/*!
# Flaca - Jpegtran

This is a very minimalist implementation of `MozJPEG`'s lossless `jpegtran`
encoder as called with `-copy none -progressive -optimize` flags.

This is made possible by forking the `mozjpeg-sys` crate, with additional
bindings from the Turbo side of things (namely `transupp.c`) that `jpegtran`
relies on.

Bindings can be regenerated by:
1. `cd mozjpeg_sys/vendor && cmake -G"Unix Makefiles" .`
2. `cp -a skel/mozjpeg_sys/jpegtran-bindgen.h mozjpeg_sys/vendor`
3. `cd mozjpeg_sys/vendor && bindgen --no-derive-copy --no-derive-debug --use-core --enable-function-attribute-detection jpegtran-bindgen.h -o OUTPATH.rs`

## Reference:

The reference materials are a bit all over the place, but the main sources
looked at to bring this all together were:
* [mozjpeg](https://github.com/mozilla/mozjpeg/blob/master/libjpeg.txt)
* [mozjpeg-sys](https://github.com/kornelski/mozjpeg-sys/blob/master/examples/reencode.rs)
* [mozjpeg-rs](https://github.com/immunant/mozjpeg-rs/blob/master/bin/jpegtran.rs)
*/

use mozjpeg_sys::{
	JCOPYOPT_NONE,
	JCROP_UNSET,
	JXFORM_NONE,
	boolean,
	jcopy_markers_execute,
	jcopy_markers_setup,
	jpeg_compress_struct,
	jpeg_copy_critical_parameters,
	jpeg_create_compress,
	jpeg_create_decompress,
	jpeg_decompress_struct,
	jpeg_destroy_compress,
	jpeg_destroy_decompress,
	jpeg_error_mgr,
	jpeg_finish_compress,
	jpeg_finish_decompress,
	jpeg_read_coefficients,
	jpeg_read_header,
	jpeg_simple_progression,
	jpeg_std_error,
	jpeg_stdio_dest,
	jpeg_stdio_src,
	jpeg_transform_info,
	jpeg_write_coefficients,
	jtransform_adjust_parameters,
	jtransform_execute_transform,
	jtransform_request_workspace,
	jvirt_barray_ptr,
};
use std::{
	ffi::CString,
	mem,
	os::unix::ffi::OsStrExt,
	path::Path,
	ptr,
};



/// Jpegtran.
pub fn jpegtran<P> (path: P) -> bool
where P: AsRef<Path> {
	let path = path.as_ref();

	path.exists() &&
		! path.is_dir() &&
		CString::new(path.as_os_str().as_bytes()).map_or(
			false,
			|ref c| unsafe { _jpegtran(c).is_ok() }
		)
}

#[allow(unused_assignments)]
/// Actual Jpegtran.
unsafe fn _jpegtran(path: &CString) -> Result<(), ()> {
	let mut transformoption: jpeg_transform_info =
		jpeg_transform_info {
			transform: JXFORM_NONE,
			perfect: 0,
			trim: 0,
			force_grayscale: 0,
			crop: 0,
			slow_hflip: 0,
			crop_width: 0,
			crop_width_set: JCROP_UNSET,
			crop_height: 0,
			crop_height_set: JCROP_UNSET,
			crop_xoffset: 0,
			crop_xoffset_set: JCROP_UNSET,
			crop_yoffset: 0,
			crop_yoffset_set: JCROP_UNSET,
			num_components: 0,
			workspace_coef_arrays: ptr::null_mut::<jvirt_barray_ptr>(),
			output_width: 0,
			output_height: 0,
			x_crop_offset: 0,
			y_crop_offset: 0,
			iMCU_sample_width: 0,
			iMCU_sample_height: 0,
		};

	let mut jsrcerr: jpeg_error_mgr = mem::zeroed();
	let mut srcinfo: jpeg_decompress_struct = mem::zeroed();
	srcinfo.common.err = jpeg_std_error(&mut jsrcerr);

	let mut jdsterr: jpeg_error_mgr = mem::zeroed();
	let mut dstinfo: jpeg_compress_struct = mem::zeroed();
	dstinfo.common.err = jpeg_std_error(&mut jdsterr);

	let mut src_coef_arrays: *mut jvirt_barray_ptr = ptr::null_mut::<jvirt_barray_ptr>();

	let mut dst_coef_arrays: *mut jvirt_barray_ptr = ptr::null_mut::<jvirt_barray_ptr>();

	// Open the file read-only.
	let mut mode = CString::new("rb").unwrap();
	let mut fh = libc::fopen(path.as_ptr(), mode.as_ptr());

	// Initialize the JPEG (de/)compression object with default error handling.
	jpeg_create_decompress(&mut srcinfo);
	jpeg_create_compress(&mut dstinfo);

	// Sync the error trace levels.
	jsrcerr.trace_level = jdsterr.trace_level;

	// Load the source file.
	jpeg_stdio_src(&mut srcinfo, fh);

	// Ignore markers.
	jcopy_markers_setup(&mut srcinfo, JCOPYOPT_NONE);

	// Read the file header to get to the goods.
	jpeg_read_header(&mut srcinfo, true as boolean);

	// Abort if transformation is not possible. We aren't cropping or anything,
	// but this method might still do something with the defaults?
	if jtransform_request_workspace(&mut srcinfo, &mut transformoption) == 0 {
		return Err(());
	}

	// Read source file as DCT coefficients.
	src_coef_arrays = jpeg_read_coefficients(&mut srcinfo);

	// Initialize destination compression parameters from source values.
	jpeg_copy_critical_parameters(&srcinfo, &mut dstinfo);

	// Adjust destination parameters if required by transform options, and sync
	// the coefficient arrays.
	dst_coef_arrays = jtransform_adjust_parameters(
		&mut srcinfo,
		&mut dstinfo,
		src_coef_arrays,
		&mut transformoption,
	);

	// Close the read handle, and re-open as a write handle.
	libc::fclose(fh);
	mode = CString::new("wb").unwrap();
	fh = libc::fopen(path.as_ptr(), mode.as_ptr());

	// Turn on "progressive" and "code optimizing" for the output.
	dstinfo.optimize_coding = true as boolean;
	jpeg_simple_progression(&mut dstinfo);

	// And load the destination file.
	jpeg_stdio_dest(&mut dstinfo, fh);

	// Start the compressor. Note: no data is written here.
	jpeg_write_coefficients(&mut dstinfo, dst_coef_arrays);

	// Make sure we aren't copying any markers.
	jcopy_markers_execute(&mut srcinfo, &mut dstinfo, JCOPYOPT_NONE);

	// Execute and write the transformation, if any.
	jtransform_execute_transform(
		&mut srcinfo,
		&mut dstinfo,
		src_coef_arrays,
		&mut transformoption,
	);

	// Finish compression and release memory.
	jpeg_finish_compress(&mut dstinfo);
	jpeg_destroy_compress(&mut dstinfo);

	jpeg_finish_decompress(&mut srcinfo);
	jpeg_destroy_decompress(&mut srcinfo);

	libc::fclose(fh);

	Ok(())
}
