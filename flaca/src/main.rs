/*!
# Flaca
*/

#![deny(
	clippy::allow_attributes_without_reason,
	clippy::correctness,
	unreachable_pub,
	unsafe_code,
)]

#![warn(
	clippy::complexity,
	clippy::nursery,
	clippy::pedantic,
	clippy::perf,
	clippy::style,

	clippy::allow_attributes,
	clippy::clone_on_ref_ptr,
	clippy::create_dir,
	clippy::filetype_is_file,
	clippy::format_push_string,
	clippy::get_unwrap,
	clippy::impl_trait_in_params,
	clippy::lossy_float_literal,
	clippy::missing_assert_message,
	clippy::missing_docs_in_private_items,
	clippy::needless_raw_strings,
	clippy::panic_in_result_fn,
	clippy::pub_without_shorthand,
	clippy::rest_pat_in_fully_bound_structs,
	clippy::semicolon_inside_block,
	clippy::str_to_string,
	clippy::string_to_string,
	clippy::todo,
	clippy::undocumented_unsafe_blocks,
	clippy::unneeded_field_pattern,
	clippy::unseparated_literal_suffix,
	clippy::unwrap_in_result,

	macro_use_extern_crate,
	missing_copy_implementations,
	missing_docs,
	non_ascii_idents,
	trivial_casts,
	trivial_numeric_casts,
	unused_crate_dependencies,
	unused_extern_crates,
	unused_import_braces,
)]

#![expect(clippy::redundant_pub_crate, reason = "Unresolvable.")]



mod error;
mod image;

pub(crate) use error::{
	EncodingError,
	FlacaError,
};
pub(crate) use image::kind::ImageKind;

use argyle::{
	Argue,
	ArgyleError,
	FLAG_HELP,
	FLAG_REQUIRED,
	FLAG_VERSION,
};
use crossbeam_channel::Receiver;
use dactyl::{
	NiceElapsed,
	NiceU64,
	traits::{
		BytesToUnsigned,
		NiceInflection,
	},
};
use dowser::{
	Dowser,
	Extension,
};
use fyi_msg::{
	BeforeAfter,
	Msg,
	MsgKind,
	Progless,
};
use std::{
	num::{
		NonZeroU32,
		NonZeroUsize,
	},
	path::Path,
	sync::{
		Arc,
		atomic::{
			AtomicBool,
			AtomicU32,
			AtomicU64,
			Ordering::{
				Acquire,
				Relaxed,
				SeqCst,
			},
		},
	},
	thread,
};



// The E_JPEG, E_JPG, and E_PNG constants are generated by build.rs.
include!(concat!(env!("OUT_DIR"), "/flaca-extensions.rs"));

/// # Maximum Resolution.
pub(crate) static MAX_RESOLUTION: AtomicU32 = AtomicU32::new(0);

/// # Total Skipped.
static SKIPPED: AtomicU64 = AtomicU64::new(0);

/// # Total Size Before.
static BEFORE: AtomicU64 = AtomicU64::new(0);

/// # Total Size After.
static AFTER: AtomicU64 = AtomicU64::new(0);



/// # Main.
///
/// This shell provides us a way to easily handle error responses. Actual
/// processing is done by `_main()`.
fn main() {
	match _main() {
		Ok(()) => {},
		Err(FlacaError::Argue(ArgyleError::WantsVersion)) => {
			println!(concat!("Flaca v", env!("CARGO_PKG_VERSION")));
		},
		Err(FlacaError::Argue(ArgyleError::WantsHelp)) => { helper(); },
		Err(e) => { Msg::error(e).die(1); },
	}
}

#[inline(never)]
/// # Actual Main.
///
/// This is the actual main, allowing us to easily bubble errors.
fn _main() -> Result<(), FlacaError> {
	// Parse CLI arguments.
	let args = Argue::new(FLAG_HELP | FLAG_REQUIRED | FLAG_VERSION)?
		.with_list();

	// Figure out which kinds we're doing.
	let kinds = match (args.switch2(b"--no-jpeg", b"--no-jpg"), args.switch(b"--no-png")) {
		(false, false) => ImageKind::All,
		(true, false) => ImageKind::Png,
		(false, true) => ImageKind::Jpeg,
		(true, true) => return Err(FlacaError::NoImages),
	};

	// Zopfli iterations.
	if let Some(n) = args.option(b"-z") {
		let n = NonZeroU32::btou(n).ok_or(FlacaError::ZopfliIterations)?;
		flapfli::set_zopfli_iterations(n);
	}

	// Pixel limits.
	if let Some(n) = args.option(b"--max-resolution") { set_pixel_limit(n)?; }

	// Figure out the maximum number of threads to use…
	let mut threads = std::thread::available_parallelism().unwrap_or(NonZeroUsize::MIN);
	if let Some(t) = args.option(b"-j") {
		if let Some(t) = t.strip_prefix(b"-").and_then(NonZeroUsize::btou) {
			threads = threads.get().checked_sub(t.get())
				.and_then(NonZeroUsize::new)
				.unwrap_or(NonZeroUsize::MIN);
		}
		else if let Some(t) = NonZeroUsize::btou(t) {
			if t < threads { threads = t; }
		}
	}

	// Find and sort the images!
	let mut paths = Dowser::default()
		.with_paths(args.args_os())
		.into_vec_filtered(|p| Extension::try_from3(p).map_or_else(
			|| Some(E_JPEG) == Extension::try_from4(p),
			|e| e == E_JPG || e == E_PNG
		));

	// Make sure we have paths, and if we only have a few, reduce the
	// number of threads accordingly.
	let total = NonZeroUsize::new(paths.len()).ok_or(FlacaError::NoImages)?;
	if total < threads { threads = total; }

	// Sort the paths for reproduceability.
	paths.sort();

	// Boot up a progress bar, if desired.
	let progress =
		if args.switch2(b"-p", b"--progress") {
			Progless::try_from(total.get()).ok().map(|p| p.with_reticulating_splines("Flaca"))
		}
		else { None };

	// Set up the killswitch.
	let killed = Arc::new(AtomicBool::new(false));
	sigint(Arc::clone(&killed), progress.clone());

	// Now onto the thread business!
	let (tx, rx) = crossbeam_channel::bounded::<&Path>(threads.get());
	thread::scope(#[inline(always)] |s| {
		// Set up the worker threads, either with or without progress.
		let mut workers = Vec::with_capacity(threads.get());
		if let Some(p) = progress.as_ref() {
			for _ in 0..threads.get() {
				workers.push(
					s.spawn(#[inline(always)] || crunch_pretty(&rx, p, kinds))
				);
			}
		}
		else {
			for _ in 0..threads.get() {
				workers.push(
					s.spawn(#[inline(always)] || crunch_quiet(&rx, kinds))
				);
			}
		}

		// Queue up all the image paths, unless CTRL+C is pressed.
		for path in &paths {
			if killed.load(Acquire) || tx.send(path).is_err() { break; }
		}

		// Disconnect and wait for the threads to finish!
		drop(tx);
		for worker in workers { let _res = worker.join(); }
	});

	// Summarize!
	if let Some(progress) = progress {
		summarize(&progress, total.get() as u64);
	}

	// Early abort?
	if killed.load(Acquire) { Err(FlacaError::Killed) }
	else { Ok(()) }
}

#[inline(never)]
/// # Worker Callback (Pretty).
///
/// This is the worker callback for pretty crunching. It listens for "new"
/// image paths and crunches them — and updates the progress bar, etc. —
/// then quits when the work has dried up.
fn crunch_pretty(rx: &Receiver::<&Path>, progress: &Progless, kinds: ImageKind) {
	#[expect(clippy::inline_always, reason = "For performance.")]
	#[inline(always)]
	/// # Noteworthy Failure?
	fn noteworthy(kinds: ImageKind, p: &Path) -> bool {
		if matches!(kinds, ImageKind::All) { true }
		else if Some(E_PNG) == Extension::try_from3(p) { kinds.supports_png() }
		else { kinds.supports_jpeg() }
	}

	while let Ok(p) = rx.recv() {
		let name = p.to_string_lossy();
		progress.add(&name);

		match crate::image::encode(p, kinds) {
			// Happy.
			Ok((b, a)) => {
				BEFORE.fetch_add(b, Relaxed);
				AFTER.fetch_add(a, Relaxed);
			},
			// Skipped.
			Err(e) => {
				SKIPPED.fetch_add(1, Relaxed);

				if ! matches!(e, EncodingError::Skipped) && noteworthy(kinds, p) {
					progress.push_msg(Msg::custom("Skipped", 11, &format!(
						"{name} \x1b[2m({})\x1b[0m",
						e.as_str(),
					)), true);
				}
			}
		}

		progress.remove(&name);
	}
}

#[inline(never)]
/// # Worker Callback (Quiet).
///
/// This is the worker callback for quiet crunching. It listens for "new" image
/// paths and crunches them, then quits when the work has dried up.
fn crunch_quiet(rx: &Receiver::<&Path>, kinds: ImageKind) {
	while let Ok(p) = rx.recv() { let _res = crate::image::encode(p, kinds); }
}

#[cold]
#[inline(never)]
/// # Print Help.
fn helper() {
	println!(concat!(
		r"
             ,--._,--.
           ,'  ,'   ,-`.
(`-.__    /  ,'   /
 `.   `--'        \__,--'-.
   `--/       ,-.  ______/
     (o-.     ,o- /
      `. ;        \    ", "\x1b[38;5;199mFlaca\x1b[0;38;5;69m v", env!("CARGO_PKG_VERSION"), "\x1b[0m", r#"
       |:          \   Brute-force, lossless
      ,'`       ,   \  JPEG and PNG compression.
     (o o ,  --'     :
      \--','.        ;
       `;;  :       /
        ;'  ;  ,' ,'
        ,','  :  '
        \ \   :
         `

USAGE:
    flaca [FLAGS] [OPTIONS] <PATH(S)>...

FLAGS:
    -h, --help        Print help information and exit.
        --no-jpeg     Skip JPEG images.
        --no-png      Skip PNG images.
    -p, --progress    Show pretty progress while minifying.
    -V, --version     Print version information and exit.

OPTIONS:
    -j <NUM>          Limit parallelization to this many threads (instead of
                      giving each logical core its own image to work on). If
                      negative, the value will be subtracted from the total
                      number of logical cores.
    -l, --list <FILE> Read (absolute) image and/or directory paths from this
                      text file — or STDIN if "-" — one entry per line, instead
                      of or in addition to (actually trailing) <PATH(S)>.
        --max-resolution <NUM>
                      Skip images containing more than <NUM> total pixels to
                      avoid potential OOM errors during decompression.
                      [default: ~4.29 billion]
    -z <NUM>          Run NUM lz77 backward/forward iterations during zopfli
                      PNG encoding passes. More iterations yield better
                      compression (up to a point), but require *significantly*
                      longer processing times. In practice, values beyond 500
                      are unlikely to save more than a few bytes, and could
                      take *days* to complete! Haha. [default: 20 or 60,
                      depending on the file size]
ARGS:
    <PATH(S)>...      One or more image and/or directory paths to losslessly
                      compress.

EARLY EXIT:
    Press "#, "\x1b[38;5;208mCTRL\x1b[0m+\x1b[38;5;208mC\x1b[0m once to quit as soon as the already-in-progress operations
    have finished (ignoring any pending images still in the queue).

    Press \x1b[38;5;208mCTRL\x1b[0m+\x1b[38;5;208mC\x1b[0m a second time if you need to exit IMMEDIATELY, but note that
    doing so may leave artifacts (temporary files) behind, and in rare cases,
    lead to image corruption.

OPTIMIZERS USED:
    MozJPEG   <https://github.com/mozilla/mozjpeg>
    Oxipng    <https://github.com/shssoichiro/oxipng>
    Zopflipng <https://github.com/google/zopfli>
"
	));
}

/// # Set Pixel Limit.
fn set_pixel_limit(raw: &[u8]) -> Result<(), FlacaError> {
	let multiplier: u32 =
		match raw.last() {
			Some(b'k' | b'K') => 1_000,
			Some(b'm' | b'M') => 1_000_000,
			Some(b'g' | b'G') => 1_000_000_000,
			None => return Err(FlacaError::MaxResolution),
			_ => 1,
		};

	let len = raw.len() - usize::from(multiplier != 1);
	let limit = NonZeroU32::btou(&raw[..len])
		.and_then(|n| n.get().checked_mul(multiplier))
		.ok_or(FlacaError::MaxResolution)?;

	MAX_RESOLUTION.store(limit, Relaxed);
	Ok(())
}

/// # Hook Up CTRL+C.
///
/// Once stops processing new items, twice forces immediate shutdown.
fn sigint(killed: Arc<AtomicBool>, progress: Option<Progless>) {
	let _res = ctrlc::set_handler(move ||
		if killed.compare_exchange(false, true, SeqCst, Relaxed).is_ok() {
			if let Some(p) = &progress { p.sigint(); }
		}
		else { std::process::exit(1); }
	);
}

/// # Summarize Results.
fn summarize(progress: &Progless, total: u64) {
	let elapsed = progress.finish();
	let skipped = SKIPPED.load(Acquire);
	if skipped == 0 {
		progress.summary(MsgKind::Crunched, "image", "images")
	}
	else {
		// And summarize what we did do.
		Msg::crunched(format!(
			"{}\x1b[2m/\x1b[0m{} in {}.",
			NiceU64::from(total - skipped),
			total.nice_inflect("image", "images"),
			NiceElapsed::from(elapsed),
		))
	}
		.with_bytes_saved(BeforeAfter::from((
			BEFORE.load(Acquire),
			AFTER.load(Acquire),
		)))
		.eprint();
}
