/*!
# Flaca
*/

#![deny(
	clippy::allow_attributes_without_reason,
	clippy::correctness,
	unreachable_pub,
	unsafe_code,
)]

#![warn(
	clippy::complexity,
	clippy::nursery,
	clippy::pedantic,
	clippy::perf,
	clippy::style,

	clippy::allow_attributes,
	clippy::clone_on_ref_ptr,
	clippy::create_dir,
	clippy::filetype_is_file,
	clippy::format_push_string,
	clippy::get_unwrap,
	clippy::impl_trait_in_params,
	clippy::lossy_float_literal,
	clippy::missing_assert_message,
	clippy::missing_docs_in_private_items,
	clippy::needless_raw_strings,
	clippy::panic_in_result_fn,
	clippy::pub_without_shorthand,
	clippy::rest_pat_in_fully_bound_structs,
	clippy::semicolon_inside_block,
	clippy::str_to_string,
	clippy::string_to_string,
	clippy::todo,
	clippy::undocumented_unsafe_blocks,
	clippy::unneeded_field_pattern,
	clippy::unseparated_literal_suffix,
	clippy::unwrap_in_result,

	macro_use_extern_crate,
	missing_copy_implementations,
	missing_docs,
	non_ascii_idents,
	trivial_casts,
	trivial_numeric_casts,
	unused_crate_dependencies,
	unused_extern_crates,
	unused_import_braces,
)]

#![expect(clippy::redundant_pub_crate, reason = "Unresolvable.")]



mod error;
mod image;

pub(crate) use error::{
	EncodingError,
	FlacaError,
};
pub(crate) use image::kind::ImageKind;

use argyle::Argument;
use crossbeam_channel::Receiver;
use dactyl::{
	NiceElapsed,
	NiceU64,
	traits::{
		BytesToUnsigned,
		NiceInflection,
	},
};
use dowser::{
	Dowser,
	Extension,
};
use fyi_msg::{
	BeforeAfter,
	Msg,
	MsgKind,
	Progless,
};
use std::{
	num::{
		NonZeroU32,
		NonZeroUsize,
	},
	path::Path,
	sync::{
		Arc,
		atomic::{
			AtomicBool,
			AtomicU32,
			AtomicU64,
			Ordering::{
				Acquire,
				Relaxed,
				SeqCst,
			},
		},
	},
	thread,
};



// The E_JPEG, E_JPG, and E_PNG constants are generated by build.rs.
include!(concat!(env!("OUT_DIR"), "/flaca-extensions.rs"));

/// # Maximum Resolution.
pub(crate) static MAX_RESOLUTION: AtomicU32 = AtomicU32::new(0);

/// # Total Skipped.
static SKIPPED: AtomicU64 = AtomicU64::new(0);

/// # Total Size Before.
static BEFORE: AtomicU64 = AtomicU64::new(0);

/// # Total Size After.
static AFTER: AtomicU64 = AtomicU64::new(0);



/// # Main.
///
/// This shell provides us a way to easily handle error responses. Actual
/// processing is done by `main__()`.
fn main() {
	match main__() {
		Ok(()) => {},
		Err(e @ (FlacaError::PrintHelp | FlacaError::PrintVersion)) => {
			println!("{e}");
		},
		Err(e) => { Msg::error(e).die(1); },
	}
}

#[inline(never)]
/// # Actual Main.
///
/// This is the actual main, allowing us to easily bubble errors.
fn main__() -> Result<(), FlacaError> {
	// Parse CLI arguments.
	let args = argyle::args()
		.with_keywords(include!(concat!(env!("OUT_DIR"), "/argyle.rs")));

	let mut kinds = ImageKind::All;
	let mut threads = None;
	let mut paths = Dowser::default();
	let mut progress = false;
	for arg in args {
		match arg {
			Argument::Key("-h" | "--help") => return Err(FlacaError::PrintHelp),
			Argument::Key("--no-jpg" | "--no-jpeg") => { kinds = kinds.diff(ImageKind::Jpeg)?; },
			Argument::Key("--no-png") => { kinds = kinds.diff(ImageKind::Png)?; },
			Argument::Key("-p" | "--progress") => { progress = true; },
			Argument::Key("-V" | "--version") => return Err(FlacaError::PrintVersion),

			Argument::KeyWithValue("-j", s) => { threads.replace(s); },

			Argument::KeyWithValue("-l" | "--list", s) => {
				paths.read_paths_from_file(s).map_err(|_| FlacaError::ListFile)?;
			},

			Argument::KeyWithValue("--max-resolution", s) => {
				set_pixel_limit(s.trim().as_bytes())?;
			},

			Argument::KeyWithValue("-z", s) => {
				let s = NonZeroU32::btou(s.trim().as_bytes())
					.ok_or(FlacaError::ZopfliIterations)?;
				if ! flapfli::set_zopfli_iterations(s) {
					return Err(FlacaError::ZopfliIterations2);
				}
			},

			// Assume these are paths.
			Argument::Other(s) => { paths = paths.with_path(s); },
			Argument::InvalidUtf8(s) => { paths = paths.with_path(s); },

			// Nothing else is relevant.
			_ => {},
		}
	}

	// Find and sort the images!
	let mut paths = paths.into_vec_filtered(dowser_filter);

	// Make sure we have paths, and if we only have a few, reduce the
	// number of threads accordingly.
	let total = NonZeroUsize::new(paths.len()).ok_or(FlacaError::NoImages)?;
	let threads = max_threads(threads, total);

	// Sort the paths for reproduceability.
	paths.sort();

	// Boot up a progress bar, if desired.
	let progress =
		if progress {
			Progless::try_from(total).ok().map(|p| p.with_reticulating_splines("Flaca"))
		}
		else { None };

	// Set up the killswitch.
	let killed = Arc::new(AtomicBool::new(false));
	sigint(Arc::clone(&killed), progress.clone());

	// Now onto the thread business!
	let mut undone: Vec<&Path> = Vec::new(); // Skipped because of CTRL+C or tx fail.
	let (tx, rx) = crossbeam_channel::bounded::<&Path>(threads.get());
	thread::scope(#[inline(always)] |s| {
		// Set up the worker threads, either with or without progress.
		let mut workers = Vec::with_capacity(threads.get());
		if let Some(p) = progress.as_ref() {
			for _ in 0..threads.get() {
				workers.push(
					s.spawn(#[inline(always)] || crunch_pretty(&rx, p, kinds))
				);
			}
		}
		else {
			for _ in 0..threads.get() {
				workers.push(
					s.spawn(#[inline(always)] || crunch_quiet(&rx, kinds))
				);
			}
		}

		// Queue up all the image paths!
		let mut already_dead = false;
		for path in &paths {
			// Early abort in progress; mark as skipped instead of giving it
			// to a worker.
			if killed.load(Acquire) {
				// Skip this path for sure.
				let mut skipped = 1_u64;
				undone.push(path);

				// But also skip anything still in the queue.
				if ! already_dead {
					already_dead = true;
					let before = undone.len();
					undone.extend(rx.try_iter());
					skipped += (undone.len() - before) as u64;
				}

				SKIPPED.fetch_add(skipped, Relaxed);
			}
			// Add the path to the queue; this shouldn't fail, but if it does
			// add it to our list so we can let the user know at the end.
			else if tx.send(path).is_err() {
				SKIPPED.fetch_add(1, Relaxed);
				undone.push(path);
			}
		}

		// Disconnect and wait for the threads to finish!
		drop(tx);
		for worker in workers { let _res = worker.join(); }
	});

	// Summarize!
	if let Some(progress) = progress { summarize(&progress, total.get() as u64); }

	// Did anything get missed?
	if ! undone.is_empty() { dump_undone(&undone); }

	// Early abort?
	if killed.load(Acquire) { Err(FlacaError::Killed) }
	else { Ok(()) }
}

#[inline(never)]
/// # Worker Callback (Pretty).
///
/// This is the worker callback for pretty crunching. It listens for "new"
/// image paths and crunches them — and updates the progress bar, etc. —
/// then quits when the work has dried up.
fn crunch_pretty(rx: &Receiver::<&Path>, progress: &Progless, kinds: ImageKind) {
	#[expect(clippy::inline_always, reason = "For performance.")]
	#[inline(always)]
	/// # Noteworthy Failure?
	fn noteworthy(kinds: ImageKind, p: &Path) -> bool {
		if matches!(kinds, ImageKind::All) { true }
		else if Some(E_PNG) == Extension::try_from3(p) { kinds.supports_png() }
		else { kinds.supports_jpeg() }
	}

	while let Ok(p) = rx.recv() {
		let name = p.to_string_lossy();
		progress.add(&name);

		match crate::image::encode(p, kinds) {
			// Happy.
			Ok((b, a)) => {
				BEFORE.fetch_add(b, Relaxed);
				AFTER.fetch_add(a, Relaxed);
			},
			// Skipped.
			Err(e) => {
				SKIPPED.fetch_add(1, Relaxed);

				if ! matches!(e, EncodingError::Skipped) && noteworthy(kinds, p) {
					progress.push_msg(Msg::skipped(format!(
						"{name} \x1b[2m({})\x1b[0m",
						e.as_str(),
					)), true);
				}
			}
		}

		progress.remove(&name);
	}
}

#[inline(never)]
/// # Worker Callback (Quiet).
///
/// This is the worker callback for quiet crunching. It listens for "new" image
/// paths and crunches them, then quits when the work has dried up.
fn crunch_quiet(rx: &Receiver::<&Path>, kinds: ImageKind) {
	while let Ok(p) = rx.recv() { let _res = crate::image::encode(p, kinds); }
}

#[inline]
/// # Dowser Filter.
fn dowser_filter(p: &Path) -> bool {
	Extension::try_from3(p).map_or_else(
		|| Some(E_JPEG) == Extension::try_from4(p),
		|e| e == E_JPG || e == E_PNG
	)
}

#[cold]
/// # Dump Undone.
///
/// When aborting early, the unprocessed entries get dumped to a temporary
/// file, potentially.
fn dump_undone(undone: &[&Path]) {
	// Merge the paths into a line-separated list, if we can.
	let mut dump = String::new();
	for p in undone {
		let Some(p) = p.to_str() else { return; };
		dump.push_str(p);
		dump.push('\n');
	}

	// Save it if we can.
	let path = std::env::temp_dir().join(format!("flaca-{}.txt", utc2k::unixtime()));
	if write_atomic::write_file(&path, dump.as_bytes()).is_ok() {
		Msg::notice(format!(
			"{} missed during the run; their paths have
        been exported to \x1b[95;1m{}\x1b[0m for reference.",
			undone.len().nice_inflect("image was", "images were"),
			path.display(),
		)).eprint();
	}
}

/// # Max Threads.
///
/// Given the hardware, user preference, and total number of jobs, calculate
/// and return the maximum number of threads to spawn.
fn max_threads(user: Option<String>, jobs: NonZeroUsize) -> NonZeroUsize {
	// The default number.
	let mut threads = std::thread::available_parallelism().unwrap_or(NonZeroUsize::MIN);

	// Lower it if the user wants differently.
	if let Some(t) = user {
		let t = t.trim().as_bytes();
		if let Some(t) = t.strip_prefix(b"-").and_then(NonZeroUsize::btou) {
			threads = threads.get().checked_sub(t.get())
				.and_then(NonZeroUsize::new)
				.unwrap_or(NonZeroUsize::MIN);
		}
		else if let Some(t) = NonZeroUsize::btou(t) {
			if t < threads { threads = t; }
		}
	}

	// Return the smaller of the user/machine and job counts.
	NonZeroUsize::min(threads, jobs)
}

/// # Set Pixel Limit.
fn set_pixel_limit(raw: &[u8]) -> Result<(), FlacaError> {
	let multiplier: u32 =
		match raw.last() {
			Some(b'k' | b'K') => 1_000,
			Some(b'm' | b'M') => 1_000_000,
			Some(b'g' | b'G') => 1_000_000_000,
			None => return Err(FlacaError::MaxResolution),
			_ => 1,
		};

	let len = raw.len() - usize::from(multiplier != 1);
	let limit = NonZeroU32::btou(&raw[..len])
		.and_then(|n| n.get().checked_mul(multiplier))
		.ok_or(FlacaError::MaxResolution)?;

	MAX_RESOLUTION.store(limit, Relaxed);
	Ok(())
}

/// # Hook Up CTRL+C.
///
/// Once stops processing new items, twice forces immediate shutdown.
fn sigint(killed: Arc<AtomicBool>, progress: Option<Progless>) {
	let _res = ctrlc::set_handler(move ||
		if killed.compare_exchange(false, true, SeqCst, Relaxed).is_ok() {
			if let Some(p) = &progress { p.sigint(); }
		}
		else { std::process::exit(1); }
	);
}

/// # Summarize Results.
fn summarize(progress: &Progless, total: u64) {
	let elapsed = progress.finish();
	let skipped = SKIPPED.load(Acquire);
	if skipped == 0 {
		progress.summary(MsgKind::Crunched, "image", "images")
	}
	else {
		// And summarize what we did do.
		Msg::crunched(format!(
			"{}\x1b[2m/\x1b[0m{} in {}.",
			NiceU64::from(total - skipped),
			total.nice_inflect("image", "images"),
			NiceElapsed::from(elapsed),
		))
	}
		.with_bytes_saved(BeforeAfter::from((
			BEFORE.load(Acquire),
			AFTER.load(Acquire),
		)))
		.eprint();
}
