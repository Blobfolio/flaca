/*!
# Flaca
*/

#![deny(
	clippy::allow_attributes_without_reason,
	clippy::correctness,
	unreachable_pub,
	unsafe_code,
)]

#![warn(
	clippy::complexity,
	clippy::nursery,
	clippy::pedantic,
	clippy::perf,
	clippy::style,

	clippy::allow_attributes,
	clippy::clone_on_ref_ptr,
	clippy::create_dir,
	clippy::filetype_is_file,
	clippy::format_push_string,
	clippy::get_unwrap,
	clippy::impl_trait_in_params,
	clippy::lossy_float_literal,
	clippy::missing_assert_message,
	clippy::missing_docs_in_private_items,
	clippy::needless_raw_strings,
	clippy::panic_in_result_fn,
	clippy::pub_without_shorthand,
	clippy::rest_pat_in_fully_bound_structs,
	clippy::semicolon_inside_block,
	clippy::str_to_string,
	clippy::string_to_string,
	clippy::todo,
	clippy::undocumented_unsafe_blocks,
	clippy::unneeded_field_pattern,
	clippy::unseparated_literal_suffix,
	clippy::unwrap_in_result,

	macro_use_extern_crate,
	missing_copy_implementations,
	missing_docs,
	non_ascii_idents,
	trivial_casts,
	trivial_numeric_casts,
	unused_crate_dependencies,
	unused_extern_crates,
	unused_import_braces,
)]

#![expect(clippy::redundant_pub_crate, reason = "Unresolvable.")]



mod crawl;
mod error;
mod img;
mod opts;

use error::{
	EncodingError,
	FlacaError,
};
use img::kind::ImageKind;
use opts::Settings;

use argyle::Argument;
use crawl::Crawler;
use crossbeam_channel::{
	Receiver,
	Sender,
};
use dactyl::{
	NiceElapsed,
	NiceU64,
	traits::{
		BytesToUnsigned,
		NiceInflection,
	},
};
use dowser::Extension;
use fyi_msg::{
	fyi_ansi::{
		ansi,
		dim,
	},
	BeforeAfter,
	Msg,
	MsgKind,
	Progless,
	ProglessTaskGuard,
};
use std::{
	num::{
		NonZeroU32,
		NonZeroUsize,
	},
	path::Path,
	process::ExitCode,
	sync::atomic::{
		AtomicU64,
		Ordering::SeqCst,
	},
	thread,
};



// The E_JPEG, E_JPG, and E_PNG constants are generated by build.rs.
include!(concat!(env!("OUT_DIR"), "/flaca-extensions.rs"));

/// # Total Skipped.
static SKIPPED: AtomicU64 = AtomicU64::new(0);

/// # Total Size Before.
static BEFORE: AtomicU64 = AtomicU64::new(0);

/// # Total Size After.
static AFTER: AtomicU64 = AtomicU64::new(0);



/// # Main.
///
/// This shell provides us a way to easily handle error responses. Actual
/// processing is done by `main__()`.
fn main() -> ExitCode {
	match main__() {
		Ok(()) => ExitCode::SUCCESS,
		Err(e @ (FlacaError::PrintHelp | FlacaError::PrintVersion)) => {
			println!("{e}");
			ExitCode::SUCCESS
		},
		Err(FlacaError::Killed) => {
			Msg::aborted(FlacaError::Killed.as_str()).eprint();
			ExitCode::FAILURE
		},
		Err(e) => {
			Msg::error(e.to_string()).eprint();
			ExitCode::FAILURE
		},
	}
}

#[inline(never)]
/// # Actual Main.
///
/// This is the actual main, allowing us to easily bubble errors.
fn main__() -> Result<(), FlacaError> {
	// Parse CLI arguments.
	let args = argyle::args()
		.with_keywords(include!(concat!(env!("OUT_DIR"), "/argyle.rs")));

	let mut settings = Settings::new();
	let mut threads = None;
	let mut paths = Crawler::new();
	let mut progress = false;
	for arg in args {
		match arg {
			Argument::Key("-h" | "--help") => return Err(FlacaError::PrintHelp),
			Argument::Key("--no-gif") => { settings.unset_kind(ImageKind::Gif)?; },
			Argument::Key("--no-jpg" | "--no-jpeg") => { settings.unset_kind(ImageKind::Jpeg)?; },
			Argument::Key("--no-png") => { settings.unset_kind(ImageKind::Png)?; },
			Argument::Key("--no-symlinks") => { paths.no_symlinks(); },
			Argument::Key("--preserve-times") => { settings.set_preserve_times(); },
			Argument::Key("-p" | "--progress") => { progress = true; },
			Argument::Key("-V" | "--version") => return Err(FlacaError::PrintVersion),

			Argument::KeyWithValue("-j", s) => { threads.replace(s); },

			Argument::KeyWithValue("-l" | "--list", s) => { paths.push_list(s); },

			Argument::KeyWithValue("--max-pixels", s) => {
				settings.set_max_pixels_raw(s.trim().as_bytes())?;
			},

			Argument::KeyWithValue("-z", s) => {
				let s = NonZeroU32::btou(s.trim().as_bytes())
					.ok_or(FlacaError::ZopfliIterations)?;
				if ! flapfli::set_zopfli_iterations(s) {
					return Err(FlacaError::ZopfliIterations2);
				}
			},

			Argument::Path(s) => { paths.push_path(s); },

			// Mistakes?
			Argument::Other(s) => return Err(FlacaError::InvalidCli(s)),
			Argument::InvalidUtf8(s) => return Err(FlacaError::InvalidCli(s.to_string_lossy().into_owned())),

			// Nothing else is relevant.
			_ => {},
		}
	}

	// Make sure we have paths, and if we only have a few, reduce the
	// number of threads accordingly.
	let paths = paths.crawl()?;
	let total = NonZeroUsize::new(paths.len()).ok_or(FlacaError::NoImages)?;
	let threads = max_threads(threads, total);

	// Set up the killswitch.
	let killed = Progless::sigint_two_strike();

	// Boot up a progress bar, if desired.
	let progress =
		if progress {
			Progless::try_from(total).ok().map(|p| p.with_reticulating_splines("Flaca"))
		}
		else { None };

	// Now onto the thread business!
	let mut undone: Vec<&Path> = Vec::new(); // Skipped because of CTRL+C or tx fail.
	let (tx, rx) = crossbeam_channel::bounded::<&Path>(threads.get());
	let (gtx, grx) = crossbeam_channel::bounded::<(&Path, Option<ProglessTaskGuard>)>(0); // For GIFs.
	thread::scope(#[inline(always)] |s| {
		// Set up the worker threads, either with or without progress.
		let mut workers = Vec::with_capacity(threads.get() + 1);
		for _ in 0..threads.get() {
			let t_gtx = gtx.clone();
			workers.push(
				s.spawn(#[inline(always)] || crunch(&rx, settings, progress.as_ref(), t_gtx))
			);
		}

		// GIFs require a dedicated worker/thread. Since it is fed by the other
		// workers, it needs to come last.
		drop(gtx);
		workers.push(
			s.spawn(#[inline(always)] || crunch_gif(grx, settings, progress.as_ref()))
		);

		// Queue up all the image paths!
		let mut already_dead = false;
		for path in &paths {
			// Early abort in progress; mark as skipped instead of giving it
			// to a worker.
			if killed.load(SeqCst) {
				// Skip this path for sure.
				let mut skipped = 1_u64;
				undone.push(path);

				// But also skip anything still in the queue.
				if ! already_dead {
					already_dead = true;
					let before = undone.len();
					undone.extend(rx.try_iter());
					skipped += (undone.len() - before) as u64;
				}

				SKIPPED.fetch_add(skipped, SeqCst);
			}
			// Add the path to the queue; this shouldn't fail, but if it does
			// add it to our list so we can let the user know at the end.
			else if tx.send(path).is_err() {
				SKIPPED.fetch_add(1, SeqCst);
				undone.push(path);
			}
		}

		// Disconnect and wait for the threads to finish!
		drop(tx);
		for worker in workers { let _res = worker.join(); }
	});

	// Clean up.
	drop(rx);

	// Summarize!
	if let Some(progress) = progress { summarize(&progress, total.get() as u64); }

	// Did anything get missed?
	if ! undone.is_empty() { dump_undone(&undone); }

	// Early abort?
	if killed.load(SeqCst) { Err(FlacaError::Killed) }
	else { Ok(()) }
}

#[inline(never)]
#[expect(clippy::needless_pass_by_value, reason = "Required for lifetime.")]
/// # Worker Callback.
///
/// This is the worker callback for image crunching. It listens for "new" image
/// paths and crunches them — and maybe updates the progress bar, etc. — then
/// quits as soon as the work has dried up.
fn crunch<'a, 'b>(
	rx: &Receiver::<&'a Path>,
	settings: Settings,
	progress: Option<&'b Progless>,
	gtx: Sender::<(&'a Path, Option<ProglessTaskGuard<'b>>)>,
) {
	// We might not need to do all the fancy pretty business.
	let Some(progress) = progress else {
		while let Ok(p) = rx.recv() {
			if matches!(crate::img::encode(p, settings), Err(EncodingError::TbdGif)) {
				let _res = gtx.send((p, None));
			}
		}
		return;
	};

	while let Ok(p) = rx.recv() {
		let name = p.to_string_lossy();
		let task = progress.task(&name);

		match crate::img::encode(p, settings) {
			// Happy.
			Ok((b, a)) => {
				BEFORE.fetch_add(b, SeqCst);
				AFTER.fetch_add(a, SeqCst);
			},
			// Skipped.
			Err(e) => {
				// Send GIFs to the dedicated GIF thread.
				if matches!(e, EncodingError::TbdGif) && gtx.send((p, task)).is_ok() {
					continue;
				}

				SKIPPED.fetch_add(1, SeqCst);

				if ! matches!(e, EncodingError::Skipped) && noteworthy(settings.kinds(), p) {
					let _res = progress.push_msg(Msg::skipped(format!(
						concat!("{} ", dim!("({})")),
						name,
						e.as_str(),
					)));
				}
			}
		}
	}
}

#[inline(never)]
#[expect(clippy::needless_pass_by_value, reason = "Required for lifetime.")]
/// # Gif Cruncher.
///
/// Gifsicle crunching cannot be done simultaneously. This dedicated worker
/// handles any GIFs that happen to come up, one at a time.
fn crunch_gif<'a>(
	rx: Receiver::<(&Path, Option<ProglessTaskGuard<'a>>)>,
	settings: Settings,
	progress: Option<&'a Progless>
) {
	// We might not need to do all the fancy pretty business.
	let Some(progress) = progress else {
		while let Ok((p, _)) = rx.recv() { let _res = crate::img::encode_gif(p, settings); }
		return;
	};

	while let Ok((p, task)) = rx.recv() {
		match crate::img::encode_gif(p, settings) {
			// Happy.
			Ok((b, a)) => {
				BEFORE.fetch_add(b, SeqCst);
				AFTER.fetch_add(a, SeqCst);
			},
			// Skipped.
			Err(e) => {
				SKIPPED.fetch_add(1, SeqCst);

				if ! matches!(e, EncodingError::Skipped) && noteworthy(settings.kinds(), p) {
					let _res = progress.push_msg(Msg::skipped(format!(
						concat!("{} ", dim!("({})")),
						p.display(),
						e.as_str(),
					)));
				}
			}
		}

		// Explicitly drop so Rust knows we're using it.
		drop(task);
	}
}

#[cold]
/// # Dump Undone.
///
/// When aborting early, the unprocessed entries get dumped to a temporary
/// file, potentially.
fn dump_undone(undone: &[&Path]) {
	// Merge the paths into a line-separated list, if we can.
	let mut dump = String::new();
	for p in undone {
		let Some(p) = p.to_str() else { return; };
		dump.push_str(p);
		dump.push('\n');
	}

	// Save it if we can.
	let path = std::env::temp_dir().join(format!("flaca-{}.txt", utc2k::unixtime()));
	if write_atomic::write_file(&path, dump.as_bytes()).is_ok() {
		Msg::notice(format!(
			concat!(
				"{} missed during the run; their paths have\n        been exported to ",
        		ansi!((bold, light_magenta) "{}"),
        		" for reference.",
        	),
			undone.len().nice_inflect("image was", "images were"),
			path.display(),
		)).eprint();
	}
}

/// # Max Threads.
///
/// Given the hardware, user preference, and total number of jobs, calculate
/// and return the maximum number of threads to spawn.
fn max_threads(user: Option<String>, jobs: NonZeroUsize) -> NonZeroUsize {
	// The default number.
	let mut threads = std::thread::available_parallelism().unwrap_or(NonZeroUsize::MIN);

	// Lower it if the user wants differently.
	if let Some(t) = user {
		let t = t.trim().as_bytes();
		if let Some(t) = t.strip_prefix(b"-").and_then(NonZeroUsize::btou) {
			threads = threads.get().checked_sub(t.get())
				.and_then(NonZeroUsize::new)
				.unwrap_or(NonZeroUsize::MIN);
		}
		else if let Some(t) = NonZeroUsize::btou(t) && t < threads { threads = t; }
	}

	// Return the smaller of the user/machine and job counts.
	NonZeroUsize::min(threads, jobs)
}

#[expect(clippy::inline_always, reason = "For performance.")]
#[inline(always)]
/// # Noteworthy Failure?
///
/// This method is used by the worker threads to decide whether or not a
/// failure is worth printing to the screen. (Errors related to disabled
/// types are suppressed.)
fn noteworthy(kinds: ImageKind, p: &Path) -> bool {
	matches!(kinds, ImageKind::All) ||
	ImageKind::try_from_ext(p).is_some_and(|k| kinds.contains(k))
}

/// # Summarize Results.
fn summarize(progress: &Progless, total: u64) {
	let elapsed = progress.finish();
	let skipped = SKIPPED.load(SeqCst);
	if skipped == 0 {
		progress.summary(MsgKind::Crunched, "image", "images")
	}
	else {
		// And summarize what we did do.
		Msg::crunched(format!(
			concat!(
				"{}",
				dim!("/"),
				"{} in {}.",
			),
			NiceU64::from(total - skipped),
			total.nice_inflect("image", "images"),
			NiceElapsed::from(elapsed),
		))
	}
		.with_bytes_saved(BeforeAfter::from((
			BEFORE.load(SeqCst),
			AFTER.load(SeqCst),
		)))
		.eprint();
}
