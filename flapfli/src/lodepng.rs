/*!
# Flapfli: Lodepng.

This module contains FFI bindings to `lodepng.c`.
*/

#![allow(non_camel_case_types, non_upper_case_globals)]

use crate::{
	ffi::{
		flapfli_allocate,
		flapfli_free,
	},
	ZOPFLI_ITERATIONS,
};
use std::{
	cell::RefCell,
	ffi::{
		c_uchar,
		c_uint,
	},
	mem::MaybeUninit,
	num::NonZeroUsize,
	sync::atomic::Ordering::Relaxed,
};
use super::{
	deflate_part,
	EncodedPNG,
	reset_dynamic_length_cache,
	ZOPFLI_MASTER_BLOCK_SIZE,
	ZopfliChunk,
	ZopfliState,
};



// Generated by build.rs.
include!(concat!(env!("OUT_DIR"), "/lodepng-bindgen.rs"));



#[no_mangle]
#[allow(unsafe_code)]
/// # Custom PNG Deflate.
///
/// This tells lodepng to use zopfli for encoding.
pub(crate) extern "C" fn flaca_png_deflate(
	out: *mut *mut c_uchar,
	outsize: *mut usize,
	arr: *const c_uchar,
	insize: usize,
	_settings: *const LodePNGCompressSettings,
) -> c_uint {
	thread_local!(
		static STATES: RefCell<Box<ZopfliState>> = RefCell::new(ZopfliState::new())
	);

	// Group the pointer crap to cut down on the number of args being
	// passed around.
	let mut dst = ZopfliOut {
		bp: 0,
		out,
		outsize,
	};

	// Make a proper slice out of the data.
	let arr = unsafe { std::slice::from_raw_parts(arr, insize) };

	// Figure out how many iterations to use.
	let mut numiterations = ZOPFLI_ITERATIONS.load(Relaxed);
	if numiterations <= 0 {
		numiterations = if arr.len() < 200_000 { 60 } else { 20 };
	}

	// The RLE cache lives for the duration of the image; let's go ahead and
	// reset that now.
	reset_dynamic_length_cache();

	// Compress in chunks, Ã  la ZopfliDeflate.
	for chunk in DeflateIter::new(arr) {
		#[cfg(not(debug_assertions))]
		if STATES.with_borrow_mut(|state| deflate_part(
			state,
			numiterations,
			chunk.total_len().get() == arr.len(),
			chunk,
			&mut dst,
		)).is_err() { return 1; };

		#[cfg(debug_assertions)]
		if let Err(e) = STATES.with_borrow_mut(|state| deflate_part(
			state,
			numiterations,
			chunk.total_len().get() == arr.len(),
			chunk,
			&mut dst,
		)) { panic!("{e}"); };
	}

	// Errors panic, so if we're here everything must be fine.
	0
}

#[no_mangle]
#[inline(always)]
#[allow(unsafe_code, clippy::inline_always)]
/// # Lodepng CRC32.
///
/// Replace lodepng's native CRC32 hashing method with Rust's (faster)
/// `crc32fast`.
pub(crate) extern "C" fn lodepng_crc32(buf: *const c_uchar, len: usize) -> c_uint {
	let mut h = crc32fast::Hasher::new();
	h.update(unsafe { std::slice::from_raw_parts(buf, len) });
	h.finalize()
}



#[derive(Debug)]
/// # Decoded Image.
pub(super) struct DecodedImage {
	pub(super) buf: *mut c_uchar,
	pub(super) w: c_uint,
	pub(super) h: c_uint,
}

impl Drop for DecodedImage {
	#[allow(unsafe_code)]
	fn drop(&mut self) {
		unsafe { flapfli_free(self.buf); }
		self.buf = std::ptr::null_mut();
	}
}



/// # Lodepng Output Pointers.
///
/// This struct provides a wrapper around the lingering bit-writing zopfli C
/// methods, saving us the trouble of having to pass down three different
/// pointers (and using a bunch of unsafe blocks) just to get the data saved.
pub(super) struct ZopfliOut {
	bp: u8,
	out: *mut *mut u8,
	outsize: *mut usize,
}

impl ZopfliOut {
	#[allow(unsafe_code)]
	#[inline]
	/// # Append Data.
	fn append_data(&mut self, value: u8) {
		#[cold]
		/// # Allocate.
		unsafe fn alloc_cold(ptr: *mut u8, size: usize) -> *mut u8 {
			flapfli_allocate(
				ptr,
				NonZeroUsize::new(size * 2).unwrap_or(NonZeroUsize::MIN),
			)
		}

		unsafe {
			// Dereferencing this size gets annoying quick! Haha.
			let size = *self.outsize;

			// (Re)allocate if size is a power of two, or empty.
			if 0 == (size & size.wrapping_sub(1)) {
				*self.out = alloc_cold(*self.out, size);
			}

			(*self.out).add(size).write(value);
			self.outsize.write(size + 1);
		}
	}
}

impl ZopfliOut {
	#[inline]
	/// # Add Bit.
	pub(crate) fn add_bit(&mut self, bit: u8) {
		if self.bp == 0 { self.append_data(0); }
		#[allow(unsafe_code)]
		unsafe {
			// Safety: `append_data` writes a byte to `outsize` and then
			// increments it, so to reach and modify that same position we need
			// to use `outsize - 1` instead.
			*(*self.out).add(*self.outsize - 1) |= bit << self.bp;
		}
		self.bp = self.bp.wrapping_add(1) & 7;
	}

	/// # Add Multiple Bits.
	pub(crate) fn add_bits(&mut self, symbol: u32, length: u32) {
		for i in 0..length {
			let bit = (symbol >> i) & 1;
			self.add_bit(bit as u8);
		}
	}

	/// # Add Type Bits Header.
	pub(crate) fn add_header(&mut self, last_block: bool, block_bit: u8) {
		self.add_bit(u8::from(last_block));
		self.add_bit(block_bit & 1);
		self.add_bit((block_bit & 2) >> 1);
	}

	/// # Add Huffman Bits.
	pub(crate) fn add_huffman_bits(&mut self, symbol: u32, length: u32) {
		// Same as add_bits, except we're doing it backwards.
		for i in (0..length).rev() {
			let bit = (symbol >> i) & 1;
			self.add_bit(bit as u8);
		}
	}

	#[allow(clippy::cast_possible_truncation)]
	/// # Add Non-Compressed Block.
	pub(crate) fn add_uncompressed_block(
		&mut self,
		last_block: bool,
		chunk: ZopfliChunk<'_>,
	) {
		// We need to proceed u16::MAX bytes at a time.
		let iter = chunk.block().chunks(usize::from(u16::MAX));
		let len = iter.len() - 1;
		for (i, block) in iter.enumerate() {
			let blocksize = block.len();
			let nlen = ! blocksize;
			let really_last_block = i == len;

			// Each chunk gets its own header.
			self.add_header(last_block && really_last_block, 0);

			// Ignore bits of input up to the next byte boundary.
			self.bp = 0;

			self.append_data((blocksize % 256) as u8);
			self.append_data((blocksize.wrapping_div(256) % 256) as u8);
			self.append_data((nlen % 256) as u8);
			self.append_data((nlen.wrapping_div(256) % 256) as u8);

			for bit in block.iter().copied() { self.append_data(bit); }
		}
	}
}



impl Default for LodePNGColorStats {
	#[allow(unsafe_code)]
	fn default() -> Self {
		let mut out = MaybeUninit::<Self>::zeroed();
		unsafe {
			// Safety: lodepng_color_stats_init sets the data.
			lodepng_color_stats_init(out.as_mut_ptr());
			out.assume_init()
		}
	}
}

impl LodePNGColorType {
	/// # Confirm Raw Image Color Type
	///
	/// This reads the color type from the raw image header to check if it
	/// matches `self`.
	///
	/// Note to future self: 25 == 16 (start of IHDR chunk) + 4 (be32 width) + 4
	/// (be32 height) + 1 (bitdepth).
	pub(super) const fn is_match(self, src: &[u8]) -> bool {
		25 < src.len() && src[25] == self as u8
	}
}

impl Default for LodePNGState {
	#[allow(unsafe_code)]
	fn default() -> Self {
		let mut out = MaybeUninit::<Self>::zeroed();
		unsafe {
			// Safety: lodepng_state_init sets the data.
			lodepng_state_init(out.as_mut_ptr());
			out.assume_init()
		}
	}
}

impl Drop for LodePNGState {
	#[allow(unsafe_code)]
	fn drop(&mut self) { unsafe { lodepng_state_cleanup(self) } }
}

impl LodePNGState {
	#[allow(unsafe_code)]
	/// # Decode!
	pub(super) fn decode(&mut self, src: &[u8]) -> Option<DecodedImage> {
		let mut buf = std::ptr::null_mut();
		let mut w = 0;
		let mut h = 0;

		// Safety: a non-zero response is an error.
		let res = unsafe {
			lodepng_decode(&mut buf, &mut w, &mut h, self, src.as_ptr(), src.len())
		};

		// Return it if we got it.
		if 0 == res && ! buf.is_null() && 0 != w && 0 != h {
			Some(DecodedImage { buf, w, h })
		}
		else { None }
	}

	#[allow(unsafe_code)]
	/// # Encode!
	///
	/// Returns true if there were no errors and the result is non-empty.
	pub(super) fn encode(&mut self, img: &DecodedImage, out: &mut EncodedPNG) -> bool {
		// Reset the size.
		out.size = 0;

		// Safety: a non-zero response is an error.
		let res = unsafe {
			lodepng_encode(&mut out.buf, &mut out.size, img.buf, img.w, img.h, self)
		};

		0 == res && ! out.is_null()
	}

	#[allow(unsafe_code)]
	/// # Set Up Encoder.
	///
	/// This configures and returns a new state for encoding purposes.
	pub(super) fn encoder(dec: &Self) -> Option<Self> {
		let mut enc = Self::default();

		// Copy palette details over to the encoder.
		if dec.info_png.color.colortype == LodePNGColorType::LCT_PALETTE {
			// Safety: a non-zero response indicates an error.
			if 0 != unsafe {
				lodepng_color_mode_copy(&mut enc.info_raw, &dec.info_png.color)
			} { return None; }

			enc.info_raw.colortype = LodePNGColorType::LCT_RGBA;
			enc.info_raw.bitdepth = 8;
		}

		enc.encoder.filter_palette_zero = 0;
		enc.encoder.filter_strategy = LodePNGFilterStrategy::LFS_ZERO;
		enc.encoder.zlibsettings.windowsize = 8_192;

		Some(enc)
	}

	/// # Change Strategies.
	pub(super) fn set_strategy(&mut self, strategy: LodePNGFilterStrategy) {
		self.encoder.filter_strategy = strategy;
	}

	/// # Prepare for Zopfli.
	pub(super) fn set_zopfli(&mut self) {
		self.encoder.zlibsettings.windowsize = 32_768;
		self.encoder.zlibsettings.custom_deflate = Some(flaca_png_deflate);
	}

	#[allow(unsafe_code)]
	#[inline(never)]
	/// # Paletteless Encode (for small images).
	///
	/// Patch the encoder settings to see if we can squeeze even more savings
	/// out of the (small) image, reencode it, and return the result if there
	/// are no errors.
	///
	/// Note: the caller will need to check the resulting size to see if
	/// savings were actually achieved.
	pub(super) fn try_small(&mut self, img: &DecodedImage) -> Option<EncodedPNG> {
		// Safety: a non-zero response is an error.
		let mut stats = LodePNGColorStats::default();
		if 0 != unsafe {
			lodepng_compute_color_stats(&mut stats, img.buf, img.w, img.h, &self.info_raw)
		} { return None; }

		// The image is too small for tRNS chunk overhead.
		if img.w * img.h <= 16 && 0 != stats.key { stats.alpha = 1; }

		// Set the encoding color mode to RGB/RGBA.
		self.encoder.auto_convert = 0;
		self.info_png.color.colortype = match (0 != stats.colored, 0 != stats.alpha) {
			(true, false) => LodePNGColorType::LCT_RGB,
			(true, true) => LodePNGColorType::LCT_RGBA,
			(false, false) => LodePNGColorType::LCT_GREY,
			(false, true) => LodePNGColorType::LCT_GREY_ALPHA,
		};
		self.info_png.color.bitdepth = u32::min(8, stats.bits);

		// Rekey if necessary.
		if 0 == stats.alpha && 0 != stats.key {
			self.info_png.color.key_defined = 1;
			self.info_png.color.key_r = c_uint::from(stats.key_r) & 255;
			self.info_png.color.key_g = c_uint::from(stats.key_g) & 255;
			self.info_png.color.key_b = c_uint::from(stats.key_b) & 255;
		}
		else { self.info_png.color.key_defined = 0; }

		// Re-encode it and see what happens!
		let mut out = EncodedPNG::new();
		if self.encode(img, &mut out) { Some(out) }
		else { None }
	}
}



/// # Deflate Chunk Iterator.
///
/// This yields slices of `arr` from the beginning, increasing the length each
/// time by `ZOPFLI_MASTER_BLOCK_SIZE`.
struct DeflateIter<'a> {
	arr: &'a [u8],
	pos: usize,
}

impl<'a> Iterator for DeflateIter<'a> {
	type Item = ZopfliChunk<'a>;

	fn next(&mut self) -> Option<Self::Item> {
		if self.pos < self.arr.len() {
			let pos = self.pos;
			let chunk = self.arr.get(..pos + ZOPFLI_MASTER_BLOCK_SIZE).unwrap_or(self.arr);
			self.pos = chunk.len();
			ZopfliChunk::new(chunk, pos).ok()
		}
		else { None }
	}

	fn size_hint(&self) -> (usize, Option<usize>) {
		let len = self.len();
		(len, Some(len))
	}
}

impl<'a> ExactSizeIterator for DeflateIter<'a> {
	fn len(&self) -> usize {
		(self.arr.len() - self.pos).div_ceil(ZOPFLI_MASTER_BLOCK_SIZE)
	}
}

impl<'a> DeflateIter<'a> {
	/// # New.
	const fn new(arr: &'a [u8]) -> Self {
		Self { arr, pos: 0 }
	}
}



#[cfg(test)]
#[allow(deref_nullptr, non_snake_case, trivial_casts, unsafe_code)]
mod tests {
	use super::*;

	#[test]
	fn t_color_type_is_match() {
		for (p, t) in [
			("../skel/assets/png/01.png", LodePNGColorType::LCT_RGB),
			("../skel/assets/png/02.png", LodePNGColorType::LCT_RGBA),
			("../skel/assets/png/04.png", LodePNGColorType::LCT_GREY),
			("../skel/assets/png/small-bwa.png", LodePNGColorType::LCT_GREY_ALPHA),
		] {
			let raw = match std::fs::read(p) {
				Ok(x) => x,
				_ => panic!("Missing {}", p),
			};
			assert!(t.is_match(&raw));
		}

		// Let's test a negative to make sure we aren't doing something silly.
		let raw = std::fs::read("../skel/assets/png/01.png").unwrap();
		assert!(! LodePNGColorType::LCT_GREY.is_match(&raw));
	}

	// Generated by build.rs (layout tests).
	include!(concat!(env!("OUT_DIR"), "/lodepng-bindgen-tests.rs"));
}
