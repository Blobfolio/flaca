diff --git a/zopfli/blocksplitter.c b/zopfli/blocksplitter.c
index 161783d..33062bb 100644
--- a/zopfli/blocksplitter.c
+++ b/zopfli/blocksplitter.c
@@ -24,8 +24,6 @@ Author: jyrki.alakuijala@gmail.com (Jyrki Alakuijala)
 #include <stdlib.h>
 
 #include "deflate.h"
-#include "squeeze.h"
-#include "tree.h"
 #include "util.h"
 
 /*
@@ -62,7 +60,7 @@ static size_t FindMinimum(FindMinimumFun f, void* context,
     size_t p[NUM];
     double vp[NUM];
     size_t besti;
-    double best;
+    double best = ZOPFLI_LARGE_FLOAT;
     double lastbest = ZOPFLI_LARGE_FLOAT;
     size_t pos = start;
 
@@ -71,6 +69,10 @@ static size_t FindMinimum(FindMinimumFun f, void* context,
 
       for (i = 0; i < NUM; i++) {
         p[i] = start + (i + 1) * ((end - start) / (NUM + 1));
+        if(pos == p[i]){
+          vp[i] = best;
+          continue;
+        }
         vp[i] = f(p[i], context);
       }
       besti = 0;
@@ -224,9 +226,8 @@ void ZopfliBlockSplitLZ77(const ZopfliOptions* options,
 
   if (lz77->size < 10) return;  /* This code fails on tiny files. */
 
-  done = (unsigned char*)malloc(lz77->size);
+  done = (unsigned char*)calloc(lz77->size, 1);
   if (!done) exit(-1); /* Allocation failed. */
-  for (i = 0; i < lz77->size; i++) done[i] = 0;
 
   lstart = 0;
   lend = lz77->size;
@@ -265,16 +266,12 @@ void ZopfliBlockSplitLZ77(const ZopfliOptions* options,
     }
   }
 
-  if (options->verbose) {
-    PrintBlockSplitPoints(lz77, *splitpoints, *npoints);
-  }
-
   free(done);
 }
 
 void ZopfliBlockSplit(const ZopfliOptions* options,
                       const unsigned char* in, size_t instart, size_t inend,
-                      size_t maxblocks, size_t** splitpoints, size_t* npoints) {
+                      size_t maxblocks, size_t** splitpoints, size_t* npoints, SymbolStats** stats) {
   size_t pos = 0;
   size_t i;
   ZopfliBlockState s;
@@ -298,19 +295,47 @@ void ZopfliBlockSplit(const ZopfliOptions* options,
   ZopfliBlockSplitLZ77(options,
                        &store, maxblocks,
                        &lz77splitpoints, &nlz77points);
+  (*stats) = (SymbolStats*)realloc(*stats, (nlz77points + 1) * sizeof(SymbolStats));
 
   /* Convert LZ77 positions to positions in the uncompressed input. */
   pos = instart;
   if (nlz77points > 0) {
+  	size_t shift2;
     for (i = 0; i < store.size; i++) {
       size_t length = store.dists[i] == 0 ? 1 : store.litlens[i];
-      if (lz77splitpoints[*npoints] == i) {
+      if (lz77splitpoints[(*npoints)] == i) {
+        size_t temp = store.size;
+        size_t shift = (*npoints) ? lz77splitpoints[*npoints - 1] : 0;
+        store.size = i - shift;
+        store.dists += shift;
+        store.litlens += shift;
+
+        InitStats(&((*stats)[*npoints]));
+        GetStatistics(&store, &((*stats)[*npoints]));
+        store.size = temp;
+        store.dists -= shift;
+        store.litlens -= shift;
         ZOPFLI_APPEND_DATA(pos, splitpoints, npoints);
         if (*npoints == nlz77points) break;
       }
       pos += length;
     }
+    shift2 = lz77splitpoints[*npoints - 1];
+    store.size -= shift2;
+    store.dists += shift2;
+    store.litlens += shift2;
+
+    InitStats(&((*stats)[*npoints]));
+    GetStatistics(&store, &((*stats)[*npoints]));
+    store.size += shift2;
+    store.dists -= shift2;
+    store.litlens -= shift2;
+  }
+  else{
+    InitStats(*stats);
+    GetStatistics(&store, *stats);
   }
+
   assert(*npoints == nlz77points);
 
   free(lz77splitpoints);
diff --git a/zopfli/blocksplitter.h b/zopfli/blocksplitter.h
index d1d622f..e4b769f 100644
--- a/zopfli/blocksplitter.h
+++ b/zopfli/blocksplitter.h
@@ -31,6 +31,7 @@ ones that enhance it.
 #include <stdlib.h>
 
 #include "lz77.h"
+#include "squeeze.h"
 #include "zopfli.h"
 
 
@@ -59,7 +60,7 @@ npoints: pointer to amount of splitpoints, for the dynamic array. The amount of
 */
 void ZopfliBlockSplit(const ZopfliOptions* options,
                       const unsigned char* in, size_t instart, size_t inend,
-                      size_t maxblocks, size_t** splitpoints, size_t* npoints);
+                      size_t maxblocks, size_t** splitpoints, size_t* npoints, SymbolStats** stats);
 
 /*
 Divides the input into equal blocks, does not even take LZ77 lengths into
diff --git a/zopfli/cache.c b/zopfli/cache.c
index 6b9444f..438a9ed 100644
--- a/zopfli/cache.c
+++ b/zopfli/cache.c
@@ -28,9 +28,9 @@ Author: jyrki.alakuijala@gmail.com (Jyrki Alakuijala)
 void ZopfliInitCache(size_t blocksize, ZopfliLongestMatchCache* lmc) {
   size_t i;
   lmc->length = (unsigned short*)malloc(sizeof(unsigned short) * blocksize);
-  lmc->dist = (unsigned short*)malloc(sizeof(unsigned short) * blocksize);
+  lmc->dist = (unsigned short*)calloc(blocksize, sizeof(unsigned short));
   /* Rather large amount of memory. */
-  lmc->sublen = (unsigned char*)malloc(ZOPFLI_CACHE_LENGTH * 3 * blocksize);
+  lmc->sublen = (unsigned char*)calloc(ZOPFLI_CACHE_LENGTH * 3 * blocksize, 1);
   if(lmc->sublen == NULL) {
     fprintf(stderr,
         "Error: Out of memory. Tried allocating %lu bytes of memory.\n",
@@ -41,8 +41,6 @@ void ZopfliInitCache(size_t blocksize, ZopfliLongestMatchCache* lmc) {
   /* length > 0 and dist 0 is invalid combination, which indicates on purpose
   that this cache value is not filled in yet. */
   for (i = 0; i < blocksize; i++) lmc->length[i] = 1;
-  for (i = 0; i < blocksize; i++) lmc->dist[i] = 0;
-  for (i = 0; i < ZOPFLI_CACHE_LENGTH * blocksize * 3; i++) lmc->sublen[i] = 0;
 }
 
 void ZopfliCleanCache(ZopfliLongestMatchCache* lmc) {
diff --git a/zopfli/deflate.c b/zopfli/deflate.c
index c5abda9..0bce4bf 100644
--- a/zopfli/deflate.c
+++ b/zopfli/deflate.c
@@ -23,10 +23,11 @@ Author: jyrki.alakuijala@gmail.com (Jyrki Alakuijala)
 #include <stdio.h>
 #include <stdlib.h>
 
+#include "../rust.h"
 #include "blocksplitter.h"
 #include "squeeze.h"
 #include "symbols.h"
-#include "tree.h"
+#include "katajainen.h"
 
 /*
 bp = bitpointer, always in range [0, 7].
@@ -128,7 +129,7 @@ static size_t EncodeTree(const unsigned* ll_lengths,
   int size_only = !out;
   size_t result_size = 0;
 
-  for(i = 0; i < 19; i++) clcounts[i] = 0;
+  for (i = 0; i < 19; i++) clcounts[i] = 0;
 
   /* Trim zeros. */
   while (hlit > 0 && ll_lengths[257 + hlit - 1] == 0) hlit--;
@@ -205,8 +206,8 @@ static size_t EncodeTree(const unsigned* ll_lengths,
     }
   }
 
-  ZopfliCalculateBitLengths(clcounts, 19, 7, clcl);
-  if (!size_only) ZopfliLengthsToSymbols(clcl, 19, 7, clsymbols);
+  assert(!ZopfliLengthLimitedCodeLengths(clcounts, 19, 7, clcl));
+  if (!size_only) ZopfliLengthsToSymbols7(clcl, 19, clsymbols);
 
   hclen = 15;
   /* Trim zeros. */
@@ -449,8 +450,7 @@ void OptimizeHuffmanForRle(int length, size_t* counts) {
   }
   /* 2) Let's mark all population counts that already can be encoded
   with an rle code.*/
-  good_for_rle = (int*)malloc((unsigned)length * sizeof(int));
-  for (i = 0; i < length; ++i) good_for_rle[i] = 0;
+  good_for_rle = (int*)calloc((unsigned)length, sizeof(int));
 
   /* Let's not spoil any of the existing good rle codes.
   Mark any seq of 0's that is longer than 5 as a good_for_rle.
@@ -543,8 +543,8 @@ static double TryOptimizeHuffmanForRle(
   memcpy(d_counts2, d_counts, sizeof(d_counts2));
   OptimizeHuffmanForRle(ZOPFLI_NUM_LL, ll_counts2);
   OptimizeHuffmanForRle(ZOPFLI_NUM_D, d_counts2);
-  ZopfliCalculateBitLengths(ll_counts2, ZOPFLI_NUM_LL, 15, ll_lengths2);
-  ZopfliCalculateBitLengths(d_counts2, ZOPFLI_NUM_D, 15, d_lengths2);
+  assert(!ZopfliLengthLimitedCodeLengths(ll_counts2, ZOPFLI_NUM_LL, 15, ll_lengths2));
+  assert(!ZopfliLengthLimitedCodeLengths(d_counts2, ZOPFLI_NUM_D, 15, d_lengths2));
   PatchDistanceCodesForBuggyDecoders(d_lengths2);
 
   treesize2 = CalculateTreeSize(ll_lengths2, d_lengths2);
@@ -574,8 +574,8 @@ static double GetDynamicLengths(const ZopfliLZ77Store* lz77,
 
   ZopfliLZ77GetHistogram(lz77, lstart, lend, ll_counts, d_counts);
   ll_counts[256] = 1;  /* End symbol. */
-  ZopfliCalculateBitLengths(ll_counts, ZOPFLI_NUM_LL, 15, ll_lengths);
-  ZopfliCalculateBitLengths(d_counts, ZOPFLI_NUM_D, 15, d_lengths);
+  assert(!ZopfliLengthLimitedCodeLengths(ll_counts, ZOPFLI_NUM_LL, 15, ll_lengths));
+  assert(!ZopfliLengthLimitedCodeLengths(d_counts, ZOPFLI_NUM_D, 15, d_lengths));
   PatchDistanceCodesForBuggyDecoders(d_lengths);
   return TryOptimizeHuffmanForRle(
       lz77, lstart, lend, ll_counts, d_counts, ll_lengths, d_lengths);
@@ -718,13 +718,10 @@ static void AddLZ77Block(const ZopfliOptions* options, int btype, int final,
 
     detect_tree_size = *outsize;
     AddDynamicTree(ll_lengths, d_lengths, bp, out, outsize);
-    if (options->verbose) {
-      fprintf(stderr, "treesize: %d\n", (int)(*outsize - detect_tree_size));
-    }
   }
 
-  ZopfliLengthsToSymbols(ll_lengths, ZOPFLI_NUM_LL, 15, ll_symbols);
-  ZopfliLengthsToSymbols(d_lengths, ZOPFLI_NUM_D, 15, d_symbols);
+  ZopfliLengthsToSymbols15(ll_lengths, ZOPFLI_NUM_LL, ll_symbols);
+  ZopfliLengthsToSymbols15(d_lengths, ZOPFLI_NUM_D, d_symbols);
 
   detect_block_size = *outsize;
   AddLZ77Data(lz77, lstart, lend, expected_data_size,
@@ -737,11 +734,6 @@ static void AddLZ77Block(const ZopfliOptions* options, int btype, int final,
     uncompressed_size += lz77->dists[i] == 0 ? 1 : lz77->litlens[i];
   }
   compressed_size = *outsize - detect_block_size;
-  if (options->verbose) {
-    fprintf(stderr, "compressed block size: %d (%dk) (unc: %d)\n",
-           (int)compressed_size, (int)(compressed_size / 1024),
-           (int)(uncompressed_size));
-  }
 }
 
 static void AddLZ77BlockAutoType(const ZopfliOptions* options, int final,
@@ -813,6 +805,8 @@ void ZopfliDeflatePart(const ZopfliOptions* options, int btype, int final,
                        unsigned char* bp, unsigned char** out,
                        size_t* outsize) {
   size_t i;
+  SymbolStats* stats;
+
   /* byte coordinates rather than lz77 index */
   size_t* splitpoints_uncompressed = 0;
   size_t npoints = 0;
@@ -820,6 +814,7 @@ void ZopfliDeflatePart(const ZopfliOptions* options, int btype, int final,
   double totalcost = 0;
   ZopfliLZ77Store lz77;
 
+  stats = 0;
   /* If btype=2 is specified, it tries all block types. If a lesser btype is
   given, then however it forces that one. Neither of the lesser types needs
   block splitting as they have no dynamic huffman trees. */
@@ -845,7 +840,7 @@ void ZopfliDeflatePart(const ZopfliOptions* options, int btype, int final,
   if (options->blocksplitting) {
     ZopfliBlockSplit(options, in, instart, inend,
                      options->blocksplittingmax,
-                     &splitpoints_uncompressed, &npoints);
+                     &splitpoints_uncompressed, &npoints, &stats);
     splitpoints = (size_t*)malloc(sizeof(*splitpoints) * npoints);
   }
 
@@ -858,7 +853,7 @@ void ZopfliDeflatePart(const ZopfliOptions* options, int btype, int final,
     ZopfliLZ77Store store;
     ZopfliInitLZ77Store(in, &store);
     ZopfliInitBlockState(options, start, end, 1, &s);
-    ZopfliLZ77Optimal(&s, in, start, end, options->numiterations, &store);
+    ZopfliLZ77Optimal(&s, in, start, end, options->numiterations, &store, stats ? &stats[i] : 0);
     totalcost += ZopfliCalculateBlockSizeAutoType(&store, 0, store.size);
 
     ZopfliAppendLZ77Store(&store, &lz77);
@@ -868,6 +863,10 @@ void ZopfliDeflatePart(const ZopfliOptions* options, int btype, int final,
     ZopfliCleanLZ77Store(&store);
   }
 
+  if(stats){
+    free(stats);
+  }
+
   /* Second block splitting attempt */
   if (options->blocksplitting && npoints > 1) {
     size_t* splitpoints2 = 0;
@@ -922,10 +921,4 @@ void ZopfliDeflate(const ZopfliOptions* options, int btype, int final,
     i += size;
   } while (i < insize);
 #endif
-  if (options->verbose) {
-    fprintf(stderr,
-            "Original Size: %lu, Deflate: %lu, Compression: %f%% Removed\n",
-            (unsigned long)insize, (unsigned long)(*outsize - offset),
-            100.0 * (double)(insize - (*outsize - offset)) / (double)insize);
-  }
 }
diff --git a/zopfli/gzip_container.c b/zopfli/gzip_container.c
deleted file mode 100644
index 7615db3..0000000
--- a/zopfli/gzip_container.c
+++ /dev/null
@@ -1,124 +0,0 @@
-/*
-Copyright 2013 Google Inc. All Rights Reserved.
-
-Licensed under the Apache License, Version 2.0 (the "License");
-you may not use this file except in compliance with the License.
-You may obtain a copy of the License at
-
-    http://www.apache.org/licenses/LICENSE-2.0
-
-Unless required by applicable law or agreed to in writing, software
-distributed under the License is distributed on an "AS IS" BASIS,
-WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
-See the License for the specific language governing permissions and
-limitations under the License.
-
-Author: lode.vandevenne@gmail.com (Lode Vandevenne)
-Author: jyrki.alakuijala@gmail.com (Jyrki Alakuijala)
-*/
-
-#include "gzip_container.h"
-#include "util.h"
-
-#include <stdio.h>
-
-#include "deflate.h"
-
-/* CRC polynomial: 0xedb88320 */
-static const unsigned long crc32_table[256] = {
-           0u, 1996959894u, 3993919788u, 2567524794u,  124634137u, 1886057615u,
-  3915621685u, 2657392035u,  249268274u, 2044508324u, 3772115230u, 2547177864u,
-   162941995u, 2125561021u, 3887607047u, 2428444049u,  498536548u, 1789927666u,
-  4089016648u, 2227061214u,  450548861u, 1843258603u, 4107580753u, 2211677639u,
-   325883990u, 1684777152u, 4251122042u, 2321926636u,  335633487u, 1661365465u,
-  4195302755u, 2366115317u,  997073096u, 1281953886u, 3579855332u, 2724688242u,
-  1006888145u, 1258607687u, 3524101629u, 2768942443u,  901097722u, 1119000684u,
-  3686517206u, 2898065728u,  853044451u, 1172266101u, 3705015759u, 2882616665u,
-   651767980u, 1373503546u, 3369554304u, 3218104598u,  565507253u, 1454621731u,
-  3485111705u, 3099436303u,  671266974u, 1594198024u, 3322730930u, 2970347812u,
-   795835527u, 1483230225u, 3244367275u, 3060149565u, 1994146192u,   31158534u,
-  2563907772u, 4023717930u, 1907459465u,  112637215u, 2680153253u, 3904427059u,
-  2013776290u,  251722036u, 2517215374u, 3775830040u, 2137656763u,  141376813u,
-  2439277719u, 3865271297u, 1802195444u,  476864866u, 2238001368u, 4066508878u,
-  1812370925u,  453092731u, 2181625025u, 4111451223u, 1706088902u,  314042704u,
-  2344532202u, 4240017532u, 1658658271u,  366619977u, 2362670323u, 4224994405u,
-  1303535960u,  984961486u, 2747007092u, 3569037538u, 1256170817u, 1037604311u,
-  2765210733u, 3554079995u, 1131014506u,  879679996u, 2909243462u, 3663771856u,
-  1141124467u,  855842277u, 2852801631u, 3708648649u, 1342533948u,  654459306u,
-  3188396048u, 3373015174u, 1466479909u,  544179635u, 3110523913u, 3462522015u,
-  1591671054u,  702138776u, 2966460450u, 3352799412u, 1504918807u,  783551873u,
-  3082640443u, 3233442989u, 3988292384u, 2596254646u,   62317068u, 1957810842u,
-  3939845945u, 2647816111u,   81470997u, 1943803523u, 3814918930u, 2489596804u,
-   225274430u, 2053790376u, 3826175755u, 2466906013u,  167816743u, 2097651377u,
-  4027552580u, 2265490386u,  503444072u, 1762050814u, 4150417245u, 2154129355u,
-   426522225u, 1852507879u, 4275313526u, 2312317920u,  282753626u, 1742555852u,
-  4189708143u, 2394877945u,  397917763u, 1622183637u, 3604390888u, 2714866558u,
-   953729732u, 1340076626u, 3518719985u, 2797360999u, 1068828381u, 1219638859u,
-  3624741850u, 2936675148u,  906185462u, 1090812512u, 3747672003u, 2825379669u,
-   829329135u, 1181335161u, 3412177804u, 3160834842u,  628085408u, 1382605366u,
-  3423369109u, 3138078467u,  570562233u, 1426400815u, 3317316542u, 2998733608u,
-   733239954u, 1555261956u, 3268935591u, 3050360625u,  752459403u, 1541320221u,
-  2607071920u, 3965973030u, 1969922972u,   40735498u, 2617837225u, 3943577151u,
-  1913087877u,   83908371u, 2512341634u, 3803740692u, 2075208622u,  213261112u,
-  2463272603u, 3855990285u, 2094854071u,  198958881u, 2262029012u, 4057260610u,
-  1759359992u,  534414190u, 2176718541u, 4139329115u, 1873836001u,  414664567u,
-  2282248934u, 4279200368u, 1711684554u,  285281116u, 2405801727u, 4167216745u,
-  1634467795u,  376229701u, 2685067896u, 3608007406u, 1308918612u,  956543938u,
-  2808555105u, 3495958263u, 1231636301u, 1047427035u, 2932959818u, 3654703836u,
-  1088359270u,  936918000u, 2847714899u, 3736837829u, 1202900863u,  817233897u,
-  3183342108u, 3401237130u, 1404277552u,  615818150u, 3134207493u, 3453421203u,
-  1423857449u,  601450431u, 3009837614u, 3294710456u, 1567103746u,  711928724u,
-  3020668471u, 3272380065u, 1510334235u,  755167117u
-};
-
-/* Returns the CRC32 */
-static unsigned long CRC(const unsigned char* data, size_t size) {
-  unsigned long result = 0xffffffffu;
-  for (; size > 0; size--) {
-    result = crc32_table[(result ^ *(data++)) & 0xff] ^ (result >> 8);
-  }
-  return result ^ 0xffffffffu;
-}
-
-/* Compresses the data according to the gzip specification, RFC 1952. */
-void ZopfliGzipCompress(const ZopfliOptions* options,
-                        const unsigned char* in, size_t insize,
-                        unsigned char** out, size_t* outsize) {
-  unsigned long crcvalue = CRC(in, insize);
-  unsigned char bp = 0;
-
-  ZOPFLI_APPEND_DATA(31, out, outsize);  /* ID1 */
-  ZOPFLI_APPEND_DATA(139, out, outsize);  /* ID2 */
-  ZOPFLI_APPEND_DATA(8, out, outsize);  /* CM */
-  ZOPFLI_APPEND_DATA(0, out, outsize);  /* FLG */
-  /* MTIME */
-  ZOPFLI_APPEND_DATA(0, out, outsize);
-  ZOPFLI_APPEND_DATA(0, out, outsize);
-  ZOPFLI_APPEND_DATA(0, out, outsize);
-  ZOPFLI_APPEND_DATA(0, out, outsize);
-
-  ZOPFLI_APPEND_DATA(2, out, outsize);  /* XFL, 2 indicates best compression. */
-  ZOPFLI_APPEND_DATA(3, out, outsize);  /* OS follows Unix conventions. */
-
-  ZopfliDeflate(options, 2 /* Dynamic block */, 1,
-                in, insize, &bp, out, outsize);
-
-  /* CRC */
-  ZOPFLI_APPEND_DATA(crcvalue % 256, out, outsize);
-  ZOPFLI_APPEND_DATA((crcvalue >> 8) % 256, out, outsize);
-  ZOPFLI_APPEND_DATA((crcvalue >> 16) % 256, out, outsize);
-  ZOPFLI_APPEND_DATA((crcvalue >> 24) % 256, out, outsize);
-
-  /* ISIZE */
-  ZOPFLI_APPEND_DATA(insize % 256, out, outsize);
-  ZOPFLI_APPEND_DATA((insize >> 8) % 256, out, outsize);
-  ZOPFLI_APPEND_DATA((insize >> 16) % 256, out, outsize);
-  ZOPFLI_APPEND_DATA((insize >> 24) % 256, out, outsize);
-
-  if (options->verbose) {
-    fprintf(stderr,
-            "Original Size: %d, Gzip: %d, Compression: %f%% Removed\n",
-            (int)insize, (int)*outsize,
-            100.0 * (double)(insize - *outsize) / (double)insize);
-  }
-}
diff --git a/zopfli/gzip_container.h b/zopfli/gzip_container.h
deleted file mode 100644
index 8f5ed90..0000000
--- a/zopfli/gzip_container.h
+++ /dev/null
@@ -1,50 +0,0 @@
-/*
-Copyright 2013 Google Inc. All Rights Reserved.
-
-Licensed under the Apache License, Version 2.0 (the "License");
-you may not use this file except in compliance with the License.
-You may obtain a copy of the License at
-
-    http://www.apache.org/licenses/LICENSE-2.0
-
-Unless required by applicable law or agreed to in writing, software
-distributed under the License is distributed on an "AS IS" BASIS,
-WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
-See the License for the specific language governing permissions and
-limitations under the License.
-
-Author: lode.vandevenne@gmail.com (Lode Vandevenne)
-Author: jyrki.alakuijala@gmail.com (Jyrki Alakuijala)
-*/
-
-#ifndef ZOPFLI_GZIP_H_
-#define ZOPFLI_GZIP_H_
-
-/*
-Functions to compress according to the Gzip specification.
-*/
-
-#include "zopfli.h"
-
-#ifdef __cplusplus
-extern "C" {
-#endif
-
-/*
-Compresses according to the gzip specification and append the compressed
-result to the output.
-
-options: global program options
-out: pointer to the dynamic output array to which the result is appended. Must
-  be freed after use.
-outsize: pointer to the dynamic output array size.
-*/
-void ZopfliGzipCompress(const ZopfliOptions* options,
-                        const unsigned char* in, size_t insize,
-                        unsigned char** out, size_t* outsize);
-
-#ifdef __cplusplus
-}  // extern "C"
-#endif
-
-#endif  /* ZOPFLI_GZIP_H_ */
diff --git a/zopfli/hash.c b/zopfli/hash.c
index 3025d1e..20d8eac 100644
--- a/zopfli/hash.c
+++ b/zopfli/hash.c
@@ -46,30 +46,26 @@ void ZopfliResetHash(size_t window_size, ZopfliHash* h) {
   size_t i;
 
   h->val = 0;
+#ifdef ZOPFLI_HASH_SAME_HASH
+  h->val2 = 0;
+#endif
   for (i = 0; i < 65536; i++) {
     h->head[i] = -1;  /* -1 indicates no head so far. */
+#ifdef ZOPFLI_HASH_SAME_HASH
+    h->head2[i] = -1;
+#endif
   }
   for (i = 0; i < window_size; i++) {
     h->prev[i] = i;  /* If prev[j] == j, then prev[j] is uninitialized. */
     h->hashval[i] = -1;
-  }
-
 #ifdef ZOPFLI_HASH_SAME
-  for (i = 0; i < window_size; i++) {
     h->same[i] = 0;
-  }
 #endif
-
 #ifdef ZOPFLI_HASH_SAME_HASH
-  h->val2 = 0;
-  for (i = 0; i < 65536; i++) {
-    h->head2[i] = -1;
-  }
-  for (i = 0; i < window_size; i++) {
     h->prev2[i] = i;
     h->hashval2[i] = -1;
-  }
 #endif
+  }
 }
 
 void ZopfliCleanHash(ZopfliHash* h) {
diff --git a/zopfli/katajainen.c b/zopfli/katajainen.c
index 1459017..eb13a21 100644
--- a/zopfli/katajainen.c
+++ b/zopfli/katajainen.c
@@ -39,13 +39,6 @@ struct Node {
   int count;  /* Leaf symbol index, or number of leaves before this chain. */
 };
 
-/*
-Memory pool for nodes.
-*/
-typedef struct NodePool {
-  Node* next;  /* Pointer to a free node in the pool. */
-} NodePool;
-
 /*
 Initializes a chain node with the given values and marks it as in use.
 */
@@ -55,64 +48,18 @@ static void InitNode(size_t weight, int count, Node* tail, Node* node) {
   node->tail = tail;
 }
 
-/*
-Performs a Boundary Package-Merge step. Puts a new chain in the given list. The
-new chain is, depending on the weights, a leaf or a combination of two chains
-from the previous list.
-lists: The lists of chains.
-maxbits: Number of lists.
-leaves: The leaves, one per symbol.
-numsymbols: Number of leaves.
-pool: the node memory pool.
-index: The index of the list in which a new chain or leaf is required.
-*/
-static void BoundaryPM(Node* (*lists)[2], Node* leaves, int numsymbols,
-                       NodePool* pool, int index) {
-  Node* newchain;
-  Node* oldchain;
-  int lastcount = lists[index][1]->count;  /* Count of last chain of list. */
-
-  if (index == 0 && lastcount >= numsymbols) return;
-
-  newchain = pool->next++;
-  oldchain = lists[index][1];
-
-  /* These are set up before the recursive calls below, so that there is a list
-  pointing to the new node, to let the garbage collection know it's in use. */
-  lists[index][0] = oldchain;
-  lists[index][1] = newchain;
-
-  if (index == 0) {
-    /* New leaf node in list 0. */
-    InitNode(leaves[lastcount].weight, lastcount + 1, 0, newchain);
-  } else {
-    size_t sum = lists[index - 1][0]->weight + lists[index - 1][1]->weight;
-    if (lastcount < numsymbols && sum > leaves[lastcount].weight) {
-      /* New leaf inserted in list, so count is incremented. */
-      InitNode(leaves[lastcount].weight, lastcount + 1, oldchain->tail,
-          newchain);
-    } else {
-      InitNode(sum, lastcount, lists[index - 1][1], newchain);
-      /* Two lookahead chains of previous list used up, create new ones. */
-      BoundaryPM(lists, leaves, numsymbols, pool, index - 1);
-      BoundaryPM(lists, leaves, numsymbols, pool, index - 1);
-    }
-  }
-}
-
 static void BoundaryPMFinal(Node* (*lists)[2],
-    Node* leaves, int numsymbols, NodePool* pool, int index) {
+    Node* leaves, int numsymbols, Node* pool, int index) {
   int lastcount = lists[index][1]->count;  /* Count of last chain of list. */
 
   size_t sum = lists[index - 1][0]->weight + lists[index - 1][1]->weight;
 
   if (lastcount < numsymbols && sum > leaves[lastcount].weight) {
-    Node* newchain = pool->next;
     Node* oldchain = lists[index][1]->tail;
 
-    lists[index][1] = newchain;
-    newchain->count = lastcount + 1;
-    newchain->tail = oldchain;
+    lists[index][1] = pool;
+    pool->count = lastcount + 1;
+    pool->tail = oldchain;
   } else {
     lists[index][1]->tail = lists[index - 1][1];
   }
@@ -123,10 +70,10 @@ Initializes each list with as lookahead chains the two leaves with lowest
 weights.
 */
 static void InitLists(
-    NodePool* pool, const Node* leaves, int maxbits, Node* (*lists)[2]) {
+    Node* pool, const Node* leaves, int maxbits, Node* (*lists)[2]) {
   int i;
-  Node* node0 = pool->next++;
-  Node* node1 = pool->next++;
+  Node* node0 = pool;
+  Node* node1 = pool + 1;
   InitNode(leaves[0].weight, 1, 0, node0);
   InitNode(leaves[1].weight, 2, 0, node1);
   for (i = 0; i < maxbits; i++) {
@@ -171,11 +118,12 @@ static int LeafComparator(const void* a, const void* b) {
 
 int ZopfliLengthLimitedCodeLengths(
     const size_t* frequencies, int n, int maxbits, unsigned* bitlengths) {
-  NodePool pool;
+  Node* pool;
   int i;
   int numsymbols = 0;  /* Amount of symbols with frequency > 0. */
   int numBoundaryPMRuns;
   Node* nodes;
+  unsigned char stack[16];
 
   /* Array of lists of chains. Each list requires only two lookahead chains at
   a time, so each list is a array of two Node*'s. */
@@ -185,12 +133,9 @@ int ZopfliLengthLimitedCodeLengths(
   Node* leaves = (Node*)malloc(n * sizeof(*leaves));
 
   /* Initialize all bitlengths at 0. */
-  for (i = 0; i < n; i++) {
-    bitlengths[i] = 0;
-  }
-
   /* Count used symbols and place them in the leaves. */
   for (i = 0; i < n; i++) {
+    bitlengths[i] = 0;
     if (frequencies[i]) {
       leaves[numsymbols].weight = frequencies[i];
       leaves[numsymbols].count = i;  /* Index of symbol this leaf represents. */
@@ -240,18 +185,71 @@ int ZopfliLengthLimitedCodeLengths(
 
   /* Initialize node memory pool. */
   nodes = (Node*)malloc(maxbits * 2 * numsymbols * sizeof(Node));
-  pool.next = nodes;
+  pool = nodes;
 
   lists = (Node* (*)[2])malloc(maxbits * sizeof(*lists));
-  InitLists(&pool, leaves, maxbits, lists);
+  InitLists(pool, leaves, maxbits, lists);
+  pool += 2;
 
   /* In the last list, 2 * numsymbols - 2 active chains need to be created. Two
   are already created in the initialization. Each BoundaryPM run creates one. */
   numBoundaryPMRuns = 2 * numsymbols - 4;
   for (i = 0; i < numBoundaryPMRuns - 1; i++) {
-    BoundaryPM(lists, leaves, numsymbols, &pool, maxbits - 1);
+    /*
+    Performs a Boundary Package-Merge step. Puts a new chain in the given list. The
+    new chain is, depending on the weights, a leaf or a combination of two chains
+    from the previous list.
+    */
+    unsigned stackpos;
+    stack[0] = maxbits - 1;
+
+    for (stackpos = 0; ;) {
+      unsigned char index = stack[stackpos];
+
+      int lastcount = lists[index][1]->count;  /* Count of last chain of list. */
+
+      Node* newchain = pool++;
+      Node* oldchain = lists[index][1];
+      size_t sum;
+
+      /* These are set up before the recursive calls below, so that there is a list
+      pointing to the new node, to let the garbage collection know it's in use. */
+      lists[index][0] = oldchain;
+      lists[index][1] = newchain;
+
+      sum = lists[index - 1][0]->weight + lists[index - 1][1]->weight;
+
+      if (lastcount < numsymbols && sum > leaves[lastcount].weight) {
+        /* New leaf inserted in list, so count is incremented. */
+        InitNode(leaves[lastcount].weight, lastcount + 1, oldchain->tail, newchain);
+      } else {
+        InitNode(sum, lastcount, lists[index - 1][1], newchain);
+        /* Two lookahead chains of previous list used up, create new ones. */
+        if (index == 1) {
+          if (lists[0][1]->count < numsymbols) {
+            lastcount = lists[0][1]->count;
+            lists[0][0] = lists[0][1];
+            lists[0][1] = pool++;
+            InitNode(leaves[lastcount].weight, lastcount + 1, 0, lists[0][1]);
+            lastcount++;
+            if(lastcount < numsymbols){
+              lists[0][0] = lists[0][1];
+              lists[0][1] = pool++;
+              InitNode(leaves[lastcount].weight, lastcount + 1, 0, lists[0][1]);
+            }
+          }
+        }
+        else {
+          stack[stackpos++] = index - 1;
+          stack[stackpos++] = index - 1;
+        }
+      }
+      if (!stackpos--) {
+        break;
+      }
+    }
   }
-  BoundaryPMFinal(lists, leaves, numsymbols, &pool, maxbits - 1);
+  BoundaryPMFinal(lists, leaves, numsymbols, pool, maxbits - 1);
 
   ExtractBitLengths(lists[maxbits - 1][1], leaves, bitlengths);
 
diff --git a/zopfli/lz77.c b/zopfli/lz77.c
index 9df899d..e283c3d 100644
--- a/zopfli/lz77.c
+++ b/zopfli/lz77.c
@@ -270,21 +270,6 @@ static int GetLengthScore(int length, int distance) {
   return distance > 1024 ? length - 1 : length;
 }
 
-void ZopfliVerifyLenDist(const unsigned char* data, size_t datasize, size_t pos,
-                         unsigned short dist, unsigned short length) {
-
-  /* TODO(lode): make this only run in a debug compile, it's for assert only. */
-  size_t i;
-
-  assert(pos + length <= datasize);
-  for (i = 0; i < length; i++) {
-    if (data[pos - dist + i] != data[pos + i]) {
-      assert(data[pos - dist + i] == data[pos + i]);
-      break;
-    }
-  }
-}
-
 /*
 Finds how long the match of scan and match is. Can be used to find how many
 bytes starting from scan, and from match, are equal. Returns the last byte
@@ -594,7 +579,6 @@ void ZopfliLZ77Greedy(ZopfliBlockState* s, const unsigned char* in,
         dist = prev_match;
         lengthscore = prevlengthscore;
         /* Add to output. */
-        ZopfliVerifyLenDist(in, inend, i - 1, dist, leng);
         ZopfliStoreLitLenDist(leng, dist, i - 1, store);
         for (j = 2; j < leng; j++) {
           assert(i < inend);
@@ -615,7 +599,6 @@ void ZopfliLZ77Greedy(ZopfliBlockState* s, const unsigned char* in,
 
     /* Add to output. */
     if (lengthscore >= ZOPFLI_MIN_MATCH) {
-      ZopfliVerifyLenDist(in, inend, i, dist, leng);
       ZopfliStoreLitLenDist(leng, dist, i, store);
     } else {
       leng = 1;
diff --git a/zopfli/lz77.h b/zopfli/lz77.h
index dc8597a..8975bb5 100644
--- a/zopfli/lz77.h
+++ b/zopfli/lz77.h
@@ -122,12 +122,6 @@ void ZopfliFindLongestMatch(
     size_t pos, size_t size, size_t limit,
     unsigned short* sublen, unsigned short* distance, unsigned short* length);
 
-/*
-Verifies if length and dist are indeed valid, only used for assertion.
-*/
-void ZopfliVerifyLenDist(const unsigned char* data, size_t datasize, size_t pos,
-                         unsigned short dist, unsigned short length);
-
 /*
 Does LZ77 using an algorithm similar to gzip, with lazy matching, rather than
 with the slow but better "squeeze" implementation.
diff --git a/zopfli/squeeze.c b/zopfli/squeeze.c
index a695c18..dc429d0 100644
--- a/zopfli/squeeze.c
+++ b/zopfli/squeeze.c
@@ -23,26 +23,13 @@ Author: jyrki.alakuijala@gmail.com (Jyrki Alakuijala)
 #include <math.h>
 #include <stdio.h>
 
+#include "../rust.h"
 #include "blocksplitter.h"
 #include "deflate.h"
 #include "symbols.h"
-#include "tree.h"
 #include "util.h"
 
-typedef struct SymbolStats {
-  /* The literal and length symbols. */
-  size_t litlens[ZOPFLI_NUM_LL];
-  /* The 32 unique dist symbols, not the 32768 possible dists. */
-  size_t dists[ZOPFLI_NUM_D];
-
-  /* Length of each lit/len symbol in bits. */
-  double ll_symbols[ZOPFLI_NUM_LL];
-  /* Length of each dist symbol in bits. */
-  double d_symbols[ZOPFLI_NUM_D];
-} SymbolStats;
-
-/* Sets everything to 0. */
-static void InitStats(SymbolStats* stats) {
+void InitStats(SymbolStats* stats) {
   memset(stats->litlens, 0, ZOPFLI_NUM_LL * sizeof(stats->litlens[0]));
   memset(stats->dists, 0, ZOPFLI_NUM_D * sizeof(stats->dists[0]));
 
@@ -112,36 +99,8 @@ static void ClearStatFreqs(SymbolStats* stats) {
   for (i = 0; i < ZOPFLI_NUM_D; i++) stats->dists[i] = 0;
 }
 
-/*
-Function that calculates a cost based on a model for the given LZ77 symbol.
-litlen: means literal symbol if dist is 0, length otherwise.
-*/
-typedef double CostModelFun(unsigned litlen, unsigned dist, void* context);
-
-/*
-Cost model which should exactly match fixed tree.
-type: CostModelFun
-*/
-static double GetCostFixed(unsigned litlen, unsigned dist, void* unused) {
-  (void)unused;
-  if (dist == 0) {
-    if (litlen <= 143) return 8;
-    else return 9;
-  } else {
-    int dbits = ZopfliGetDistExtraBits(dist);
-    int lbits = ZopfliGetLengthExtraBits(litlen);
-    int lsym = ZopfliGetLengthSymbol(litlen);
-    int cost = 0;
-    if (lsym <= 279) cost += 7;
-    else cost += 8;
-    cost += 5;  /* Every dist symbol has length 5. */
-    return cost + dbits + lbits;
-  }
-}
-
 /*
 Cost model based on symbol statistics.
-type: CostModelFun
 */
 static double GetCostStat(unsigned litlen, unsigned dist, void* context) {
   SymbolStats* stats = (SymbolStats*)context;
@@ -160,7 +119,7 @@ static double GetCostStat(unsigned litlen, unsigned dist, void* context) {
 Finds the minimum possible cost this cost model can return for valid length and
 distance symbols.
 */
-static double GetCostModelMinCost(CostModelFun* costmodel, void* costcontext) {
+static double GetCostModelMinCost(void* costcontext) {
   double mincost;
   int bestlength = 0; /* length that has lowest cost in the cost model */
   int bestdist = 0; /* distance that has lowest cost in the cost model */
@@ -178,7 +137,7 @@ static double GetCostModelMinCost(CostModelFun* costmodel, void* costcontext) {
 
   mincost = ZOPFLI_LARGE_FLOAT;
   for (i = 3; i < 259; i++) {
-    double c = costmodel(i, 1, costcontext);
+    double c = GetCostStat(i, 1, costcontext);
     if (c < mincost) {
       bestlength = i;
       mincost = c;
@@ -187,14 +146,14 @@ static double GetCostModelMinCost(CostModelFun* costmodel, void* costcontext) {
 
   mincost = ZOPFLI_LARGE_FLOAT;
   for (i = 0; i < 30; i++) {
-    double c = costmodel(3, dsymbols[i], costcontext);
+    double c = GetCostStat(3, dsymbols[i], costcontext);
     if (c < mincost) {
       bestdist = dsymbols[i];
       mincost = c;
     }
   }
 
-  return costmodel(bestlength, bestdist, costcontext);
+  return GetCostStat(bestlength, bestdist, costcontext);
 }
 
 static size_t zopfli_min(size_t a, size_t b) {
@@ -208,8 +167,7 @@ s: the ZopfliBlockState
 in: the input data array
 instart: where to start
 inend: where to stop (not inclusive)
-costmodel: function to calculate the cost of some lit/len/dist pair.
-costcontext: abstract context for the costmodel function
+costcontext: abstract context for the costmodel
 length_array: output array of size (inend - instart) which will receive the best
     length to reach this byte from a previous byte.
 returns the cost that was, according to the costmodel, needed to get to the end.
@@ -217,7 +175,7 @@ returns the cost that was, according to the costmodel, needed to get to the end.
 static double GetBestLengths(ZopfliBlockState *s,
                              const unsigned char* in,
                              size_t instart, size_t inend,
-                             CostModelFun* costmodel, void* costcontext,
+                             SymbolStats* costcontext,
                              unsigned short* length_array,
                              ZopfliHash* h, float* costs) {
   /* Best cost to get here so far. */
@@ -229,8 +187,33 @@ static double GetBestLengths(ZopfliBlockState *s,
   size_t windowstart = instart > ZOPFLI_WINDOW_SIZE
       ? instart - ZOPFLI_WINDOW_SIZE : 0;
   double result;
-  double mincost = GetCostModelMinCost(costmodel, costcontext);
+  double mincost = costcontext ? GetCostModelMinCost(costcontext) : 12;
   double mincostaddcostj;
+  double* literals; /*Cost of a literal*/
+  double litlentable[259]; /*Cost of the length bits of a match*/
+  double disttable[30]; /*Cost of the distance bits of a match*/
+  if(costcontext){
+    literals = costcontext->ll_symbols;
+    for (i = 3; i < 259; i++){
+      litlentable[i] = costcontext->ll_symbols[ZopfliGetLengthSymbol(i)] + ZopfliGetLengthExtraBits(i);
+    }
+    for (i = 0; i < 30; i++){
+      disttable[i] =  costcontext->d_symbols[i] + (i < 4 ? 0 : (i - 2) / 2);
+    }
+  }
+  else{
+    double litstack[256];
+    literals = litstack;
+    for (i = 0; i < 256; i++){
+      literals[i] = 8 + (i > 143);
+    }
+    for (i = 3; i < 259; i++){
+      litlentable[i] = 12 + (i > 114) + ZopfliGetLengthExtraBits(i);
+    }
+    for (i = 0; i < 30; i++){
+      disttable[i] =  i < 4 ? 0 : (i - 2) / 2;
+    }
+  }
 
   if (instart == inend) return 0;
 
@@ -256,7 +239,7 @@ static double GetBestLengths(ZopfliBlockState *s,
         && i + ZOPFLI_MAX_MATCH * 2 + 1 < inend
         && h->same[(i - ZOPFLI_MAX_MATCH) & ZOPFLI_WINDOW_MASK]
             > ZOPFLI_MAX_MATCH) {
-      double symbolcost = costmodel(ZOPFLI_MAX_MATCH, 1, costcontext);
+      double symbolcost = disttable[0] + litlentable[ZOPFLI_MAX_MATCH];
       /* Set the length to reach each one to ZOPFLI_MAX_MATCH, and the cost to
       the cost corresponding to that length. Doing this, we skip
       ZOPFLI_MAX_MATCH values to avoid calling ZopfliFindLongestMatch. */
@@ -275,7 +258,7 @@ static double GetBestLengths(ZopfliBlockState *s,
 
     /* Literal. */
     if (i + 1 <= inend) {
-      double newCost = costmodel(in[i], 0, costcontext) + costs[j];
+      double newCost = literals[in[i]] + costs[j];
       assert(newCost >= 0);
       if (newCost < costs[j + 1]) {
         costs[j + 1] = newCost;
@@ -288,11 +271,10 @@ static double GetBestLengths(ZopfliBlockState *s,
     for (k = 3; k <= kend; k++) {
       double newCost;
 
-      /* Calling the cost model is expensive, avoid this if we are already at
-      the minimum possible cost that it can return. */
-     if (costs[j + k] <= mincostaddcostj) continue;
-
-      newCost = costmodel(k, sublen[k], costcontext) + costs[j];
+      /* Calculating the cost is expensive, avoid this if we are already at
+      the minimum possible cost that it can be. */
+      if (costs[j + k] <= mincostaddcostj) continue;
+      newCost = disttable[ZopfliGetDistSymbol(sublen[k])] + litlentable[k] + costs[j];
       assert(newCost >= 0);
       if (newCost < costs[j + k]) {
         assert(k <= ZOPFLI_MAX_MATCH);
@@ -369,7 +351,6 @@ static void FollowPath(ZopfliBlockState* s,
       ZopfliFindLongestMatch(s, h, in, pos, inend, length, 0,
                              &dist, &dummy_length);
       assert(!(dummy_length != length && length > 2 && dummy_length > 2));
-      ZopfliVerifyLenDist(in, inend, pos, dist, length);
       ZopfliStoreLitLenDist(length, dist, pos, store);
       total_length_test += length;
     } else {
@@ -394,8 +375,7 @@ static void CalculateStatistics(SymbolStats* stats) {
   ZopfliCalculateEntropy(stats->dists, ZOPFLI_NUM_D, stats->d_symbols);
 }
 
-/* Appends the symbol statistics from the store. */
-static void GetStatistics(const ZopfliLZ77Store* store, SymbolStats* stats) {
+void GetStatistics(const ZopfliLZ77Store* store, SymbolStats* stats) {
   size_t i;
   for (i = 0; i < store->size; i++) {
     if (store->dists[i] == 0) {
@@ -420,8 +400,7 @@ inend: where to stop (not inclusive)
 path: pointer to dynamically allocated memory to store the path
 pathsize: pointer to the size of the dynamic path array
 length_array: array of size (inend - instart) used to store lengths
-costmodel: function to use as the cost model for this squeeze run
-costcontext: abstract context for the costmodel function
+costcontext: abstract context for the costmodel
 store: place to output the LZ77 data
 returns the cost that was, according to the costmodel, needed to get to the end.
     This is not the actual cost.
@@ -429,10 +408,10 @@ returns the cost that was, according to the costmodel, needed to get to the end.
 static double LZ77OptimalRun(ZopfliBlockState* s,
     const unsigned char* in, size_t instart, size_t inend,
     unsigned short** path, size_t* pathsize,
-    unsigned short* length_array, CostModelFun* costmodel,
+    unsigned short* length_array,
     void* costcontext, ZopfliLZ77Store* store,
     ZopfliHash* h, float* costs) {
-  double cost = GetBestLengths(s, in, instart, inend, costmodel,
+  double cost = GetBestLengths(s, in, instart, inend,
                 costcontext, length_array, h, costs);
   free(*path);
   *path = 0;
@@ -446,7 +425,7 @@ static double LZ77OptimalRun(ZopfliBlockState* s,
 void ZopfliLZ77Optimal(ZopfliBlockState *s,
                        const unsigned char* in, size_t instart, size_t inend,
                        int numiterations,
-                       ZopfliLZ77Store* store) {
+                       ZopfliLZ77Store* store, SymbolStats* instats) {
   /* Dist to get to here with smallest cost. */
   size_t blocksize = inend - instart;
   unsigned short* length_array =
@@ -478,8 +457,13 @@ void ZopfliLZ77Optimal(ZopfliBlockState *s,
   the statistics of the previous run. */
 
   /* Initial run. */
-  ZopfliLZ77Greedy(s, in, instart, inend, &currentstore, h);
-  GetStatistics(&currentstore, &stats);
+  if(!instats){
+    ZopfliLZ77Greedy(s, in, instart, inend, &currentstore, h);
+    GetStatistics(&currentstore, &stats);
+  }
+  else{
+    CopyStats(instats, &stats);
+  }
 
   /* Repeat statistics with each time the cost model from the previous stat
   run. */
@@ -487,12 +471,9 @@ void ZopfliLZ77Optimal(ZopfliBlockState *s,
     ZopfliCleanLZ77Store(&currentstore);
     ZopfliInitLZ77Store(in, &currentstore);
     LZ77OptimalRun(s, in, instart, inend, &path, &pathsize,
-                   length_array, GetCostStat, (void*)&stats,
+                   length_array, (void*)&stats,
                    &currentstore, h, costs);
     cost = ZopfliCalculateBlockSize(&currentstore, 0, currentstore.size, 2);
-    if (s->options->verbose_more || (s->options->verbose && cost < bestcost)) {
-      fprintf(stderr, "Iteration %d: %d bit\n", i, (int) cost);
-    }
     if (cost < bestcost) {
       /* Copy to the output store. */
       ZopfliCopyLZ77Store(&currentstore, store);
@@ -551,7 +532,7 @@ void ZopfliLZ77OptimalFixed(ZopfliBlockState *s,
   /* Shortest path for fixed tree This one should give the shortest possible
   result for fixed tree, no repeated runs are needed since the tree is known. */
   LZ77OptimalRun(s, in, instart, inend, &path, &pathsize,
-                 length_array, GetCostFixed, 0, store, h, costs);
+                 length_array, 0, store, h, costs);
 
   free(length_array);
   free(path);
diff --git a/zopfli/squeeze.h b/zopfli/squeeze.h
index 48bb775..68db437 100644
--- a/zopfli/squeeze.h
+++ b/zopfli/squeeze.h
@@ -33,6 +33,24 @@ solution.
 
 #include "lz77.h"
 
+typedef struct SymbolStats {
+  /* The literal and length symbols. */
+  size_t litlens[ZOPFLI_NUM_LL];
+  /* The 32 unique dist symbols, not the 32768 possible dists. */
+  size_t dists[ZOPFLI_NUM_D];
+
+  /* Length of each lit/len symbol in bits. */
+  double ll_symbols[ZOPFLI_NUM_LL];
+  /* Length of each dist symbol in bits. */
+  double d_symbols[ZOPFLI_NUM_D];
+} SymbolStats;
+
+/* Sets everything to 0. */
+void InitStats(SymbolStats* stats);
+
+/* Appends the symbol statistics from the store. */
+void GetStatistics(const ZopfliLZ77Store* store, SymbolStats* stats);
+
 /*
 Calculates lit/len and dist pairs for given data.
 If instart is larger than 0, it uses values before instart as starting
@@ -41,7 +59,7 @@ dictionary.
 void ZopfliLZ77Optimal(ZopfliBlockState *s,
                        const unsigned char* in, size_t instart, size_t inend,
                        int numiterations,
-                       ZopfliLZ77Store* store);
+                       ZopfliLZ77Store* store, SymbolStats* instats);
 
 /*
 Does the same as ZopfliLZ77Optimal, but optimized for the fixed tree of the
diff --git a/zopfli/tree.c b/zopfli/tree.c
deleted file mode 100644
index c457511..0000000
--- a/zopfli/tree.c
+++ /dev/null
@@ -1,101 +0,0 @@
-/*
-Copyright 2011 Google Inc. All Rights Reserved.
-
-Licensed under the Apache License, Version 2.0 (the "License");
-you may not use this file except in compliance with the License.
-You may obtain a copy of the License at
-
-    http://www.apache.org/licenses/LICENSE-2.0
-
-Unless required by applicable law or agreed to in writing, software
-distributed under the License is distributed on an "AS IS" BASIS,
-WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
-See the License for the specific language governing permissions and
-limitations under the License.
-
-Author: lode.vandevenne@gmail.com (Lode Vandevenne)
-Author: jyrki.alakuijala@gmail.com (Jyrki Alakuijala)
-*/
-
-#include "tree.h"
-
-#include <assert.h>
-#include <math.h>
-#include <stdio.h>
-#include <stdlib.h>
-
-#include "katajainen.h"
-#include "util.h"
-
-void ZopfliLengthsToSymbols(const unsigned* lengths, size_t n, unsigned maxbits,
-                            unsigned* symbols) {
-  size_t* bl_count = (size_t*)malloc(sizeof(size_t) * (maxbits + 1));
-  size_t* next_code = (size_t*)malloc(sizeof(size_t) * (maxbits + 1));
-  unsigned bits, i;
-  unsigned code;
-
-  for (i = 0; i < n; i++) {
-    symbols[i] = 0;
-  }
-
-  /* 1) Count the number of codes for each code length. Let bl_count[N] be the
-  number of codes of length N, N >= 1. */
-  for (bits = 0; bits <= maxbits; bits++) {
-    bl_count[bits] = 0;
-  }
-  for (i = 0; i < n; i++) {
-    assert(lengths[i] <= maxbits);
-    bl_count[lengths[i]]++;
-  }
-  /* 2) Find the numerical value of the smallest code for each code length. */
-  code = 0;
-  bl_count[0] = 0;
-  for (bits = 1; bits <= maxbits; bits++) {
-    code = (code + bl_count[bits-1]) << 1;
-    next_code[bits] = code;
-  }
-  /* 3) Assign numerical values to all codes, using consecutive values for all
-  codes of the same length with the base values determined at step 2. */
-  for (i = 0;  i < n; i++) {
-    unsigned len = lengths[i];
-    if (len != 0) {
-      symbols[i] = next_code[len];
-      next_code[len]++;
-    }
-  }
-
-  free(bl_count);
-  free(next_code);
-}
-
-void ZopfliCalculateEntropy(const size_t* count, size_t n, double* bitlengths) {
-  static const double kInvLog2 = 1.4426950408889;  /* 1.0 / log(2.0) */
-  unsigned sum = 0;
-  unsigned i;
-  double log2sum;
-  for (i = 0; i < n; ++i) {
-    sum += count[i];
-  }
-  log2sum = (sum == 0 ? log(n) : log(sum)) * kInvLog2;
-  for (i = 0; i < n; ++i) {
-    /* When the count of the symbol is 0, but its cost is requested anyway, it
-    means the symbol will appear at least once anyway, so give it the cost as if
-    its count is 1.*/
-    if (count[i] == 0) bitlengths[i] = log2sum;
-    else bitlengths[i] = log2sum - log(count[i]) * kInvLog2;
-    /* Depending on compiler and architecture, the above subtraction of two
-    floating point numbers may give a negative result very close to zero
-    instead of zero (e.g. -5.973954e-17 with gcc 4.1.2 on Ubuntu 11.4). Clamp
-    it to zero. These floating point imprecisions do not affect the cost model
-    significantly so this is ok. */
-    if (bitlengths[i] < 0 && bitlengths[i] > -1e-5) bitlengths[i] = 0;
-    assert(bitlengths[i] >= 0);
-  }
-}
-
-void ZopfliCalculateBitLengths(const size_t* count, size_t n, int maxbits,
-                               unsigned* bitlengths) {
-  int error = ZopfliLengthLimitedCodeLengths(count, n, maxbits, bitlengths);
-  (void) error;
-  assert(!error);
-}
diff --git a/zopfli/tree.h b/zopfli/tree.h
deleted file mode 100644
index 4d6f469..0000000
--- a/zopfli/tree.h
+++ /dev/null
@@ -1,51 +0,0 @@
-/*
-Copyright 2011 Google Inc. All Rights Reserved.
-
-Licensed under the Apache License, Version 2.0 (the "License");
-you may not use this file except in compliance with the License.
-You may obtain a copy of the License at
-
-    http://www.apache.org/licenses/LICENSE-2.0
-
-Unless required by applicable law or agreed to in writing, software
-distributed under the License is distributed on an "AS IS" BASIS,
-WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
-See the License for the specific language governing permissions and
-limitations under the License.
-
-Author: lode.vandevenne@gmail.com (Lode Vandevenne)
-Author: jyrki.alakuijala@gmail.com (Jyrki Alakuijala)
-*/
-
-/*
-Utilities for creating and using Huffman trees.
-*/
-
-#ifndef ZOPFLI_TREE_H_
-#define ZOPFLI_TREE_H_
-
-#include <string.h>
-
-/*
-Calculates the bitlengths for the Huffman tree, based on the counts of each
-symbol.
-*/
-void ZopfliCalculateBitLengths(const size_t* count, size_t n, int maxbits,
-                               unsigned *bitlengths);
-
-/*
-Converts a series of Huffman tree bitlengths, to the bit values of the symbols.
-*/
-void ZopfliLengthsToSymbols(const unsigned* lengths, size_t n, unsigned maxbits,
-                            unsigned* symbols);
-
-/*
-Calculates the entropy of each symbol, based on the counts of each symbol. The
-result is similar to the result of ZopfliCalculateBitLengths, but with the
-actual theoritical bit lengths according to the entropy. Since the resulting
-values are fractional, they cannot be used to encode the tree specified by
-DEFLATE.
-*/
-void ZopfliCalculateEntropy(const size_t* count, size_t n, double* bitlengths);
-
-#endif  /* ZOPFLI_TREE_H_ */
diff --git a/zopfli/zlib_container.c b/zopfli/zlib_container.c
deleted file mode 100644
index 130ffc7..0000000
--- a/zopfli/zlib_container.c
+++ /dev/null
@@ -1,79 +0,0 @@
-/*
-Copyright 2013 Google Inc. All Rights Reserved.
-
-Licensed under the Apache License, Version 2.0 (the "License");
-you may not use this file except in compliance with the License.
-You may obtain a copy of the License at
-
-    http://www.apache.org/licenses/LICENSE-2.0
-
-Unless required by applicable law or agreed to in writing, software
-distributed under the License is distributed on an "AS IS" BASIS,
-WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
-See the License for the specific language governing permissions and
-limitations under the License.
-
-Author: lode.vandevenne@gmail.com (Lode Vandevenne)
-Author: jyrki.alakuijala@gmail.com (Jyrki Alakuijala)
-*/
-
-#include "zlib_container.h"
-#include "util.h"
-
-#include <stdio.h>
-
-#include "deflate.h"
-
-
-/* Calculates the adler32 checksum of the data */
-static unsigned adler32(const unsigned char* data, size_t size)
-{
-  static const unsigned sums_overflow = 5550;
-  unsigned s1 = 1;
-  unsigned s2 = 1 >> 16;
-
-  while (size > 0) {
-    size_t amount = size > sums_overflow ? sums_overflow : size;
-    size -= amount;
-    while (amount > 0) {
-      s1 += (*data++);
-      s2 += s1;
-      amount--;
-    }
-    s1 %= 65521;
-    s2 %= 65521;
-  }
-
-  return (s2 << 16) | s1;
-}
-
-void ZopfliZlibCompress(const ZopfliOptions* options,
-                        const unsigned char* in, size_t insize,
-                        unsigned char** out, size_t* outsize) {
-  unsigned char bitpointer = 0;
-  unsigned checksum = adler32(in, (unsigned)insize);
-  unsigned cmf = 120;  /* CM 8, CINFO 7. See zlib spec.*/
-  unsigned flevel = 3;
-  unsigned fdict = 0;
-  unsigned cmfflg = 256 * cmf + fdict * 32 + flevel * 64;
-  unsigned fcheck = 31 - cmfflg % 31;
-  cmfflg += fcheck;
-
-  ZOPFLI_APPEND_DATA(cmfflg / 256, out, outsize);
-  ZOPFLI_APPEND_DATA(cmfflg % 256, out, outsize);
-
-  ZopfliDeflate(options, 2 /* dynamic block */, 1 /* final */,
-                in, insize, &bitpointer, out, outsize);
-
-  ZOPFLI_APPEND_DATA((checksum >> 24) % 256, out, outsize);
-  ZOPFLI_APPEND_DATA((checksum >> 16) % 256, out, outsize);
-  ZOPFLI_APPEND_DATA((checksum >> 8) % 256, out, outsize);
-  ZOPFLI_APPEND_DATA(checksum % 256, out, outsize);
-
-  if (options->verbose) {
-    fprintf(stderr,
-            "Original Size: %d, Zlib: %d, Compression: %f%% Removed\n",
-            (int)insize, (int)*outsize,
-            100.0 * (double)(insize - *outsize) / (double)insize);
-  }
-}
diff --git a/zopfli/zlib_container.h b/zopfli/zlib_container.h
deleted file mode 100644
index 9ddfb9c..0000000
--- a/zopfli/zlib_container.h
+++ /dev/null
@@ -1,50 +0,0 @@
-/*
-Copyright 2013 Google Inc. All Rights Reserved.
-
-Licensed under the Apache License, Version 2.0 (the "License");
-you may not use this file except in compliance with the License.
-You may obtain a copy of the License at
-
-    http://www.apache.org/licenses/LICENSE-2.0
-
-Unless required by applicable law or agreed to in writing, software
-distributed under the License is distributed on an "AS IS" BASIS,
-WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
-See the License for the specific language governing permissions and
-limitations under the License.
-
-Author: lode.vandevenne@gmail.com (Lode Vandevenne)
-Author: jyrki.alakuijala@gmail.com (Jyrki Alakuijala)
-*/
-
-#ifndef ZOPFLI_ZLIB_H_
-#define ZOPFLI_ZLIB_H_
-
-/*
-Functions to compress according to the Zlib specification.
-*/
-
-#include "zopfli.h"
-
-#ifdef __cplusplus
-extern "C" {
-#endif
-
-/*
-Compresses according to the zlib specification and append the compressed
-result to the output.
-
-options: global program options
-out: pointer to the dynamic output array to which the result is appended. Must
-  be freed after use.
-outsize: pointer to the dynamic output array size.
-*/
-void ZopfliZlibCompress(const ZopfliOptions* options,
-                        const unsigned char* in, size_t insize,
-                        unsigned char** out, size_t* outsize);
-
-#ifdef __cplusplus
-}  // extern "C"
-#endif
-
-#endif  /* ZOPFLI_ZLIB_H_ */
diff --git a/zopfli/zopfli_bin.c b/zopfli/zopfli_bin.c
deleted file mode 100644
index a42bade..0000000
--- a/zopfli/zopfli_bin.c
+++ /dev/null
@@ -1,219 +0,0 @@
-/*
-Copyright 2011 Google Inc. All Rights Reserved.
-
-Licensed under the Apache License, Version 2.0 (the "License");
-you may not use this file except in compliance with the License.
-You may obtain a copy of the License at
-
-    http://www.apache.org/licenses/LICENSE-2.0
-
-Unless required by applicable law or agreed to in writing, software
-distributed under the License is distributed on an "AS IS" BASIS,
-WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
-See the License for the specific language governing permissions and
-limitations under the License.
-
-Author: lode.vandevenne@gmail.com (Lode Vandevenne)
-Author: jyrki.alakuijala@gmail.com (Jyrki Alakuijala)
-*/
-
-/*
-Zopfli compressor program. It can output gzip-, zlib- or deflate-compatible
-data. By default it creates a .gz file. This tool can only compress, not
-decompress. Decompression can be done by any standard gzip, zlib or deflate
-decompressor.
-*/
-
-#include <assert.h>
-#include <stdio.h>
-#include <stdlib.h>
-#include <string.h>
-
-#include "deflate.h"
-#include "gzip_container.h"
-#include "zlib_container.h"
-
-/* Windows workaround for stdout output. */
-#if _WIN32
-#include <fcntl.h>
-#endif
-
-/*
-Loads a file into a memory array. Returns 1 on success, 0 if file doesn't exist
-or couldn't be opened.
-*/
-static int LoadFile(const char* filename,
-                    unsigned char** out, size_t* outsize) {
-  FILE* file;
-
-  *out = 0;
-  *outsize = 0;
-  file = fopen(filename, "rb");
-  if (!file) return 0;
-
-  fseek(file , 0 , SEEK_END);
-  *outsize = ftell(file);
-  if(*outsize > 2147483647) {
-    fprintf(stderr,"Files larger than 2GB are not supported.\n");
-    exit(EXIT_FAILURE);
-  }
-  rewind(file);
-
-  *out = (unsigned char*)malloc(*outsize);
-
-  if (*outsize && (*out)) {
-    size_t testsize = fread(*out, 1, *outsize, file);
-    if (testsize != *outsize) {
-      /* It could be a directory */
-      free(*out);
-      *out = 0;
-      *outsize = 0;
-      fclose(file);
-      return 0;
-    }
-  }
-
-  assert(!(*outsize) || out);  /* If size is not zero, out must be allocated. */
-  fclose(file);
-  return 1;
-}
-
-/*
-Saves a file from a memory array, overwriting the file if it existed.
-*/
-static void SaveFile(const char* filename,
-                     const unsigned char* in, size_t insize) {
-  FILE* file = fopen(filename, "wb" );
-  if (file == NULL) {
-      fprintf(stderr,"Error: Cannot write to output file, terminating.\n");
-      exit (EXIT_FAILURE);
-  }
-  assert(file);
-  fwrite((char*)in, 1, insize, file);
-  fclose(file);
-}
-
-/*
-outfilename: filename to write output to, or 0 to write to stdout instead
-*/
-static void CompressFile(const ZopfliOptions* options,
-                         ZopfliFormat output_type,
-                         const char* infilename,
-                         const char* outfilename) {
-  unsigned char* in;
-  size_t insize;
-  unsigned char* out = 0;
-  size_t outsize = 0;
-  if (!LoadFile(infilename, &in, &insize)) {
-    fprintf(stderr, "Invalid filename: %s\n", infilename);
-    return;
-  }
-
-  ZopfliCompress(options, output_type, in, insize, &out, &outsize);
-
-  if (outfilename) {
-    SaveFile(outfilename, out, outsize);
-  } else {
-#if _WIN32
-    /* Windows workaround for stdout output. */
-    _setmode(_fileno(stdout), _O_BINARY);
-#endif
-    fwrite(out, 1, outsize, stdout);
-  }
-
-  free(out);
-  free(in);
-}
-
-/*
-Add two strings together. Size does not matter. Result must be freed.
-*/
-static char* AddStrings(const char* str1, const char* str2) {
-  size_t len = strlen(str1) + strlen(str2);
-  char* result = (char*)malloc(len + 1);
-  if (!result) exit(-1); /* Allocation failed. */
-  strcpy(result, str1);
-  strcat(result, str2);
-  return result;
-}
-
-static char StringsEqual(const char* str1, const char* str2) {
-  return strcmp(str1, str2) == 0;
-}
-
-int main(int argc, char* argv[]) {
-  ZopfliOptions options;
-  ZopfliFormat output_type = ZOPFLI_FORMAT_GZIP;
-  const char* filename = 0;
-  int output_to_stdout = 0;
-  int i;
-
-  ZopfliInitOptions(&options);
-
-  for (i = 1; i < argc; i++) {
-    const char* arg = argv[i];
-    if (StringsEqual(arg, "-v")) options.verbose = 1;
-    else if (StringsEqual(arg, "-c")) output_to_stdout = 1;
-    else if (StringsEqual(arg, "--deflate")) {
-      output_type = ZOPFLI_FORMAT_DEFLATE;
-    }
-    else if (StringsEqual(arg, "--zlib")) output_type = ZOPFLI_FORMAT_ZLIB;
-    else if (StringsEqual(arg, "--gzip")) output_type = ZOPFLI_FORMAT_GZIP;
-    else if (StringsEqual(arg, "--splitlast"))  /* Ignore */;
-    else if (arg[0] == '-' && arg[1] == '-' && arg[2] == 'i'
-        && arg[3] >= '0' && arg[3] <= '9') {
-      options.numiterations = atoi(arg + 3);
-    }
-    else if (StringsEqual(arg, "-h")) {
-      fprintf(stderr,
-          "Usage: zopfli [OPTION]... FILE...\n"
-          "  -h    gives this help\n"
-          "  -c    write the result on standard output, instead of disk"
-          " filename + '.gz'\n"
-          "  -v    verbose mode\n"
-          "  --i#  perform # iterations (default 15). More gives"
-          " more compression but is slower."
-          " Examples: --i10, --i50, --i1000\n");
-      fprintf(stderr,
-          "  --gzip        output to gzip format (default)\n"
-          "  --zlib        output to zlib format instead of gzip\n"
-          "  --deflate     output to deflate format instead of gzip\n"
-          "  --splitlast   ignored, left for backwards compatibility\n");
-      return 0;
-    }
-  }
-
-  if (options.numiterations < 1) {
-    fprintf(stderr, "Error: must have 1 or more iterations\n");
-    return 0;
-  }
-
-  for (i = 1; i < argc; i++) {
-    if (argv[i][0] != '-') {
-      char* outfilename;
-      filename = argv[i];
-      if (output_to_stdout) {
-        outfilename = 0;
-      } else if (output_type == ZOPFLI_FORMAT_GZIP) {
-        outfilename = AddStrings(filename, ".gz");
-      } else if (output_type == ZOPFLI_FORMAT_ZLIB) {
-        outfilename = AddStrings(filename, ".zlib");
-      } else {
-        assert(output_type == ZOPFLI_FORMAT_DEFLATE);
-        outfilename = AddStrings(filename, ".deflate");
-      }
-      if (options.verbose && outfilename) {
-        fprintf(stderr, "Saving to: %s\n", outfilename);
-      }
-      CompressFile(&options, output_type, filename, outfilename);
-      free(outfilename);
-    }
-  }
-
-  if (!filename) {
-    fprintf(stderr,
-            "Please provide filename\nFor help, type: %s -h\n", argv[0]);
-  }
-
-  return 0;
-}
diff --git a/zopfli/zopfli_lib.c b/zopfli/zopfli_lib.c
deleted file mode 100644
index 5f5b214..0000000
--- a/zopfli/zopfli_lib.c
+++ /dev/null
@@ -1,42 +0,0 @@
-/*
-Copyright 2011 Google Inc. All Rights Reserved.
-
-Licensed under the Apache License, Version 2.0 (the "License");
-you may not use this file except in compliance with the License.
-You may obtain a copy of the License at
-
-    http://www.apache.org/licenses/LICENSE-2.0
-
-Unless required by applicable law or agreed to in writing, software
-distributed under the License is distributed on an "AS IS" BASIS,
-WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
-See the License for the specific language governing permissions and
-limitations under the License.
-
-Author: lode.vandevenne@gmail.com (Lode Vandevenne)
-Author: jyrki.alakuijala@gmail.com (Jyrki Alakuijala)
-*/
-
-#include "zopfli.h"
-
-#include "deflate.h"
-#include "gzip_container.h"
-#include "zlib_container.h"
-
-#include <assert.h>
-
-void ZopfliCompress(const ZopfliOptions* options, ZopfliFormat output_type,
-                    const unsigned char* in, size_t insize,
-                    unsigned char** out, size_t* outsize) {
-  if (output_type == ZOPFLI_FORMAT_GZIP) {
-    ZopfliGzipCompress(options, in, insize, out, outsize);
-  } else if (output_type == ZOPFLI_FORMAT_ZLIB) {
-    ZopfliZlibCompress(options, in, insize, out, outsize);
-  } else if (output_type == ZOPFLI_FORMAT_DEFLATE) {
-    unsigned char bp = 0;
-    ZopfliDeflate(options, 2 /* Dynamic block */, 1,
-                  in, insize, &bp, out, outsize);
-  } else {
-    assert(0);
-  }
-}
