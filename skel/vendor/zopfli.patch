diff --git a/zopfli/blocksplitter.c b/zopfli/blocksplitter.c
index 161783d..33062bb 100644
--- a/zopfli/blocksplitter.c
+++ b/zopfli/blocksplitter.c
@@ -24,8 +24,6 @@ Author: jyrki.alakuijala@gmail.com (Jyrki Alakuijala)
 #include <stdlib.h>
 
 #include "deflate.h"
-#include "squeeze.h"
-#include "tree.h"
 #include "util.h"
 
 /*
@@ -62,7 +60,7 @@ static size_t FindMinimum(FindMinimumFun f, void* context,
     size_t p[NUM];
     double vp[NUM];
     size_t besti;
-    double best;
+    double best = ZOPFLI_LARGE_FLOAT;
     double lastbest = ZOPFLI_LARGE_FLOAT;
     size_t pos = start;
 
@@ -71,6 +69,10 @@ static size_t FindMinimum(FindMinimumFun f, void* context,
 
       for (i = 0; i < NUM; i++) {
         p[i] = start + (i + 1) * ((end - start) / (NUM + 1));
+        if(pos == p[i]){
+          vp[i] = best;
+          continue;
+        }
         vp[i] = f(p[i], context);
       }
       besti = 0;
@@ -224,9 +226,8 @@ void ZopfliBlockSplitLZ77(const ZopfliOptions* options,
 
   if (lz77->size < 10) return;  /* This code fails on tiny files. */
 
-  done = (unsigned char*)malloc(lz77->size);
+  done = (unsigned char*)calloc(lz77->size, 1);
   if (!done) exit(-1); /* Allocation failed. */
-  for (i = 0; i < lz77->size; i++) done[i] = 0;
 
   lstart = 0;
   lend = lz77->size;
@@ -265,16 +266,12 @@ void ZopfliBlockSplitLZ77(const ZopfliOptions* options,
     }
   }
 
-  if (options->verbose) {
-    PrintBlockSplitPoints(lz77, *splitpoints, *npoints);
-  }
-
   free(done);
 }
 
 void ZopfliBlockSplit(const ZopfliOptions* options,
                       const unsigned char* in, size_t instart, size_t inend,
-                      size_t maxblocks, size_t** splitpoints, size_t* npoints) {
+                      size_t maxblocks, size_t** splitpoints, size_t* npoints, SymbolStats** stats) {
   size_t pos = 0;
   size_t i;
   ZopfliBlockState s;
@@ -298,19 +295,47 @@ void ZopfliBlockSplit(const ZopfliOptions* options,
   ZopfliBlockSplitLZ77(options,
                        &store, maxblocks,
                        &lz77splitpoints, &nlz77points);
+  (*stats) = (SymbolStats*)realloc(*stats, (nlz77points + 1) * sizeof(SymbolStats));
 
   /* Convert LZ77 positions to positions in the uncompressed input. */
   pos = instart;
   if (nlz77points > 0) {
+  	size_t shift2;
     for (i = 0; i < store.size; i++) {
       size_t length = store.dists[i] == 0 ? 1 : store.litlens[i];
-      if (lz77splitpoints[*npoints] == i) {
+      if (lz77splitpoints[(*npoints)] == i) {
+        size_t temp = store.size;
+        size_t shift = (*npoints) ? lz77splitpoints[*npoints - 1] : 0;
+        store.size = i - shift;
+        store.dists += shift;
+        store.litlens += shift;
+
+        InitStats(&((*stats)[*npoints]));
+        GetStatistics(&store, &((*stats)[*npoints]));
+        store.size = temp;
+        store.dists -= shift;
+        store.litlens -= shift;
         ZOPFLI_APPEND_DATA(pos, splitpoints, npoints);
         if (*npoints == nlz77points) break;
       }
       pos += length;
     }
+    shift2 = lz77splitpoints[*npoints - 1];
+    store.size -= shift2;
+    store.dists += shift2;
+    store.litlens += shift2;
+
+    InitStats(&((*stats)[*npoints]));
+    GetStatistics(&store, &((*stats)[*npoints]));
+    store.size += shift2;
+    store.dists -= shift2;
+    store.litlens -= shift2;
+  }
+  else{
+    InitStats(*stats);
+    GetStatistics(&store, *stats);
   }
+
   assert(*npoints == nlz77points);
 
   free(lz77splitpoints);
diff --git a/zopfli/blocksplitter.h b/zopfli/blocksplitter.h
index d1d622f..e4b769f 100644
--- a/zopfli/blocksplitter.h
+++ b/zopfli/blocksplitter.h
@@ -31,6 +31,7 @@ ones that enhance it.
 #include <stdlib.h>
 
 #include "lz77.h"
+#include "squeeze.h"
 #include "zopfli.h"
 
 
@@ -59,7 +60,7 @@ npoints: pointer to amount of splitpoints, for the dynamic array. The amount of
 */
 void ZopfliBlockSplit(const ZopfliOptions* options,
                       const unsigned char* in, size_t instart, size_t inend,
-                      size_t maxblocks, size_t** splitpoints, size_t* npoints);
+                      size_t maxblocks, size_t** splitpoints, size_t* npoints, SymbolStats** stats);
 
 /*
 Divides the input into equal blocks, does not even take LZ77 lengths into
diff --git a/zopfli/cache.c b/zopfli/cache.c
index 6b9444f..438a9ed 100644
--- a/zopfli/cache.c
+++ b/zopfli/cache.c
@@ -28,9 +28,9 @@ Author: jyrki.alakuijala@gmail.com (Jyrki Alakuijala)
 void ZopfliInitCache(size_t blocksize, ZopfliLongestMatchCache* lmc) {
   size_t i;
   lmc->length = (unsigned short*)malloc(sizeof(unsigned short) * blocksize);
-  lmc->dist = (unsigned short*)malloc(sizeof(unsigned short) * blocksize);
+  lmc->dist = (unsigned short*)calloc(blocksize, sizeof(unsigned short));
   /* Rather large amount of memory. */
-  lmc->sublen = (unsigned char*)malloc(ZOPFLI_CACHE_LENGTH * 3 * blocksize);
+  lmc->sublen = (unsigned char*)calloc(ZOPFLI_CACHE_LENGTH * 3 * blocksize, 1);
   if(lmc->sublen == NULL) {
     fprintf(stderr,
         "Error: Out of memory. Tried allocating %lu bytes of memory.\n",
@@ -41,8 +41,6 @@ void ZopfliInitCache(size_t blocksize, ZopfliLongestMatchCache* lmc) {
   /* length > 0 and dist 0 is invalid combination, which indicates on purpose
   that this cache value is not filled in yet. */
   for (i = 0; i < blocksize; i++) lmc->length[i] = 1;
-  for (i = 0; i < blocksize; i++) lmc->dist[i] = 0;
-  for (i = 0; i < ZOPFLI_CACHE_LENGTH * blocksize * 3; i++) lmc->sublen[i] = 0;
 }
 
 void ZopfliCleanCache(ZopfliLongestMatchCache* lmc) {
diff --git a/zopfli/deflate.c b/zopfli/deflate.c
index c5abda9..0bce4bf 100644
--- a/zopfli/deflate.c
+++ b/zopfli/deflate.c
@@ -23,10 +23,11 @@ Author: jyrki.alakuijala@gmail.com (Jyrki Alakuijala)
 #include <stdio.h>
 #include <stdlib.h>
 
+#include "../rust.h"
 #include "blocksplitter.h"
 #include "squeeze.h"
 #include "symbols.h"
-#include "tree.h"
+#include "katajainen.h"
 
 /*
 bp = bitpointer, always in range [0, 7].
@@ -128,7 +129,7 @@ static size_t EncodeTree(const unsigned* ll_lengths,
   int size_only = !out;
   size_t result_size = 0;
 
-  for(i = 0; i < 19; i++) clcounts[i] = 0;
+  for (i = 0; i < 19; i++) clcounts[i] = 0;
 
   /* Trim zeros. */
   while (hlit > 0 && ll_lengths[257 + hlit - 1] == 0) hlit--;
@@ -205,8 +206,8 @@ static size_t EncodeTree(const unsigned* ll_lengths,
     }
   }
 
-  ZopfliCalculateBitLengths(clcounts, 19, 7, clcl);
-  if (!size_only) ZopfliLengthsToSymbols(clcl, 19, 7, clsymbols);
+  assert(!ZopfliLengthLimitedCodeLengths(clcounts, 19, 7, clcl));
+  if (!size_only) ZopfliLengthsToSymbols7(clcl, 19, clsymbols);
 
   hclen = 15;
   /* Trim zeros. */
@@ -449,8 +450,7 @@ void OptimizeHuffmanForRle(int length, size_t* counts) {
   }
   /* 2) Let's mark all population counts that already can be encoded
   with an rle code.*/
-  good_for_rle = (int*)malloc((unsigned)length * sizeof(int));
-  for (i = 0; i < length; ++i) good_for_rle[i] = 0;
+  good_for_rle = (int*)calloc((unsigned)length, sizeof(int));
 
   /* Let's not spoil any of the existing good rle codes.
   Mark any seq of 0's that is longer than 5 as a good_for_rle.
@@ -543,8 +543,8 @@ static double TryOptimizeHuffmanForRle(
   memcpy(d_counts2, d_counts, sizeof(d_counts2));
   OptimizeHuffmanForRle(ZOPFLI_NUM_LL, ll_counts2);
   OptimizeHuffmanForRle(ZOPFLI_NUM_D, d_counts2);
-  ZopfliCalculateBitLengths(ll_counts2, ZOPFLI_NUM_LL, 15, ll_lengths2);
-  ZopfliCalculateBitLengths(d_counts2, ZOPFLI_NUM_D, 15, d_lengths2);
+  assert(!ZopfliLengthLimitedCodeLengths(ll_counts2, ZOPFLI_NUM_LL, 15, ll_lengths2));
+  assert(!ZopfliLengthLimitedCodeLengths(d_counts2, ZOPFLI_NUM_D, 15, d_lengths2));
   PatchDistanceCodesForBuggyDecoders(d_lengths2);
 
   treesize2 = CalculateTreeSize(ll_lengths2, d_lengths2);
@@ -574,8 +574,8 @@ static double GetDynamicLengths(const ZopfliLZ77Store* lz77,
 
   ZopfliLZ77GetHistogram(lz77, lstart, lend, ll_counts, d_counts);
   ll_counts[256] = 1;  /* End symbol. */
-  ZopfliCalculateBitLengths(ll_counts, ZOPFLI_NUM_LL, 15, ll_lengths);
-  ZopfliCalculateBitLengths(d_counts, ZOPFLI_NUM_D, 15, d_lengths);
+  assert(!ZopfliLengthLimitedCodeLengths(ll_counts, ZOPFLI_NUM_LL, 15, ll_lengths));
+  assert(!ZopfliLengthLimitedCodeLengths(d_counts, ZOPFLI_NUM_D, 15, d_lengths));
   PatchDistanceCodesForBuggyDecoders(d_lengths);
   return TryOptimizeHuffmanForRle(
       lz77, lstart, lend, ll_counts, d_counts, ll_lengths, d_lengths);
@@ -718,13 +718,10 @@ static void AddLZ77Block(const ZopfliOptions* options, int btype, int final,
 
     detect_tree_size = *outsize;
     AddDynamicTree(ll_lengths, d_lengths, bp, out, outsize);
-    if (options->verbose) {
-      fprintf(stderr, "treesize: %d\n", (int)(*outsize - detect_tree_size));
-    }
   }
 
-  ZopfliLengthsToSymbols(ll_lengths, ZOPFLI_NUM_LL, 15, ll_symbols);
-  ZopfliLengthsToSymbols(d_lengths, ZOPFLI_NUM_D, 15, d_symbols);
+  ZopfliLengthsToSymbols15(ll_lengths, ZOPFLI_NUM_LL, ll_symbols);
+  ZopfliLengthsToSymbols15(d_lengths, ZOPFLI_NUM_D, d_symbols);
 
   detect_block_size = *outsize;
   AddLZ77Data(lz77, lstart, lend, expected_data_size,
@@ -737,11 +734,6 @@ static void AddLZ77Block(const ZopfliOptions* options, int btype, int final,
     uncompressed_size += lz77->dists[i] == 0 ? 1 : lz77->litlens[i];
   }
   compressed_size = *outsize - detect_block_size;
-  if (options->verbose) {
-    fprintf(stderr, "compressed block size: %d (%dk) (unc: %d)\n",
-           (int)compressed_size, (int)(compressed_size / 1024),
-           (int)(uncompressed_size));
-  }
 }
 
 static void AddLZ77BlockAutoType(const ZopfliOptions* options, int final,
@@ -813,6 +805,8 @@ void ZopfliDeflatePart(const ZopfliOptions* options, int btype, int final,
                        unsigned char* bp, unsigned char** out,
                        size_t* outsize) {
   size_t i;
+  SymbolStats* stats;
+
   /* byte coordinates rather than lz77 index */
   size_t* splitpoints_uncompressed = 0;
   size_t npoints = 0;
@@ -820,6 +814,7 @@ void ZopfliDeflatePart(const ZopfliOptions* options, int btype, int final,
   double totalcost = 0;
   ZopfliLZ77Store lz77;
 
+  stats = 0;
   /* If btype=2 is specified, it tries all block types. If a lesser btype is
   given, then however it forces that one. Neither of the lesser types needs
   block splitting as they have no dynamic huffman trees. */
@@ -845,7 +840,7 @@ void ZopfliDeflatePart(const ZopfliOptions* options, int btype, int final,
   if (options->blocksplitting) {
     ZopfliBlockSplit(options, in, instart, inend,
                      options->blocksplittingmax,
-                     &splitpoints_uncompressed, &npoints);
+                     &splitpoints_uncompressed, &npoints, &stats);
     splitpoints = (size_t*)malloc(sizeof(*splitpoints) * npoints);
   }
 
@@ -858,7 +853,7 @@ void ZopfliDeflatePart(const ZopfliOptions* options, int btype, int final,
     ZopfliLZ77Store store;
     ZopfliInitLZ77Store(in, &store);
     ZopfliInitBlockState(options, start, end, 1, &s);
-    ZopfliLZ77Optimal(&s, in, start, end, options->numiterations, &store);
+    ZopfliLZ77Optimal(&s, in, start, end, options->numiterations, &store, stats ? &stats[i] : 0);
     totalcost += ZopfliCalculateBlockSizeAutoType(&store, 0, store.size);
 
     ZopfliAppendLZ77Store(&store, &lz77);
@@ -868,6 +863,10 @@ void ZopfliDeflatePart(const ZopfliOptions* options, int btype, int final,
     ZopfliCleanLZ77Store(&store);
   }
 
+  if(stats){
+    free(stats);
+  }
+
   /* Second block splitting attempt */
   if (options->blocksplitting && npoints > 1) {
     size_t* splitpoints2 = 0;
@@ -922,10 +921,4 @@ void ZopfliDeflate(const ZopfliOptions* options, int btype, int final,
     i += size;
   } while (i < insize);
 #endif
-  if (options->verbose) {
-    fprintf(stderr,
-            "Original Size: %lu, Deflate: %lu, Compression: %f%% Removed\n",
-            (unsigned long)insize, (unsigned long)(*outsize - offset),
-            100.0 * (double)(insize - (*outsize - offset)) / (double)insize);
-  }
 }
diff --git a/zopfli/gzip_container.c b/zopfli/gzip_container.c
index 7615db3..969d8c1 100644
--- a/zopfli/gzip_container.c
+++ b/zopfli/gzip_container.c
@@ -114,11 +114,4 @@ void ZopfliGzipCompress(const ZopfliOptions* options,
   ZOPFLI_APPEND_DATA((insize >> 8) % 256, out, outsize);
   ZOPFLI_APPEND_DATA((insize >> 16) % 256, out, outsize);
   ZOPFLI_APPEND_DATA((insize >> 24) % 256, out, outsize);
-
-  if (options->verbose) {
-    fprintf(stderr,
-            "Original Size: %d, Gzip: %d, Compression: %f%% Removed\n",
-            (int)insize, (int)*outsize,
-            100.0 * (double)(insize - *outsize) / (double)insize);
-  }
 }
diff --git a/zopfli/hash.c b/zopfli/hash.c
index 3025d1e..20d8eac 100644
--- a/zopfli/hash.c
+++ b/zopfli/hash.c
@@ -46,30 +46,26 @@ void ZopfliResetHash(size_t window_size, ZopfliHash* h) {
   size_t i;
 
   h->val = 0;
+#ifdef ZOPFLI_HASH_SAME_HASH
+  h->val2 = 0;
+#endif
   for (i = 0; i < 65536; i++) {
     h->head[i] = -1;  /* -1 indicates no head so far. */
+#ifdef ZOPFLI_HASH_SAME_HASH
+    h->head2[i] = -1;
+#endif
   }
   for (i = 0; i < window_size; i++) {
     h->prev[i] = i;  /* If prev[j] == j, then prev[j] is uninitialized. */
     h->hashval[i] = -1;
-  }
-
 #ifdef ZOPFLI_HASH_SAME
-  for (i = 0; i < window_size; i++) {
     h->same[i] = 0;
-  }
 #endif
-
 #ifdef ZOPFLI_HASH_SAME_HASH
-  h->val2 = 0;
-  for (i = 0; i < 65536; i++) {
-    h->head2[i] = -1;
-  }
-  for (i = 0; i < window_size; i++) {
     h->prev2[i] = i;
     h->hashval2[i] = -1;
-  }
 #endif
+  }
 }
 
 void ZopfliCleanHash(ZopfliHash* h) {
diff --git a/zopfli/katajainen.c b/zopfli/katajainen.c
index 1459017..eb13a21 100644
--- a/zopfli/katajainen.c
+++ b/zopfli/katajainen.c
@@ -39,13 +39,6 @@ struct Node {
   int count;  /* Leaf symbol index, or number of leaves before this chain. */
 };
 
-/*
-Memory pool for nodes.
-*/
-typedef struct NodePool {
-  Node* next;  /* Pointer to a free node in the pool. */
-} NodePool;
-
 /*
 Initializes a chain node with the given values and marks it as in use.
 */
@@ -55,64 +48,18 @@ static void InitNode(size_t weight, int count, Node* tail, Node* node) {
   node->tail = tail;
 }
 
-/*
-Performs a Boundary Package-Merge step. Puts a new chain in the given list. The
-new chain is, depending on the weights, a leaf or a combination of two chains
-from the previous list.
-lists: The lists of chains.
-maxbits: Number of lists.
-leaves: The leaves, one per symbol.
-numsymbols: Number of leaves.
-pool: the node memory pool.
-index: The index of the list in which a new chain or leaf is required.
-*/
-static void BoundaryPM(Node* (*lists)[2], Node* leaves, int numsymbols,
-                       NodePool* pool, int index) {
-  Node* newchain;
-  Node* oldchain;
-  int lastcount = lists[index][1]->count;  /* Count of last chain of list. */
-
-  if (index == 0 && lastcount >= numsymbols) return;
-
-  newchain = pool->next++;
-  oldchain = lists[index][1];
-
-  /* These are set up before the recursive calls below, so that there is a list
-  pointing to the new node, to let the garbage collection know it's in use. */
-  lists[index][0] = oldchain;
-  lists[index][1] = newchain;
-
-  if (index == 0) {
-    /* New leaf node in list 0. */
-    InitNode(leaves[lastcount].weight, lastcount + 1, 0, newchain);
-  } else {
-    size_t sum = lists[index - 1][0]->weight + lists[index - 1][1]->weight;
-    if (lastcount < numsymbols && sum > leaves[lastcount].weight) {
-      /* New leaf inserted in list, so count is incremented. */
-      InitNode(leaves[lastcount].weight, lastcount + 1, oldchain->tail,
-          newchain);
-    } else {
-      InitNode(sum, lastcount, lists[index - 1][1], newchain);
-      /* Two lookahead chains of previous list used up, create new ones. */
-      BoundaryPM(lists, leaves, numsymbols, pool, index - 1);
-      BoundaryPM(lists, leaves, numsymbols, pool, index - 1);
-    }
-  }
-}
-
 static void BoundaryPMFinal(Node* (*lists)[2],
-    Node* leaves, int numsymbols, NodePool* pool, int index) {
+    Node* leaves, int numsymbols, Node* pool, int index) {
   int lastcount = lists[index][1]->count;  /* Count of last chain of list. */
 
   size_t sum = lists[index - 1][0]->weight + lists[index - 1][1]->weight;
 
   if (lastcount < numsymbols && sum > leaves[lastcount].weight) {
-    Node* newchain = pool->next;
     Node* oldchain = lists[index][1]->tail;
 
-    lists[index][1] = newchain;
-    newchain->count = lastcount + 1;
-    newchain->tail = oldchain;
+    lists[index][1] = pool;
+    pool->count = lastcount + 1;
+    pool->tail = oldchain;
   } else {
     lists[index][1]->tail = lists[index - 1][1];
   }
@@ -123,10 +70,10 @@ Initializes each list with as lookahead chains the two leaves with lowest
 weights.
 */
 static void InitLists(
-    NodePool* pool, const Node* leaves, int maxbits, Node* (*lists)[2]) {
+    Node* pool, const Node* leaves, int maxbits, Node* (*lists)[2]) {
   int i;
-  Node* node0 = pool->next++;
-  Node* node1 = pool->next++;
+  Node* node0 = pool;
+  Node* node1 = pool + 1;
   InitNode(leaves[0].weight, 1, 0, node0);
   InitNode(leaves[1].weight, 2, 0, node1);
   for (i = 0; i < maxbits; i++) {
@@ -171,11 +118,12 @@ static int LeafComparator(const void* a, const void* b) {
 
 int ZopfliLengthLimitedCodeLengths(
     const size_t* frequencies, int n, int maxbits, unsigned* bitlengths) {
-  NodePool pool;
+  Node* pool;
   int i;
   int numsymbols = 0;  /* Amount of symbols with frequency > 0. */
   int numBoundaryPMRuns;
   Node* nodes;
+  unsigned char stack[16];
 
   /* Array of lists of chains. Each list requires only two lookahead chains at
   a time, so each list is a array of two Node*'s. */
@@ -185,12 +133,9 @@ int ZopfliLengthLimitedCodeLengths(
   Node* leaves = (Node*)malloc(n * sizeof(*leaves));
 
   /* Initialize all bitlengths at 0. */
-  for (i = 0; i < n; i++) {
-    bitlengths[i] = 0;
-  }
-
   /* Count used symbols and place them in the leaves. */
   for (i = 0; i < n; i++) {
+    bitlengths[i] = 0;
     if (frequencies[i]) {
       leaves[numsymbols].weight = frequencies[i];
       leaves[numsymbols].count = i;  /* Index of symbol this leaf represents. */
@@ -240,18 +185,71 @@ int ZopfliLengthLimitedCodeLengths(
 
   /* Initialize node memory pool. */
   nodes = (Node*)malloc(maxbits * 2 * numsymbols * sizeof(Node));
-  pool.next = nodes;
+  pool = nodes;
 
   lists = (Node* (*)[2])malloc(maxbits * sizeof(*lists));
-  InitLists(&pool, leaves, maxbits, lists);
+  InitLists(pool, leaves, maxbits, lists);
+  pool += 2;
 
   /* In the last list, 2 * numsymbols - 2 active chains need to be created. Two
   are already created in the initialization. Each BoundaryPM run creates one. */
   numBoundaryPMRuns = 2 * numsymbols - 4;
   for (i = 0; i < numBoundaryPMRuns - 1; i++) {
-    BoundaryPM(lists, leaves, numsymbols, &pool, maxbits - 1);
+    /*
+    Performs a Boundary Package-Merge step. Puts a new chain in the given list. The
+    new chain is, depending on the weights, a leaf or a combination of two chains
+    from the previous list.
+    */
+    unsigned stackpos;
+    stack[0] = maxbits - 1;
+
+    for (stackpos = 0; ;) {
+      unsigned char index = stack[stackpos];
+
+      int lastcount = lists[index][1]->count;  /* Count of last chain of list. */
+
+      Node* newchain = pool++;
+      Node* oldchain = lists[index][1];
+      size_t sum;
+
+      /* These are set up before the recursive calls below, so that there is a list
+      pointing to the new node, to let the garbage collection know it's in use. */
+      lists[index][0] = oldchain;
+      lists[index][1] = newchain;
+
+      sum = lists[index - 1][0]->weight + lists[index - 1][1]->weight;
+
+      if (lastcount < numsymbols && sum > leaves[lastcount].weight) {
+        /* New leaf inserted in list, so count is incremented. */
+        InitNode(leaves[lastcount].weight, lastcount + 1, oldchain->tail, newchain);
+      } else {
+        InitNode(sum, lastcount, lists[index - 1][1], newchain);
+        /* Two lookahead chains of previous list used up, create new ones. */
+        if (index == 1) {
+          if (lists[0][1]->count < numsymbols) {
+            lastcount = lists[0][1]->count;
+            lists[0][0] = lists[0][1];
+            lists[0][1] = pool++;
+            InitNode(leaves[lastcount].weight, lastcount + 1, 0, lists[0][1]);
+            lastcount++;
+            if(lastcount < numsymbols){
+              lists[0][0] = lists[0][1];
+              lists[0][1] = pool++;
+              InitNode(leaves[lastcount].weight, lastcount + 1, 0, lists[0][1]);
+            }
+          }
+        }
+        else {
+          stack[stackpos++] = index - 1;
+          stack[stackpos++] = index - 1;
+        }
+      }
+      if (!stackpos--) {
+        break;
+      }
+    }
   }
-  BoundaryPMFinal(lists, leaves, numsymbols, &pool, maxbits - 1);
+  BoundaryPMFinal(lists, leaves, numsymbols, pool, maxbits - 1);
 
   ExtractBitLengths(lists[maxbits - 1][1], leaves, bitlengths);
 
diff --git a/zopfli/lz77.c b/zopfli/lz77.c
index 9df899d..e283c3d 100644
--- a/zopfli/lz77.c
+++ b/zopfli/lz77.c
@@ -270,21 +270,6 @@ static int GetLengthScore(int length, int distance) {
   return distance > 1024 ? length - 1 : length;
 }
 
-void ZopfliVerifyLenDist(const unsigned char* data, size_t datasize, size_t pos,
-                         unsigned short dist, unsigned short length) {
-
-  /* TODO(lode): make this only run in a debug compile, it's for assert only. */
-  size_t i;
-
-  assert(pos + length <= datasize);
-  for (i = 0; i < length; i++) {
-    if (data[pos - dist + i] != data[pos + i]) {
-      assert(data[pos - dist + i] == data[pos + i]);
-      break;
-    }
-  }
-}
-
 /*
 Finds how long the match of scan and match is. Can be used to find how many
 bytes starting from scan, and from match, are equal. Returns the last byte
@@ -594,7 +579,6 @@ void ZopfliLZ77Greedy(ZopfliBlockState* s, const unsigned char* in,
         dist = prev_match;
         lengthscore = prevlengthscore;
         /* Add to output. */
-        ZopfliVerifyLenDist(in, inend, i - 1, dist, leng);
         ZopfliStoreLitLenDist(leng, dist, i - 1, store);
         for (j = 2; j < leng; j++) {
           assert(i < inend);
@@ -615,7 +599,6 @@ void ZopfliLZ77Greedy(ZopfliBlockState* s, const unsigned char* in,
 
     /* Add to output. */
     if (lengthscore >= ZOPFLI_MIN_MATCH) {
-      ZopfliVerifyLenDist(in, inend, i, dist, leng);
       ZopfliStoreLitLenDist(leng, dist, i, store);
     } else {
       leng = 1;
diff --git a/zopfli/lz77.h b/zopfli/lz77.h
index dc8597a..8975bb5 100644
--- a/zopfli/lz77.h
+++ b/zopfli/lz77.h
@@ -122,12 +122,6 @@ void ZopfliFindLongestMatch(
     size_t pos, size_t size, size_t limit,
     unsigned short* sublen, unsigned short* distance, unsigned short* length);
 
-/*
-Verifies if length and dist are indeed valid, only used for assertion.
-*/
-void ZopfliVerifyLenDist(const unsigned char* data, size_t datasize, size_t pos,
-                         unsigned short dist, unsigned short length);
-
 /*
 Does LZ77 using an algorithm similar to gzip, with lazy matching, rather than
 with the slow but better "squeeze" implementation.
diff --git a/zopfli/squeeze.c b/zopfli/squeeze.c
index a695c18..dc429d0 100644
--- a/zopfli/squeeze.c
+++ b/zopfli/squeeze.c
@@ -23,26 +23,13 @@ Author: jyrki.alakuijala@gmail.com (Jyrki Alakuijala)
 #include <math.h>
 #include <stdio.h>
 
+#include "../rust.h"
 #include "blocksplitter.h"
 #include "deflate.h"
 #include "symbols.h"
-#include "tree.h"
 #include "util.h"
 
-typedef struct SymbolStats {
-  /* The literal and length symbols. */
-  size_t litlens[ZOPFLI_NUM_LL];
-  /* The 32 unique dist symbols, not the 32768 possible dists. */
-  size_t dists[ZOPFLI_NUM_D];
-
-  /* Length of each lit/len symbol in bits. */
-  double ll_symbols[ZOPFLI_NUM_LL];
-  /* Length of each dist symbol in bits. */
-  double d_symbols[ZOPFLI_NUM_D];
-} SymbolStats;
-
-/* Sets everything to 0. */
-static void InitStats(SymbolStats* stats) {
+void InitStats(SymbolStats* stats) {
   memset(stats->litlens, 0, ZOPFLI_NUM_LL * sizeof(stats->litlens[0]));
   memset(stats->dists, 0, ZOPFLI_NUM_D * sizeof(stats->dists[0]));
 
@@ -112,36 +99,8 @@ static void ClearStatFreqs(SymbolStats* stats) {
   for (i = 0; i < ZOPFLI_NUM_D; i++) stats->dists[i] = 0;
 }
 
-/*
-Function that calculates a cost based on a model for the given LZ77 symbol.
-litlen: means literal symbol if dist is 0, length otherwise.
-*/
-typedef double CostModelFun(unsigned litlen, unsigned dist, void* context);
-
-/*
-Cost model which should exactly match fixed tree.
-type: CostModelFun
-*/
-static double GetCostFixed(unsigned litlen, unsigned dist, void* unused) {
-  (void)unused;
-  if (dist == 0) {
-    if (litlen <= 143) return 8;
-    else return 9;
-  } else {
-    int dbits = ZopfliGetDistExtraBits(dist);
-    int lbits = ZopfliGetLengthExtraBits(litlen);
-    int lsym = ZopfliGetLengthSymbol(litlen);
-    int cost = 0;
-    if (lsym <= 279) cost += 7;
-    else cost += 8;
-    cost += 5;  /* Every dist symbol has length 5. */
-    return cost + dbits + lbits;
-  }
-}
-
 /*
 Cost model based on symbol statistics.
-type: CostModelFun
 */
 static double GetCostStat(unsigned litlen, unsigned dist, void* context) {
   SymbolStats* stats = (SymbolStats*)context;
@@ -160,7 +119,7 @@ static double GetCostStat(unsigned litlen, unsigned dist, void* context) {
 Finds the minimum possible cost this cost model can return for valid length and
 distance symbols.
 */
-static double GetCostModelMinCost(CostModelFun* costmodel, void* costcontext) {
+static double GetCostModelMinCost(void* costcontext) {
   double mincost;
   int bestlength = 0; /* length that has lowest cost in the cost model */
   int bestdist = 0; /* distance that has lowest cost in the cost model */
@@ -178,7 +137,7 @@ static double GetCostModelMinCost(CostModelFun* costmodel, void* costcontext) {
 
   mincost = ZOPFLI_LARGE_FLOAT;
   for (i = 3; i < 259; i++) {
-    double c = costmodel(i, 1, costcontext);
+    double c = GetCostStat(i, 1, costcontext);
     if (c < mincost) {
       bestlength = i;
       mincost = c;
@@ -187,14 +146,14 @@ static double GetCostModelMinCost(CostModelFun* costmodel, void* costcontext) {
 
   mincost = ZOPFLI_LARGE_FLOAT;
   for (i = 0; i < 30; i++) {
-    double c = costmodel(3, dsymbols[i], costcontext);
+    double c = GetCostStat(3, dsymbols[i], costcontext);
     if (c < mincost) {
       bestdist = dsymbols[i];
       mincost = c;
     }
   }
 
-  return costmodel(bestlength, bestdist, costcontext);
+  return GetCostStat(bestlength, bestdist, costcontext);
 }
 
 static size_t zopfli_min(size_t a, size_t b) {
@@ -208,8 +167,7 @@ s: the ZopfliBlockState
 in: the input data array
 instart: where to start
 inend: where to stop (not inclusive)
-costmodel: function to calculate the cost of some lit/len/dist pair.
-costcontext: abstract context for the costmodel function
+costcontext: abstract context for the costmodel
 length_array: output array of size (inend - instart) which will receive the best
     length to reach this byte from a previous byte.
 returns the cost that was, according to the costmodel, needed to get to the end.
@@ -217,7 +175,7 @@ returns the cost that was, according to the costmodel, needed to get to the end.
 static double GetBestLengths(ZopfliBlockState *s,
                              const unsigned char* in,
                              size_t instart, size_t inend,
-                             CostModelFun* costmodel, void* costcontext,
+                             SymbolStats* costcontext,
                              unsigned short* length_array,
                              ZopfliHash* h, float* costs) {
   /* Best cost to get here so far. */
@@ -229,8 +187,33 @@ static double GetBestLengths(ZopfliBlockState *s,
   size_t windowstart = instart > ZOPFLI_WINDOW_SIZE
       ? instart - ZOPFLI_WINDOW_SIZE : 0;
   double result;
-  double mincost = GetCostModelMinCost(costmodel, costcontext);
+  double mincost = costcontext ? GetCostModelMinCost(costcontext) : 12;
   double mincostaddcostj;
+  double* literals; /*Cost of a literal*/
+  double litlentable[259]; /*Cost of the length bits of a match*/
+  double disttable[30]; /*Cost of the distance bits of a match*/
+  if(costcontext){
+    literals = costcontext->ll_symbols;
+    for (i = 3; i < 259; i++){
+      litlentable[i] = costcontext->ll_symbols[ZopfliGetLengthSymbol(i)] + ZopfliGetLengthExtraBits(i);
+    }
+    for (i = 0; i < 30; i++){
+      disttable[i] =  costcontext->d_symbols[i] + (i < 4 ? 0 : (i - 2) / 2);
+    }
+  }
+  else{
+    double litstack[256];
+    literals = litstack;
+    for (i = 0; i < 256; i++){
+      literals[i] = 8 + (i > 143);
+    }
+    for (i = 3; i < 259; i++){
+      litlentable[i] = 12 + (i > 114) + ZopfliGetLengthExtraBits(i);
+    }
+    for (i = 0; i < 30; i++){
+      disttable[i] =  i < 4 ? 0 : (i - 2) / 2;
+    }
+  }
 
   if (instart == inend) return 0;
 
@@ -256,7 +239,7 @@ static double GetBestLengths(ZopfliBlockState *s,
         && i + ZOPFLI_MAX_MATCH * 2 + 1 < inend
         && h->same[(i - ZOPFLI_MAX_MATCH) & ZOPFLI_WINDOW_MASK]
             > ZOPFLI_MAX_MATCH) {
-      double symbolcost = costmodel(ZOPFLI_MAX_MATCH, 1, costcontext);
+      double symbolcost = disttable[0] + litlentable[ZOPFLI_MAX_MATCH];
       /* Set the length to reach each one to ZOPFLI_MAX_MATCH, and the cost to
       the cost corresponding to that length. Doing this, we skip
       ZOPFLI_MAX_MATCH values to avoid calling ZopfliFindLongestMatch. */
@@ -275,7 +258,7 @@ static double GetBestLengths(ZopfliBlockState *s,
 
     /* Literal. */
     if (i + 1 <= inend) {
-      double newCost = costmodel(in[i], 0, costcontext) + costs[j];
+      double newCost = literals[in[i]] + costs[j];
       assert(newCost >= 0);
       if (newCost < costs[j + 1]) {
         costs[j + 1] = newCost;
@@ -288,11 +271,10 @@ static double GetBestLengths(ZopfliBlockState *s,
     for (k = 3; k <= kend; k++) {
       double newCost;
 
-      /* Calling the cost model is expensive, avoid this if we are already at
-      the minimum possible cost that it can return. */
-     if (costs[j + k] <= mincostaddcostj) continue;
-
-      newCost = costmodel(k, sublen[k], costcontext) + costs[j];
+      /* Calculating the cost is expensive, avoid this if we are already at
+      the minimum possible cost that it can be. */
+      if (costs[j + k] <= mincostaddcostj) continue;
+      newCost = disttable[ZopfliGetDistSymbol(sublen[k])] + litlentable[k] + costs[j];
       assert(newCost >= 0);
       if (newCost < costs[j + k]) {
         assert(k <= ZOPFLI_MAX_MATCH);
@@ -369,7 +351,6 @@ static void FollowPath(ZopfliBlockState* s,
       ZopfliFindLongestMatch(s, h, in, pos, inend, length, 0,
                              &dist, &dummy_length);
       assert(!(dummy_length != length && length > 2 && dummy_length > 2));
-      ZopfliVerifyLenDist(in, inend, pos, dist, length);
       ZopfliStoreLitLenDist(length, dist, pos, store);
       total_length_test += length;
     } else {
@@ -394,8 +375,7 @@ static void CalculateStatistics(SymbolStats* stats) {
   ZopfliCalculateEntropy(stats->dists, ZOPFLI_NUM_D, stats->d_symbols);
 }
 
-/* Appends the symbol statistics from the store. */
-static void GetStatistics(const ZopfliLZ77Store* store, SymbolStats* stats) {
+void GetStatistics(const ZopfliLZ77Store* store, SymbolStats* stats) {
   size_t i;
   for (i = 0; i < store->size; i++) {
     if (store->dists[i] == 0) {
@@ -420,8 +400,7 @@ inend: where to stop (not inclusive)
 path: pointer to dynamically allocated memory to store the path
 pathsize: pointer to the size of the dynamic path array
 length_array: array of size (inend - instart) used to store lengths
-costmodel: function to use as the cost model for this squeeze run
-costcontext: abstract context for the costmodel function
+costcontext: abstract context for the costmodel
 store: place to output the LZ77 data
 returns the cost that was, according to the costmodel, needed to get to the end.
     This is not the actual cost.
@@ -429,10 +408,10 @@ returns the cost that was, according to the costmodel, needed to get to the end.
 static double LZ77OptimalRun(ZopfliBlockState* s,
     const unsigned char* in, size_t instart, size_t inend,
     unsigned short** path, size_t* pathsize,
-    unsigned short* length_array, CostModelFun* costmodel,
+    unsigned short* length_array,
     void* costcontext, ZopfliLZ77Store* store,
     ZopfliHash* h, float* costs) {
-  double cost = GetBestLengths(s, in, instart, inend, costmodel,
+  double cost = GetBestLengths(s, in, instart, inend,
                 costcontext, length_array, h, costs);
   free(*path);
   *path = 0;
@@ -446,7 +425,7 @@ static double LZ77OptimalRun(ZopfliBlockState* s,
 void ZopfliLZ77Optimal(ZopfliBlockState *s,
                        const unsigned char* in, size_t instart, size_t inend,
                        int numiterations,
-                       ZopfliLZ77Store* store) {
+                       ZopfliLZ77Store* store, SymbolStats* instats) {
   /* Dist to get to here with smallest cost. */
   size_t blocksize = inend - instart;
   unsigned short* length_array =
@@ -478,8 +457,13 @@ void ZopfliLZ77Optimal(ZopfliBlockState *s,
   the statistics of the previous run. */
 
   /* Initial run. */
-  ZopfliLZ77Greedy(s, in, instart, inend, &currentstore, h);
-  GetStatistics(&currentstore, &stats);
+  if(!instats){
+    ZopfliLZ77Greedy(s, in, instart, inend, &currentstore, h);
+    GetStatistics(&currentstore, &stats);
+  }
+  else{
+    CopyStats(instats, &stats);
+  }
 
   /* Repeat statistics with each time the cost model from the previous stat
   run. */
@@ -487,12 +471,9 @@ void ZopfliLZ77Optimal(ZopfliBlockState *s,
     ZopfliCleanLZ77Store(&currentstore);
     ZopfliInitLZ77Store(in, &currentstore);
     LZ77OptimalRun(s, in, instart, inend, &path, &pathsize,
-                   length_array, GetCostStat, (void*)&stats,
+                   length_array, (void*)&stats,
                    &currentstore, h, costs);
     cost = ZopfliCalculateBlockSize(&currentstore, 0, currentstore.size, 2);
-    if (s->options->verbose_more || (s->options->verbose && cost < bestcost)) {
-      fprintf(stderr, "Iteration %d: %d bit\n", i, (int) cost);
-    }
     if (cost < bestcost) {
       /* Copy to the output store. */
       ZopfliCopyLZ77Store(&currentstore, store);
@@ -551,7 +532,7 @@ void ZopfliLZ77OptimalFixed(ZopfliBlockState *s,
   /* Shortest path for fixed tree This one should give the shortest possible
   result for fixed tree, no repeated runs are needed since the tree is known. */
   LZ77OptimalRun(s, in, instart, inend, &path, &pathsize,
-                 length_array, GetCostFixed, 0, store, h, costs);
+                 length_array, 0, store, h, costs);
 
   free(length_array);
   free(path);
diff --git a/zopfli/squeeze.h b/zopfli/squeeze.h
index 48bb775..68db437 100644
--- a/zopfli/squeeze.h
+++ b/zopfli/squeeze.h
@@ -33,6 +33,24 @@ solution.
 
 #include "lz77.h"
 
+typedef struct SymbolStats {
+  /* The literal and length symbols. */
+  size_t litlens[ZOPFLI_NUM_LL];
+  /* The 32 unique dist symbols, not the 32768 possible dists. */
+  size_t dists[ZOPFLI_NUM_D];
+
+  /* Length of each lit/len symbol in bits. */
+  double ll_symbols[ZOPFLI_NUM_LL];
+  /* Length of each dist symbol in bits. */
+  double d_symbols[ZOPFLI_NUM_D];
+} SymbolStats;
+
+/* Sets everything to 0. */
+void InitStats(SymbolStats* stats);
+
+/* Appends the symbol statistics from the store. */
+void GetStatistics(const ZopfliLZ77Store* store, SymbolStats* stats);
+
 /*
 Calculates lit/len and dist pairs for given data.
 If instart is larger than 0, it uses values before instart as starting
@@ -41,7 +59,7 @@ dictionary.
 void ZopfliLZ77Optimal(ZopfliBlockState *s,
                        const unsigned char* in, size_t instart, size_t inend,
                        int numiterations,
-                       ZopfliLZ77Store* store);
+                       ZopfliLZ77Store* store, SymbolStats* instats);
 
 /*
 Does the same as ZopfliLZ77Optimal, but optimized for the fixed tree of the
diff --git a/zopfli/tree.c b/zopfli/tree.c
deleted file mode 100644
index c457511..0000000
--- a/zopfli/tree.c
+++ /dev/null
@@ -1,101 +0,0 @@
-/*
-Copyright 2011 Google Inc. All Rights Reserved.
-
-Licensed under the Apache License, Version 2.0 (the "License");
-you may not use this file except in compliance with the License.
-You may obtain a copy of the License at
-
-    http://www.apache.org/licenses/LICENSE-2.0
-
-Unless required by applicable law or agreed to in writing, software
-distributed under the License is distributed on an "AS IS" BASIS,
-WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
-See the License for the specific language governing permissions and
-limitations under the License.
-
-Author: lode.vandevenne@gmail.com (Lode Vandevenne)
-Author: jyrki.alakuijala@gmail.com (Jyrki Alakuijala)
-*/
-
-#include "tree.h"
-
-#include <assert.h>
-#include <math.h>
-#include <stdio.h>
-#include <stdlib.h>
-
-#include "katajainen.h"
-#include "util.h"
-
-void ZopfliLengthsToSymbols(const unsigned* lengths, size_t n, unsigned maxbits,
-                            unsigned* symbols) {
-  size_t* bl_count = (size_t*)malloc(sizeof(size_t) * (maxbits + 1));
-  size_t* next_code = (size_t*)malloc(sizeof(size_t) * (maxbits + 1));
-  unsigned bits, i;
-  unsigned code;
-
-  for (i = 0; i < n; i++) {
-    symbols[i] = 0;
-  }
-
-  /* 1) Count the number of codes for each code length. Let bl_count[N] be the
-  number of codes of length N, N >= 1. */
-  for (bits = 0; bits <= maxbits; bits++) {
-    bl_count[bits] = 0;
-  }
-  for (i = 0; i < n; i++) {
-    assert(lengths[i] <= maxbits);
-    bl_count[lengths[i]]++;
-  }
-  /* 2) Find the numerical value of the smallest code for each code length. */
-  code = 0;
-  bl_count[0] = 0;
-  for (bits = 1; bits <= maxbits; bits++) {
-    code = (code + bl_count[bits-1]) << 1;
-    next_code[bits] = code;
-  }
-  /* 3) Assign numerical values to all codes, using consecutive values for all
-  codes of the same length with the base values determined at step 2. */
-  for (i = 0;  i < n; i++) {
-    unsigned len = lengths[i];
-    if (len != 0) {
-      symbols[i] = next_code[len];
-      next_code[len]++;
-    }
-  }
-
-  free(bl_count);
-  free(next_code);
-}
-
-void ZopfliCalculateEntropy(const size_t* count, size_t n, double* bitlengths) {
-  static const double kInvLog2 = 1.4426950408889;  /* 1.0 / log(2.0) */
-  unsigned sum = 0;
-  unsigned i;
-  double log2sum;
-  for (i = 0; i < n; ++i) {
-    sum += count[i];
-  }
-  log2sum = (sum == 0 ? log(n) : log(sum)) * kInvLog2;
-  for (i = 0; i < n; ++i) {
-    /* When the count of the symbol is 0, but its cost is requested anyway, it
-    means the symbol will appear at least once anyway, so give it the cost as if
-    its count is 1.*/
-    if (count[i] == 0) bitlengths[i] = log2sum;
-    else bitlengths[i] = log2sum - log(count[i]) * kInvLog2;
-    /* Depending on compiler and architecture, the above subtraction of two
-    floating point numbers may give a negative result very close to zero
-    instead of zero (e.g. -5.973954e-17 with gcc 4.1.2 on Ubuntu 11.4). Clamp
-    it to zero. These floating point imprecisions do not affect the cost model
-    significantly so this is ok. */
-    if (bitlengths[i] < 0 && bitlengths[i] > -1e-5) bitlengths[i] = 0;
-    assert(bitlengths[i] >= 0);
-  }
-}
-
-void ZopfliCalculateBitLengths(const size_t* count, size_t n, int maxbits,
-                               unsigned* bitlengths) {
-  int error = ZopfliLengthLimitedCodeLengths(count, n, maxbits, bitlengths);
-  (void) error;
-  assert(!error);
-}
diff --git a/zopfli/tree.h b/zopfli/tree.h
deleted file mode 100644
index 4d6f469..0000000
--- a/zopfli/tree.h
+++ /dev/null
@@ -1,51 +0,0 @@
-/*
-Copyright 2011 Google Inc. All Rights Reserved.
-
-Licensed under the Apache License, Version 2.0 (the "License");
-you may not use this file except in compliance with the License.
-You may obtain a copy of the License at
-
-    http://www.apache.org/licenses/LICENSE-2.0
-
-Unless required by applicable law or agreed to in writing, software
-distributed under the License is distributed on an "AS IS" BASIS,
-WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
-See the License for the specific language governing permissions and
-limitations under the License.
-
-Author: lode.vandevenne@gmail.com (Lode Vandevenne)
-Author: jyrki.alakuijala@gmail.com (Jyrki Alakuijala)
-*/
-
-/*
-Utilities for creating and using Huffman trees.
-*/
-
-#ifndef ZOPFLI_TREE_H_
-#define ZOPFLI_TREE_H_
-
-#include <string.h>
-
-/*
-Calculates the bitlengths for the Huffman tree, based on the counts of each
-symbol.
-*/
-void ZopfliCalculateBitLengths(const size_t* count, size_t n, int maxbits,
-                               unsigned *bitlengths);
-
-/*
-Converts a series of Huffman tree bitlengths, to the bit values of the symbols.
-*/
-void ZopfliLengthsToSymbols(const unsigned* lengths, size_t n, unsigned maxbits,
-                            unsigned* symbols);
-
-/*
-Calculates the entropy of each symbol, based on the counts of each symbol. The
-result is similar to the result of ZopfliCalculateBitLengths, but with the
-actual theoritical bit lengths according to the entropy. Since the resulting
-values are fractional, they cannot be used to encode the tree specified by
-DEFLATE.
-*/
-void ZopfliCalculateEntropy(const size_t* count, size_t n, double* bitlengths);
-
-#endif  /* ZOPFLI_TREE_H_ */
diff --git a/zopfli/zlib_container.c b/zopfli/zlib_container.c
index 130ffc7..4ccac0d 100644
--- a/zopfli/zlib_container.c
+++ b/zopfli/zlib_container.c
@@ -69,11 +69,4 @@ void ZopfliZlibCompress(const ZopfliOptions* options,
   ZOPFLI_APPEND_DATA((checksum >> 16) % 256, out, outsize);
   ZOPFLI_APPEND_DATA((checksum >> 8) % 256, out, outsize);
   ZOPFLI_APPEND_DATA(checksum % 256, out, outsize);
-
-  if (options->verbose) {
-    fprintf(stderr,
-            "Original Size: %d, Zlib: %d, Compression: %f%% Removed\n",
-            (int)insize, (int)*outsize,
-            100.0 * (double)(insize - *outsize) / (double)insize);
-  }
 }
