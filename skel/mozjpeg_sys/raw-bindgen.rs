/* automatically generated by rust-bindgen 0.54.1 */

#[repr(C)]
pub struct __BindgenUnionField<T>(::core::marker::PhantomData<T>);
impl<T> __BindgenUnionField<T> {
	#[inline]
	pub const fn new() -> Self {
		__BindgenUnionField(::core::marker::PhantomData)
	}
	#[inline]
	pub unsafe fn as_ref(&self) -> &T {
		::core::mem::transmute(self)
	}
	#[inline]
	pub unsafe fn as_mut(&mut self) -> &mut T {
		::core::mem::transmute(self)
	}
}
impl<T> ::core::default::Default for __BindgenUnionField<T> {
	#[inline]
	fn default() -> Self {
		Self::new()
	}
}
impl<T> ::core::clone::Clone for __BindgenUnionField<T> {
	#[inline]
	fn clone(&self) -> Self {
		Self::new()
	}
}
impl<T> ::core::marker::Copy for __BindgenUnionField<T> {}
impl<T> ::core::fmt::Debug for __BindgenUnionField<T> {
	fn fmt(&self, fmt: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
		fmt.write_str("__BindgenUnionField")
	}
}
impl<T> ::core::hash::Hash for __BindgenUnionField<T> {
	fn hash<H: ::core::hash::Hasher>(&self, _state: &mut H) {}
}
impl<T> ::core::cmp::PartialEq for __BindgenUnionField<T> {
	fn eq(&self, _other: &__BindgenUnionField<T>) -> bool {
		true
	}
}
impl<T> ::core::cmp::Eq for __BindgenUnionField<T> {}
pub const JPEG_LIB_VERSION: u32 = 62;
pub const LIBJPEG_TURBO_VERSION_NUMBER: u32 = 4000000;
pub const MEM_SRCDST_SUPPORTED: u32 = 1;
pub const WITH_SIMD: u32 = 1;
pub const BITS_IN_JSAMPLE: u32 = 8;
pub const HAVE_LOCALE_H: u32 = 1;
pub const HAVE_STDDEF_H: u32 = 1;
pub const HAVE_STDLIB_H: u32 = 1;
pub const NEED_SYS_TYPES_H: u32 = 1;
pub const HAVE_UNSIGNED_CHAR: u32 = 1;
pub const HAVE_UNSIGNED_SHORT: u32 = 1;
pub const _FEATURES_H: u32 = 1;
pub const _DEFAULT_SOURCE: u32 = 1;
pub const __USE_ISOC11: u32 = 1;
pub const __USE_ISOC99: u32 = 1;
pub const __USE_ISOC95: u32 = 1;
pub const __USE_POSIX_IMPLICITLY: u32 = 1;
pub const _POSIX_SOURCE: u32 = 1;
pub const _POSIX_C_SOURCE: u32 = 200809;
pub const __USE_POSIX: u32 = 1;
pub const __USE_POSIX2: u32 = 1;
pub const __USE_POSIX199309: u32 = 1;
pub const __USE_POSIX199506: u32 = 1;
pub const __USE_XOPEN2K: u32 = 1;
pub const __USE_XOPEN2K8: u32 = 1;
pub const _ATFILE_SOURCE: u32 = 1;
pub const __USE_MISC: u32 = 1;
pub const __USE_ATFILE: u32 = 1;
pub const __USE_FORTIFY_LEVEL: u32 = 0;
pub const __GLIBC_USE_DEPRECATED_GETS: u32 = 0;
pub const _STDC_PREDEF_H: u32 = 1;
pub const __STDC_IEC_559__: u32 = 1;
pub const __STDC_IEC_559_COMPLEX__: u32 = 1;
pub const __STDC_ISO_10646__: u32 = 201706;
pub const __GNU_LIBRARY__: u32 = 6;
pub const __GLIBC__: u32 = 2;
pub const __GLIBC_MINOR__: u32 = 28;
pub const _SYS_CDEFS_H: u32 = 1;
pub const __glibc_c99_flexarr_available: u32 = 1;
pub const __WORDSIZE: u32 = 64;
pub const __WORDSIZE_TIME64_COMPAT32: u32 = 1;
pub const __SYSCALL_WORDSIZE: u32 = 64;
pub const __HAVE_GENERIC_SELECTION: u32 = 1;
pub const __GLIBC_USE_LIB_EXT2: u32 = 0;
pub const __GLIBC_USE_IEC_60559_BFP_EXT: u32 = 0;
pub const __GLIBC_USE_IEC_60559_FUNCS_EXT: u32 = 0;
pub const __GLIBC_USE_IEC_60559_TYPES_EXT: u32 = 0;
pub const _STDLIB_H: u32 = 1;
pub const WNOHANG: u32 = 1;
pub const WUNTRACED: u32 = 2;
pub const WSTOPPED: u32 = 2;
pub const WEXITED: u32 = 4;
pub const WCONTINUED: u32 = 8;
pub const WNOWAIT: u32 = 16777216;
pub const __WNOTHREAD: u32 = 536870912;
pub const __WALL: u32 = 1073741824;
pub const __WCLONE: u32 = 2147483648;
pub const __ENUM_IDTYPE_T: u32 = 1;
pub const __W_CONTINUED: u32 = 65535;
pub const __WCOREFLAG: u32 = 128;
pub const __HAVE_FLOAT128: u32 = 0;
pub const __HAVE_DISTINCT_FLOAT128: u32 = 0;
pub const __HAVE_FLOAT64X: u32 = 1;
pub const __HAVE_FLOAT64X_LONG_DOUBLE: u32 = 1;
pub const __HAVE_FLOAT16: u32 = 0;
pub const __HAVE_FLOAT32: u32 = 1;
pub const __HAVE_FLOAT64: u32 = 1;
pub const __HAVE_FLOAT32X: u32 = 1;
pub const __HAVE_FLOAT128X: u32 = 0;
pub const __HAVE_DISTINCT_FLOAT16: u32 = 0;
pub const __HAVE_DISTINCT_FLOAT32: u32 = 0;
pub const __HAVE_DISTINCT_FLOAT64: u32 = 0;
pub const __HAVE_DISTINCT_FLOAT32X: u32 = 0;
pub const __HAVE_DISTINCT_FLOAT64X: u32 = 0;
pub const __HAVE_DISTINCT_FLOAT128X: u32 = 0;
pub const __HAVE_FLOATN_NOT_TYPEDEF: u32 = 0;
pub const __ldiv_t_defined: u32 = 1;
pub const __lldiv_t_defined: u32 = 1;
pub const RAND_MAX: u32 = 2147483647;
pub const EXIT_FAILURE: u32 = 1;
pub const EXIT_SUCCESS: u32 = 0;
pub const _SYS_TYPES_H: u32 = 1;
pub const _BITS_TYPES_H: u32 = 1;
pub const _BITS_TYPESIZES_H: u32 = 1;
pub const __OFF_T_MATCHES_OFF64_T: u32 = 1;
pub const __INO_T_MATCHES_INO64_T: u32 = 1;
pub const __RLIM_T_MATCHES_RLIM64_T: u32 = 1;
pub const __FD_SETSIZE: u32 = 1024;
pub const __clock_t_defined: u32 = 1;
pub const __clockid_t_defined: u32 = 1;
pub const __time_t_defined: u32 = 1;
pub const __timer_t_defined: u32 = 1;
pub const _BITS_STDINT_INTN_H: u32 = 1;
pub const __BIT_TYPES_DEFINED__: u32 = 1;
pub const _ENDIAN_H: u32 = 1;
pub const __LITTLE_ENDIAN: u32 = 1234;
pub const __BIG_ENDIAN: u32 = 4321;
pub const __PDP_ENDIAN: u32 = 3412;
pub const __BYTE_ORDER: u32 = 1234;
pub const __FLOAT_WORD_ORDER: u32 = 1234;
pub const LITTLE_ENDIAN: u32 = 1234;
pub const BIG_ENDIAN: u32 = 4321;
pub const PDP_ENDIAN: u32 = 3412;
pub const BYTE_ORDER: u32 = 1234;
pub const _BITS_BYTESWAP_H: u32 = 1;
pub const _BITS_UINTN_IDENTITY_H: u32 = 1;
pub const _SYS_SELECT_H: u32 = 1;
pub const __FD_ZERO_STOS: &'static [u8; 6usize] = b"stosq\0";
pub const __sigset_t_defined: u32 = 1;
pub const __timeval_defined: u32 = 1;
pub const _STRUCT_TIMESPEC: u32 = 1;
pub const FD_SETSIZE: u32 = 1024;
pub const _BITS_PTHREADTYPES_COMMON_H: u32 = 1;
pub const _THREAD_SHARED_TYPES_H: u32 = 1;
pub const _BITS_PTHREADTYPES_ARCH_H: u32 = 1;
pub const __SIZEOF_PTHREAD_MUTEX_T: u32 = 40;
pub const __SIZEOF_PTHREAD_ATTR_T: u32 = 56;
pub const __SIZEOF_PTHREAD_RWLOCK_T: u32 = 56;
pub const __SIZEOF_PTHREAD_BARRIER_T: u32 = 32;
pub const __SIZEOF_PTHREAD_MUTEXATTR_T: u32 = 4;
pub const __SIZEOF_PTHREAD_COND_T: u32 = 48;
pub const __SIZEOF_PTHREAD_CONDATTR_T: u32 = 4;
pub const __SIZEOF_PTHREAD_RWLOCKATTR_T: u32 = 8;
pub const __SIZEOF_PTHREAD_BARRIERATTR_T: u32 = 4;
pub const __PTHREAD_MUTEX_LOCK_ELISION: u32 = 1;
pub const __PTHREAD_MUTEX_NUSERS_AFTER_KIND: u32 = 0;
pub const __PTHREAD_MUTEX_USE_UNION: u32 = 0;
pub const __PTHREAD_RWLOCK_INT_FLAGS_SHARED: u32 = 1;
pub const __PTHREAD_MUTEX_HAVE_PREV: u32 = 1;
pub const __have_pthread_attr_t: u32 = 1;
pub const _ALLOCA_H: u32 = 1;
pub const _STDIO_H: u32 = 1;
pub const __GNUC_VA_LIST: u32 = 1;
pub const _____fpos_t_defined: u32 = 1;
pub const ____mbstate_t_defined: u32 = 1;
pub const _____fpos64_t_defined: u32 = 1;
pub const ____FILE_defined: u32 = 1;
pub const __FILE_defined: u32 = 1;
pub const __struct_FILE_defined: u32 = 1;
pub const _IO_EOF_SEEN: u32 = 16;
pub const _IO_ERR_SEEN: u32 = 32;
pub const _IO_USER_LOCK: u32 = 32768;
pub const _IOFBF: u32 = 0;
pub const _IOLBF: u32 = 1;
pub const _IONBF: u32 = 2;
pub const BUFSIZ: u32 = 8192;
pub const EOF: i32 = -1;
pub const SEEK_SET: u32 = 0;
pub const SEEK_CUR: u32 = 1;
pub const SEEK_END: u32 = 2;
pub const P_tmpdir: &'static [u8; 5usize] = b"/tmp\0";
pub const _BITS_STDIO_LIM_H: u32 = 1;
pub const L_tmpnam: u32 = 20;
pub const TMP_MAX: u32 = 238328;
pub const FILENAME_MAX: u32 = 4096;
pub const L_ctermid: u32 = 9;
pub const FOPEN_MAX: u32 = 16;
pub const _STRING_H: u32 = 1;
pub const _BITS_TYPES_LOCALE_T_H: u32 = 1;
pub const _BITS_TYPES___LOCALE_T_H: u32 = 1;
pub const _STRINGS_H: u32 = 1;
pub const MAX_COMPONENTS: u32 = 10;
pub const MAXJSAMPLE: u32 = 255;
pub const CENTERJSAMPLE: u32 = 128;
pub const JPEG_MAX_DIMENSION: u32 = 65500;
pub const FALSE: u32 = 0;
pub const TRUE: u32 = 1;
pub const DCTSIZE: u32 = 8;
pub const DCTSIZE2: u32 = 64;
pub const NUM_QUANT_TBLS: u32 = 4;
pub const NUM_HUFF_TBLS: u32 = 4;
pub const NUM_ARITH_TBLS: u32 = 16;
pub const MAX_COMPS_IN_SCAN: u32 = 4;
pub const MAX_SAMP_FACTOR: u32 = 4;
pub const C_MAX_BLOCKS_IN_MCU: u32 = 10;
pub const D_MAX_BLOCKS_IN_MCU: u32 = 10;
pub const JCS_EXTENSIONS: u32 = 1;
pub const JCS_ALPHA_EXTENSIONS: u32 = 1;
pub const JMSG_LENGTH_MAX: u32 = 200;
pub const JMSG_STR_PARM_MAX: u32 = 80;
pub const JPOOL_PERMANENT: u32 = 0;
pub const JPOOL_IMAGE: u32 = 1;
pub const JPOOL_NUMPOOLS: u32 = 2;
pub const JPEG_SUSPENDED: u32 = 0;
pub const JPEG_HEADER_OK: u32 = 1;
pub const JPEG_HEADER_TABLES_ONLY: u32 = 2;
pub const JPEG_REACHED_SOS: u32 = 1;
pub const JPEG_REACHED_EOI: u32 = 2;
pub const JPEG_ROW_COMPLETED: u32 = 3;
pub const JPEG_SCAN_COMPLETED: u32 = 4;
pub const JPEG_C_PARAM_SUPPORTED: u32 = 1;
pub const JPEG_RST0: u32 = 208;
pub const JPEG_EOI: u32 = 217;
pub const JPEG_APP0: u32 = 224;
pub const JPEG_COM: u32 = 254;
pub const TJ_NUMSAMP: u32 = 6;
pub const TJ_NUMPF: u32 = 12;
pub const TJ_NUMCS: u32 = 5;
pub const TJFLAG_BOTTOMUP: u32 = 2;
pub const TJFLAG_FASTUPSAMPLE: u32 = 256;
pub const TJFLAG_NOREALLOC: u32 = 1024;
pub const TJFLAG_FASTDCT: u32 = 2048;
pub const TJFLAG_ACCURATEDCT: u32 = 4096;
pub const TJFLAG_STOPONWARNING: u32 = 8192;
pub const TJFLAG_PROGRESSIVE: u32 = 16384;
pub const TJ_NUMERR: u32 = 2;
pub const TJ_NUMXOP: u32 = 8;
pub const TJXOPT_PERFECT: u32 = 1;
pub const TJXOPT_TRIM: u32 = 2;
pub const TJXOPT_CROP: u32 = 4;
pub const TJXOPT_GRAY: u32 = 8;
pub const TJXOPT_NOOUTPUT: u32 = 16;
pub const TJXOPT_PROGRESSIVE: u32 = 32;
pub const TJXOPT_COPYNONE: u32 = 64;
pub const TJFLAG_FORCEMMX: u32 = 8;
pub const TJFLAG_FORCESSE: u32 = 16;
pub const TJFLAG_FORCESSE2: u32 = 32;
pub const TJFLAG_FORCESSE3: u32 = 128;
pub const NUMSUBOPT: u32 = 6;
pub const TJ_BGR: u32 = 1;
pub const TJ_BOTTOMUP: u32 = 2;
pub const TJ_FORCEMMX: u32 = 8;
pub const TJ_FORCESSE: u32 = 16;
pub const TJ_FORCESSE2: u32 = 32;
pub const TJ_ALPHAFIRST: u32 = 64;
pub const TJ_FORCESSE3: u32 = 128;
pub const TJ_FASTUPSAMPLE: u32 = 256;
pub const TJ_YUV: u32 = 512;
pub const TRANSFORMS_SUPPORTED: u32 = 1;
pub type size_t = ::std::os::raw::c_ulong;
pub type wchar_t = ::std::os::raw::c_int;
#[repr(C)]
#[repr(align(16))]
pub struct max_align_t {
	pub __clang_max_align_nonce1: ::std::os::raw::c_longlong,
	pub __bindgen_padding_0: u64,
	pub __clang_max_align_nonce2: u128,
}
#[test]
fn bindgen_test_layout_max_align_t() {
	assert_eq!(
		::core::mem::size_of::<max_align_t>(),
		32usize,
		concat!("Size of: ", stringify!(max_align_t))
	);
	assert_eq!(
		::core::mem::align_of::<max_align_t>(),
		16usize,
		concat!("Alignment of ", stringify!(max_align_t))
	);
	assert_eq!(
		unsafe {
			&(*(::core::ptr::null::<max_align_t>())).__clang_max_align_nonce1 as *const _ as usize
		},
		0usize,
		concat!(
			"Offset of field: ",
			stringify!(max_align_t),
			"::",
			stringify!(__clang_max_align_nonce1)
		)
	);
	assert_eq!(
		unsafe {
			&(*(::core::ptr::null::<max_align_t>())).__clang_max_align_nonce2 as *const _ as usize
		},
		16usize,
		concat!(
			"Offset of field: ",
			stringify!(max_align_t),
			"::",
			stringify!(__clang_max_align_nonce2)
		)
	);
}
pub const idtype_t_P_ALL: idtype_t = 0;
pub const idtype_t_P_PID: idtype_t = 1;
pub const idtype_t_P_PGID: idtype_t = 2;
pub type idtype_t = u32;
pub type _Float32 = f32;
pub type _Float64 = f64;
pub type _Float32x = f64;
pub type _Float64x = u128;
#[repr(C)]
pub struct div_t {
	pub quot: ::std::os::raw::c_int,
	pub rem: ::std::os::raw::c_int,
}
#[test]
fn bindgen_test_layout_div_t() {
	assert_eq!(
		::core::mem::size_of::<div_t>(),
		8usize,
		concat!("Size of: ", stringify!(div_t))
	);
	assert_eq!(
		::core::mem::align_of::<div_t>(),
		4usize,
		concat!("Alignment of ", stringify!(div_t))
	);
	assert_eq!(
		unsafe { &(*(::core::ptr::null::<div_t>())).quot as *const _ as usize },
		0usize,
		concat!(
			"Offset of field: ",
			stringify!(div_t),
			"::",
			stringify!(quot)
		)
	);
	assert_eq!(
		unsafe { &(*(::core::ptr::null::<div_t>())).rem as *const _ as usize },
		4usize,
		concat!(
			"Offset of field: ",
			stringify!(div_t),
			"::",
			stringify!(rem)
		)
	);
}
#[repr(C)]
pub struct ldiv_t {
	pub quot: ::std::os::raw::c_long,
	pub rem: ::std::os::raw::c_long,
}
#[test]
fn bindgen_test_layout_ldiv_t() {
	assert_eq!(
		::core::mem::size_of::<ldiv_t>(),
		16usize,
		concat!("Size of: ", stringify!(ldiv_t))
	);
	assert_eq!(
		::core::mem::align_of::<ldiv_t>(),
		8usize,
		concat!("Alignment of ", stringify!(ldiv_t))
	);
	assert_eq!(
		unsafe { &(*(::core::ptr::null::<ldiv_t>())).quot as *const _ as usize },
		0usize,
		concat!(
			"Offset of field: ",
			stringify!(ldiv_t),
			"::",
			stringify!(quot)
		)
	);
	assert_eq!(
		unsafe { &(*(::core::ptr::null::<ldiv_t>())).rem as *const _ as usize },
		8usize,
		concat!(
			"Offset of field: ",
			stringify!(ldiv_t),
			"::",
			stringify!(rem)
		)
	);
}
#[repr(C)]
pub struct lldiv_t {
	pub quot: ::std::os::raw::c_longlong,
	pub rem: ::std::os::raw::c_longlong,
}
#[test]
fn bindgen_test_layout_lldiv_t() {
	assert_eq!(
		::core::mem::size_of::<lldiv_t>(),
		16usize,
		concat!("Size of: ", stringify!(lldiv_t))
	);
	assert_eq!(
		::core::mem::align_of::<lldiv_t>(),
		8usize,
		concat!("Alignment of ", stringify!(lldiv_t))
	);
	assert_eq!(
		unsafe { &(*(::core::ptr::null::<lldiv_t>())).quot as *const _ as usize },
		0usize,
		concat!(
			"Offset of field: ",
			stringify!(lldiv_t),
			"::",
			stringify!(quot)
		)
	);
	assert_eq!(
		unsafe { &(*(::core::ptr::null::<lldiv_t>())).rem as *const _ as usize },
		8usize,
		concat!(
			"Offset of field: ",
			stringify!(lldiv_t),
			"::",
			stringify!(rem)
		)
	);
}
extern "C" {
	pub fn __ctype_get_mb_cur_max() -> size_t;
}
extern "C" {
	pub fn atof(__nptr: *const ::std::os::raw::c_char) -> f64;
}
extern "C" {
	pub fn atoi(__nptr: *const ::std::os::raw::c_char) -> ::std::os::raw::c_int;
}
extern "C" {
	pub fn atol(__nptr: *const ::std::os::raw::c_char) -> ::std::os::raw::c_long;
}
extern "C" {
	pub fn atoll(__nptr: *const ::std::os::raw::c_char) -> ::std::os::raw::c_longlong;
}
extern "C" {
	pub fn strtod(
		__nptr: *const ::std::os::raw::c_char,
		__endptr: *mut *mut ::std::os::raw::c_char,
	) -> f64;
}
extern "C" {
	pub fn strtof(
		__nptr: *const ::std::os::raw::c_char,
		__endptr: *mut *mut ::std::os::raw::c_char,
	) -> f32;
}
extern "C" {
	pub fn strtold(
		__nptr: *const ::std::os::raw::c_char,
		__endptr: *mut *mut ::std::os::raw::c_char,
	) -> u128;
}
extern "C" {
	pub fn strtol(
		__nptr: *const ::std::os::raw::c_char,
		__endptr: *mut *mut ::std::os::raw::c_char,
		__base: ::std::os::raw::c_int,
	) -> ::std::os::raw::c_long;
}
extern "C" {
	pub fn strtoul(
		__nptr: *const ::std::os::raw::c_char,
		__endptr: *mut *mut ::std::os::raw::c_char,
		__base: ::std::os::raw::c_int,
	) -> ::std::os::raw::c_ulong;
}
extern "C" {
	pub fn strtoq(
		__nptr: *const ::std::os::raw::c_char,
		__endptr: *mut *mut ::std::os::raw::c_char,
		__base: ::std::os::raw::c_int,
	) -> ::std::os::raw::c_longlong;
}
extern "C" {
	pub fn strtouq(
		__nptr: *const ::std::os::raw::c_char,
		__endptr: *mut *mut ::std::os::raw::c_char,
		__base: ::std::os::raw::c_int,
	) -> ::std::os::raw::c_ulonglong;
}
extern "C" {
	pub fn strtoll(
		__nptr: *const ::std::os::raw::c_char,
		__endptr: *mut *mut ::std::os::raw::c_char,
		__base: ::std::os::raw::c_int,
	) -> ::std::os::raw::c_longlong;
}
extern "C" {
	pub fn strtoull(
		__nptr: *const ::std::os::raw::c_char,
		__endptr: *mut *mut ::std::os::raw::c_char,
		__base: ::std::os::raw::c_int,
	) -> ::std::os::raw::c_ulonglong;
}
extern "C" {
	pub fn l64a(__n: ::std::os::raw::c_long) -> *mut ::std::os::raw::c_char;
}
extern "C" {
	pub fn a64l(__s: *const ::std::os::raw::c_char) -> ::std::os::raw::c_long;
}
pub type __u_char = ::std::os::raw::c_uchar;
pub type __u_short = ::std::os::raw::c_ushort;
pub type __u_int = ::std::os::raw::c_uint;
pub type __u_long = ::std::os::raw::c_ulong;
pub type __int8_t = ::std::os::raw::c_schar;
pub type __uint8_t = ::std::os::raw::c_uchar;
pub type __int16_t = ::std::os::raw::c_short;
pub type __uint16_t = ::std::os::raw::c_ushort;
pub type __int32_t = ::std::os::raw::c_int;
pub type __uint32_t = ::std::os::raw::c_uint;
pub type __int64_t = ::std::os::raw::c_long;
pub type __uint64_t = ::std::os::raw::c_ulong;
pub type __int_least8_t = __int8_t;
pub type __uint_least8_t = __uint8_t;
pub type __int_least16_t = __int16_t;
pub type __uint_least16_t = __uint16_t;
pub type __int_least32_t = __int32_t;
pub type __uint_least32_t = __uint32_t;
pub type __int_least64_t = __int64_t;
pub type __uint_least64_t = __uint64_t;
pub type __quad_t = ::std::os::raw::c_long;
pub type __u_quad_t = ::std::os::raw::c_ulong;
pub type __intmax_t = ::std::os::raw::c_long;
pub type __uintmax_t = ::std::os::raw::c_ulong;
pub type __dev_t = ::std::os::raw::c_ulong;
pub type __uid_t = ::std::os::raw::c_uint;
pub type __gid_t = ::std::os::raw::c_uint;
pub type __ino_t = ::std::os::raw::c_ulong;
pub type __ino64_t = ::std::os::raw::c_ulong;
pub type __mode_t = ::std::os::raw::c_uint;
pub type __nlink_t = ::std::os::raw::c_ulong;
pub type __off_t = ::std::os::raw::c_long;
pub type __off64_t = ::std::os::raw::c_long;
pub type __pid_t = ::std::os::raw::c_int;
#[repr(C)]
pub struct __fsid_t {
	pub __val: [::std::os::raw::c_int; 2usize],
}
#[test]
fn bindgen_test_layout___fsid_t() {
	assert_eq!(
		::core::mem::size_of::<__fsid_t>(),
		8usize,
		concat!("Size of: ", stringify!(__fsid_t))
	);
	assert_eq!(
		::core::mem::align_of::<__fsid_t>(),
		4usize,
		concat!("Alignment of ", stringify!(__fsid_t))
	);
	assert_eq!(
		unsafe { &(*(::core::ptr::null::<__fsid_t>())).__val as *const _ as usize },
		0usize,
		concat!(
			"Offset of field: ",
			stringify!(__fsid_t),
			"::",
			stringify!(__val)
		)
	);
}
pub type __clock_t = ::std::os::raw::c_long;
pub type __rlim_t = ::std::os::raw::c_ulong;
pub type __rlim64_t = ::std::os::raw::c_ulong;
pub type __id_t = ::std::os::raw::c_uint;
pub type __time_t = ::std::os::raw::c_long;
pub type __useconds_t = ::std::os::raw::c_uint;
pub type __suseconds_t = ::std::os::raw::c_long;
pub type __daddr_t = ::std::os::raw::c_int;
pub type __key_t = ::std::os::raw::c_int;
pub type __clockid_t = ::std::os::raw::c_int;
pub type __timer_t = *mut ::core::ffi::c_void;
pub type __blksize_t = ::std::os::raw::c_long;
pub type __blkcnt_t = ::std::os::raw::c_long;
pub type __blkcnt64_t = ::std::os::raw::c_long;
pub type __fsblkcnt_t = ::std::os::raw::c_ulong;
pub type __fsblkcnt64_t = ::std::os::raw::c_ulong;
pub type __fsfilcnt_t = ::std::os::raw::c_ulong;
pub type __fsfilcnt64_t = ::std::os::raw::c_ulong;
pub type __fsword_t = ::std::os::raw::c_long;
pub type __ssize_t = ::std::os::raw::c_long;
pub type __syscall_slong_t = ::std::os::raw::c_long;
pub type __syscall_ulong_t = ::std::os::raw::c_ulong;
pub type __loff_t = __off64_t;
pub type __caddr_t = *mut ::std::os::raw::c_char;
pub type __intptr_t = ::std::os::raw::c_long;
pub type __socklen_t = ::std::os::raw::c_uint;
pub type __sig_atomic_t = ::std::os::raw::c_int;
pub type u_char = __u_char;
pub type u_short = __u_short;
pub type u_int = __u_int;
pub type u_long = __u_long;
pub type quad_t = __quad_t;
pub type u_quad_t = __u_quad_t;
pub type fsid_t = __fsid_t;
pub type loff_t = __loff_t;
pub type ino_t = __ino_t;
pub type dev_t = __dev_t;
pub type gid_t = __gid_t;
pub type mode_t = __mode_t;
pub type nlink_t = __nlink_t;
pub type uid_t = __uid_t;
pub type off_t = __off_t;
pub type pid_t = __pid_t;
pub type id_t = __id_t;
pub type ssize_t = __ssize_t;
pub type daddr_t = __daddr_t;
pub type caddr_t = __caddr_t;
pub type key_t = __key_t;
pub type clock_t = __clock_t;
pub type clockid_t = __clockid_t;
pub type time_t = __time_t;
pub type timer_t = __timer_t;
pub type ulong = ::std::os::raw::c_ulong;
pub type ushort = ::std::os::raw::c_ushort;
pub type uint = ::std::os::raw::c_uint;
pub type u_int8_t = ::std::os::raw::c_uchar;
pub type u_int16_t = ::std::os::raw::c_ushort;
pub type u_int32_t = ::std::os::raw::c_uint;
pub type u_int64_t = ::std::os::raw::c_ulong;
pub type register_t = ::std::os::raw::c_long;
#[repr(C)]
pub struct __sigset_t {
	pub __val: [::std::os::raw::c_ulong; 16usize],
}
#[test]
fn bindgen_test_layout___sigset_t() {
	assert_eq!(
		::core::mem::size_of::<__sigset_t>(),
		128usize,
		concat!("Size of: ", stringify!(__sigset_t))
	);
	assert_eq!(
		::core::mem::align_of::<__sigset_t>(),
		8usize,
		concat!("Alignment of ", stringify!(__sigset_t))
	);
	assert_eq!(
		unsafe { &(*(::core::ptr::null::<__sigset_t>())).__val as *const _ as usize },
		0usize,
		concat!(
			"Offset of field: ",
			stringify!(__sigset_t),
			"::",
			stringify!(__val)
		)
	);
}
pub type sigset_t = __sigset_t;
#[repr(C)]
pub struct timeval {
	pub tv_sec: __time_t,
	pub tv_usec: __suseconds_t,
}
#[test]
fn bindgen_test_layout_timeval() {
	assert_eq!(
		::core::mem::size_of::<timeval>(),
		16usize,
		concat!("Size of: ", stringify!(timeval))
	);
	assert_eq!(
		::core::mem::align_of::<timeval>(),
		8usize,
		concat!("Alignment of ", stringify!(timeval))
	);
	assert_eq!(
		unsafe { &(*(::core::ptr::null::<timeval>())).tv_sec as *const _ as usize },
		0usize,
		concat!(
			"Offset of field: ",
			stringify!(timeval),
			"::",
			stringify!(tv_sec)
		)
	);
	assert_eq!(
		unsafe { &(*(::core::ptr::null::<timeval>())).tv_usec as *const _ as usize },
		8usize,
		concat!(
			"Offset of field: ",
			stringify!(timeval),
			"::",
			stringify!(tv_usec)
		)
	);
}
#[repr(C)]
pub struct timespec {
	pub tv_sec: __time_t,
	pub tv_nsec: __syscall_slong_t,
}
#[test]
fn bindgen_test_layout_timespec() {
	assert_eq!(
		::core::mem::size_of::<timespec>(),
		16usize,
		concat!("Size of: ", stringify!(timespec))
	);
	assert_eq!(
		::core::mem::align_of::<timespec>(),
		8usize,
		concat!("Alignment of ", stringify!(timespec))
	);
	assert_eq!(
		unsafe { &(*(::core::ptr::null::<timespec>())).tv_sec as *const _ as usize },
		0usize,
		concat!(
			"Offset of field: ",
			stringify!(timespec),
			"::",
			stringify!(tv_sec)
		)
	);
	assert_eq!(
		unsafe { &(*(::core::ptr::null::<timespec>())).tv_nsec as *const _ as usize },
		8usize,
		concat!(
			"Offset of field: ",
			stringify!(timespec),
			"::",
			stringify!(tv_nsec)
		)
	);
}
pub type suseconds_t = __suseconds_t;
pub type __fd_mask = ::std::os::raw::c_long;
#[repr(C)]
pub struct fd_set {
	pub __fds_bits: [__fd_mask; 16usize],
}
#[test]
fn bindgen_test_layout_fd_set() {
	assert_eq!(
		::core::mem::size_of::<fd_set>(),
		128usize,
		concat!("Size of: ", stringify!(fd_set))
	);
	assert_eq!(
		::core::mem::align_of::<fd_set>(),
		8usize,
		concat!("Alignment of ", stringify!(fd_set))
	);
	assert_eq!(
		unsafe { &(*(::core::ptr::null::<fd_set>())).__fds_bits as *const _ as usize },
		0usize,
		concat!(
			"Offset of field: ",
			stringify!(fd_set),
			"::",
			stringify!(__fds_bits)
		)
	);
}
pub type fd_mask = __fd_mask;
extern "C" {
	pub fn select(
		__nfds: ::std::os::raw::c_int,
		__readfds: *mut fd_set,
		__writefds: *mut fd_set,
		__exceptfds: *mut fd_set,
		__timeout: *mut timeval,
	) -> ::std::os::raw::c_int;
}
extern "C" {
	pub fn pselect(
		__nfds: ::std::os::raw::c_int,
		__readfds: *mut fd_set,
		__writefds: *mut fd_set,
		__exceptfds: *mut fd_set,
		__timeout: *const timespec,
		__sigmask: *const __sigset_t,
	) -> ::std::os::raw::c_int;
}
pub type blksize_t = __blksize_t;
pub type blkcnt_t = __blkcnt_t;
pub type fsblkcnt_t = __fsblkcnt_t;
pub type fsfilcnt_t = __fsfilcnt_t;
#[repr(C)]
pub struct __pthread_rwlock_arch_t {
	pub __readers: ::std::os::raw::c_uint,
	pub __writers: ::std::os::raw::c_uint,
	pub __wrphase_futex: ::std::os::raw::c_uint,
	pub __writers_futex: ::std::os::raw::c_uint,
	pub __pad3: ::std::os::raw::c_uint,
	pub __pad4: ::std::os::raw::c_uint,
	pub __cur_writer: ::std::os::raw::c_int,
	pub __shared: ::std::os::raw::c_int,
	pub __rwelision: ::std::os::raw::c_schar,
	pub __pad1: [::std::os::raw::c_uchar; 7usize],
	pub __pad2: ::std::os::raw::c_ulong,
	pub __flags: ::std::os::raw::c_uint,
}
#[test]
fn bindgen_test_layout___pthread_rwlock_arch_t() {
	assert_eq!(
		::core::mem::size_of::<__pthread_rwlock_arch_t>(),
		56usize,
		concat!("Size of: ", stringify!(__pthread_rwlock_arch_t))
	);
	assert_eq!(
		::core::mem::align_of::<__pthread_rwlock_arch_t>(),
		8usize,
		concat!("Alignment of ", stringify!(__pthread_rwlock_arch_t))
	);
	assert_eq!(
		unsafe {
			&(*(::core::ptr::null::<__pthread_rwlock_arch_t>())).__readers as *const _ as usize
		},
		0usize,
		concat!(
			"Offset of field: ",
			stringify!(__pthread_rwlock_arch_t),
			"::",
			stringify!(__readers)
		)
	);
	assert_eq!(
		unsafe {
			&(*(::core::ptr::null::<__pthread_rwlock_arch_t>())).__writers as *const _ as usize
		},
		4usize,
		concat!(
			"Offset of field: ",
			stringify!(__pthread_rwlock_arch_t),
			"::",
			stringify!(__writers)
		)
	);
	assert_eq!(
		unsafe {
			&(*(::core::ptr::null::<__pthread_rwlock_arch_t>())).__wrphase_futex as *const _
				as usize
		},
		8usize,
		concat!(
			"Offset of field: ",
			stringify!(__pthread_rwlock_arch_t),
			"::",
			stringify!(__wrphase_futex)
		)
	);
	assert_eq!(
		unsafe {
			&(*(::core::ptr::null::<__pthread_rwlock_arch_t>())).__writers_futex as *const _
				as usize
		},
		12usize,
		concat!(
			"Offset of field: ",
			stringify!(__pthread_rwlock_arch_t),
			"::",
			stringify!(__writers_futex)
		)
	);
	assert_eq!(
		unsafe { &(*(::core::ptr::null::<__pthread_rwlock_arch_t>())).__pad3 as *const _ as usize },
		16usize,
		concat!(
			"Offset of field: ",
			stringify!(__pthread_rwlock_arch_t),
			"::",
			stringify!(__pad3)
		)
	);
	assert_eq!(
		unsafe { &(*(::core::ptr::null::<__pthread_rwlock_arch_t>())).__pad4 as *const _ as usize },
		20usize,
		concat!(
			"Offset of field: ",
			stringify!(__pthread_rwlock_arch_t),
			"::",
			stringify!(__pad4)
		)
	);
	assert_eq!(
		unsafe {
			&(*(::core::ptr::null::<__pthread_rwlock_arch_t>())).__cur_writer as *const _ as usize
		},
		24usize,
		concat!(
			"Offset of field: ",
			stringify!(__pthread_rwlock_arch_t),
			"::",
			stringify!(__cur_writer)
		)
	);
	assert_eq!(
		unsafe {
			&(*(::core::ptr::null::<__pthread_rwlock_arch_t>())).__shared as *const _ as usize
		},
		28usize,
		concat!(
			"Offset of field: ",
			stringify!(__pthread_rwlock_arch_t),
			"::",
			stringify!(__shared)
		)
	);
	assert_eq!(
		unsafe {
			&(*(::core::ptr::null::<__pthread_rwlock_arch_t>())).__rwelision as *const _ as usize
		},
		32usize,
		concat!(
			"Offset of field: ",
			stringify!(__pthread_rwlock_arch_t),
			"::",
			stringify!(__rwelision)
		)
	);
	assert_eq!(
		unsafe { &(*(::core::ptr::null::<__pthread_rwlock_arch_t>())).__pad1 as *const _ as usize },
		33usize,
		concat!(
			"Offset of field: ",
			stringify!(__pthread_rwlock_arch_t),
			"::",
			stringify!(__pad1)
		)
	);
	assert_eq!(
		unsafe { &(*(::core::ptr::null::<__pthread_rwlock_arch_t>())).__pad2 as *const _ as usize },
		40usize,
		concat!(
			"Offset of field: ",
			stringify!(__pthread_rwlock_arch_t),
			"::",
			stringify!(__pad2)
		)
	);
	assert_eq!(
		unsafe {
			&(*(::core::ptr::null::<__pthread_rwlock_arch_t>())).__flags as *const _ as usize
		},
		48usize,
		concat!(
			"Offset of field: ",
			stringify!(__pthread_rwlock_arch_t),
			"::",
			stringify!(__flags)
		)
	);
}
#[repr(C)]
pub struct __pthread_internal_list {
	pub __prev: *mut __pthread_internal_list,
	pub __next: *mut __pthread_internal_list,
}
#[test]
fn bindgen_test_layout___pthread_internal_list() {
	assert_eq!(
		::core::mem::size_of::<__pthread_internal_list>(),
		16usize,
		concat!("Size of: ", stringify!(__pthread_internal_list))
	);
	assert_eq!(
		::core::mem::align_of::<__pthread_internal_list>(),
		8usize,
		concat!("Alignment of ", stringify!(__pthread_internal_list))
	);
	assert_eq!(
		unsafe { &(*(::core::ptr::null::<__pthread_internal_list>())).__prev as *const _ as usize },
		0usize,
		concat!(
			"Offset of field: ",
			stringify!(__pthread_internal_list),
			"::",
			stringify!(__prev)
		)
	);
	assert_eq!(
		unsafe { &(*(::core::ptr::null::<__pthread_internal_list>())).__next as *const _ as usize },
		8usize,
		concat!(
			"Offset of field: ",
			stringify!(__pthread_internal_list),
			"::",
			stringify!(__next)
		)
	);
}
pub type __pthread_list_t = __pthread_internal_list;
#[repr(C)]
pub struct __pthread_mutex_s {
	pub __lock: ::std::os::raw::c_int,
	pub __count: ::std::os::raw::c_uint,
	pub __owner: ::std::os::raw::c_int,
	pub __nusers: ::std::os::raw::c_uint,
	pub __kind: ::std::os::raw::c_int,
	pub __spins: ::std::os::raw::c_short,
	pub __elision: ::std::os::raw::c_short,
	pub __list: __pthread_list_t,
}
#[test]
fn bindgen_test_layout___pthread_mutex_s() {
	assert_eq!(
		::core::mem::size_of::<__pthread_mutex_s>(),
		40usize,
		concat!("Size of: ", stringify!(__pthread_mutex_s))
	);
	assert_eq!(
		::core::mem::align_of::<__pthread_mutex_s>(),
		8usize,
		concat!("Alignment of ", stringify!(__pthread_mutex_s))
	);
	assert_eq!(
		unsafe { &(*(::core::ptr::null::<__pthread_mutex_s>())).__lock as *const _ as usize },
		0usize,
		concat!(
			"Offset of field: ",
			stringify!(__pthread_mutex_s),
			"::",
			stringify!(__lock)
		)
	);
	assert_eq!(
		unsafe { &(*(::core::ptr::null::<__pthread_mutex_s>())).__count as *const _ as usize },
		4usize,
		concat!(
			"Offset of field: ",
			stringify!(__pthread_mutex_s),
			"::",
			stringify!(__count)
		)
	);
	assert_eq!(
		unsafe { &(*(::core::ptr::null::<__pthread_mutex_s>())).__owner as *const _ as usize },
		8usize,
		concat!(
			"Offset of field: ",
			stringify!(__pthread_mutex_s),
			"::",
			stringify!(__owner)
		)
	);
	assert_eq!(
		unsafe { &(*(::core::ptr::null::<__pthread_mutex_s>())).__nusers as *const _ as usize },
		12usize,
		concat!(
			"Offset of field: ",
			stringify!(__pthread_mutex_s),
			"::",
			stringify!(__nusers)
		)
	);
	assert_eq!(
		unsafe { &(*(::core::ptr::null::<__pthread_mutex_s>())).__kind as *const _ as usize },
		16usize,
		concat!(
			"Offset of field: ",
			stringify!(__pthread_mutex_s),
			"::",
			stringify!(__kind)
		)
	);
	assert_eq!(
		unsafe { &(*(::core::ptr::null::<__pthread_mutex_s>())).__spins as *const _ as usize },
		20usize,
		concat!(
			"Offset of field: ",
			stringify!(__pthread_mutex_s),
			"::",
			stringify!(__spins)
		)
	);
	assert_eq!(
		unsafe { &(*(::core::ptr::null::<__pthread_mutex_s>())).__elision as *const _ as usize },
		22usize,
		concat!(
			"Offset of field: ",
			stringify!(__pthread_mutex_s),
			"::",
			stringify!(__elision)
		)
	);
	assert_eq!(
		unsafe { &(*(::core::ptr::null::<__pthread_mutex_s>())).__list as *const _ as usize },
		24usize,
		concat!(
			"Offset of field: ",
			stringify!(__pthread_mutex_s),
			"::",
			stringify!(__list)
		)
	);
}
#[repr(C)]
pub struct __pthread_cond_s {
	pub __bindgen_anon_1: __pthread_cond_s__bindgen_ty_1,
	pub __bindgen_anon_2: __pthread_cond_s__bindgen_ty_2,
	pub __g_refs: [::std::os::raw::c_uint; 2usize],
	pub __g_size: [::std::os::raw::c_uint; 2usize],
	pub __g1_orig_size: ::std::os::raw::c_uint,
	pub __wrefs: ::std::os::raw::c_uint,
	pub __g_signals: [::std::os::raw::c_uint; 2usize],
}
#[repr(C)]
pub struct __pthread_cond_s__bindgen_ty_1 {
	pub __wseq: __BindgenUnionField<::std::os::raw::c_ulonglong>,
	pub __wseq32: __BindgenUnionField<__pthread_cond_s__bindgen_ty_1__bindgen_ty_1>,
	pub bindgen_union_field: u64,
}
#[repr(C)]
pub struct __pthread_cond_s__bindgen_ty_1__bindgen_ty_1 {
	pub __low: ::std::os::raw::c_uint,
	pub __high: ::std::os::raw::c_uint,
}
#[test]
fn bindgen_test_layout___pthread_cond_s__bindgen_ty_1__bindgen_ty_1() {
	assert_eq!(
		::core::mem::size_of::<__pthread_cond_s__bindgen_ty_1__bindgen_ty_1>(),
		8usize,
		concat!(
			"Size of: ",
			stringify!(__pthread_cond_s__bindgen_ty_1__bindgen_ty_1)
		)
	);
	assert_eq!(
		::core::mem::align_of::<__pthread_cond_s__bindgen_ty_1__bindgen_ty_1>(),
		4usize,
		concat!(
			"Alignment of ",
			stringify!(__pthread_cond_s__bindgen_ty_1__bindgen_ty_1)
		)
	);
	assert_eq!(
		unsafe {
			&(*(::core::ptr::null::<__pthread_cond_s__bindgen_ty_1__bindgen_ty_1>())).__low
				as *const _ as usize
		},
		0usize,
		concat!(
			"Offset of field: ",
			stringify!(__pthread_cond_s__bindgen_ty_1__bindgen_ty_1),
			"::",
			stringify!(__low)
		)
	);
	assert_eq!(
		unsafe {
			&(*(::core::ptr::null::<__pthread_cond_s__bindgen_ty_1__bindgen_ty_1>())).__high
				as *const _ as usize
		},
		4usize,
		concat!(
			"Offset of field: ",
			stringify!(__pthread_cond_s__bindgen_ty_1__bindgen_ty_1),
			"::",
			stringify!(__high)
		)
	);
}
#[test]
fn bindgen_test_layout___pthread_cond_s__bindgen_ty_1() {
	assert_eq!(
		::core::mem::size_of::<__pthread_cond_s__bindgen_ty_1>(),
		8usize,
		concat!("Size of: ", stringify!(__pthread_cond_s__bindgen_ty_1))
	);
	assert_eq!(
		::core::mem::align_of::<__pthread_cond_s__bindgen_ty_1>(),
		8usize,
		concat!("Alignment of ", stringify!(__pthread_cond_s__bindgen_ty_1))
	);
	assert_eq!(
		unsafe {
			&(*(::core::ptr::null::<__pthread_cond_s__bindgen_ty_1>())).__wseq as *const _ as usize
		},
		0usize,
		concat!(
			"Offset of field: ",
			stringify!(__pthread_cond_s__bindgen_ty_1),
			"::",
			stringify!(__wseq)
		)
	);
	assert_eq!(
		unsafe {
			&(*(::core::ptr::null::<__pthread_cond_s__bindgen_ty_1>())).__wseq32 as *const _
				as usize
		},
		0usize,
		concat!(
			"Offset of field: ",
			stringify!(__pthread_cond_s__bindgen_ty_1),
			"::",
			stringify!(__wseq32)
		)
	);
}
#[repr(C)]
pub struct __pthread_cond_s__bindgen_ty_2 {
	pub __g1_start: __BindgenUnionField<::std::os::raw::c_ulonglong>,
	pub __g1_start32: __BindgenUnionField<__pthread_cond_s__bindgen_ty_2__bindgen_ty_1>,
	pub bindgen_union_field: u64,
}
#[repr(C)]
pub struct __pthread_cond_s__bindgen_ty_2__bindgen_ty_1 {
	pub __low: ::std::os::raw::c_uint,
	pub __high: ::std::os::raw::c_uint,
}
#[test]
fn bindgen_test_layout___pthread_cond_s__bindgen_ty_2__bindgen_ty_1() {
	assert_eq!(
		::core::mem::size_of::<__pthread_cond_s__bindgen_ty_2__bindgen_ty_1>(),
		8usize,
		concat!(
			"Size of: ",
			stringify!(__pthread_cond_s__bindgen_ty_2__bindgen_ty_1)
		)
	);
	assert_eq!(
		::core::mem::align_of::<__pthread_cond_s__bindgen_ty_2__bindgen_ty_1>(),
		4usize,
		concat!(
			"Alignment of ",
			stringify!(__pthread_cond_s__bindgen_ty_2__bindgen_ty_1)
		)
	);
	assert_eq!(
		unsafe {
			&(*(::core::ptr::null::<__pthread_cond_s__bindgen_ty_2__bindgen_ty_1>())).__low
				as *const _ as usize
		},
		0usize,
		concat!(
			"Offset of field: ",
			stringify!(__pthread_cond_s__bindgen_ty_2__bindgen_ty_1),
			"::",
			stringify!(__low)
		)
	);
	assert_eq!(
		unsafe {
			&(*(::core::ptr::null::<__pthread_cond_s__bindgen_ty_2__bindgen_ty_1>())).__high
				as *const _ as usize
		},
		4usize,
		concat!(
			"Offset of field: ",
			stringify!(__pthread_cond_s__bindgen_ty_2__bindgen_ty_1),
			"::",
			stringify!(__high)
		)
	);
}
#[test]
fn bindgen_test_layout___pthread_cond_s__bindgen_ty_2() {
	assert_eq!(
		::core::mem::size_of::<__pthread_cond_s__bindgen_ty_2>(),
		8usize,
		concat!("Size of: ", stringify!(__pthread_cond_s__bindgen_ty_2))
	);
	assert_eq!(
		::core::mem::align_of::<__pthread_cond_s__bindgen_ty_2>(),
		8usize,
		concat!("Alignment of ", stringify!(__pthread_cond_s__bindgen_ty_2))
	);
	assert_eq!(
		unsafe {
			&(*(::core::ptr::null::<__pthread_cond_s__bindgen_ty_2>())).__g1_start as *const _
				as usize
		},
		0usize,
		concat!(
			"Offset of field: ",
			stringify!(__pthread_cond_s__bindgen_ty_2),
			"::",
			stringify!(__g1_start)
		)
	);
	assert_eq!(
		unsafe {
			&(*(::core::ptr::null::<__pthread_cond_s__bindgen_ty_2>())).__g1_start32 as *const _
				as usize
		},
		0usize,
		concat!(
			"Offset of field: ",
			stringify!(__pthread_cond_s__bindgen_ty_2),
			"::",
			stringify!(__g1_start32)
		)
	);
}
#[test]
fn bindgen_test_layout___pthread_cond_s() {
	assert_eq!(
		::core::mem::size_of::<__pthread_cond_s>(),
		48usize,
		concat!("Size of: ", stringify!(__pthread_cond_s))
	);
	assert_eq!(
		::core::mem::align_of::<__pthread_cond_s>(),
		8usize,
		concat!("Alignment of ", stringify!(__pthread_cond_s))
	);
	assert_eq!(
		unsafe { &(*(::core::ptr::null::<__pthread_cond_s>())).__g_refs as *const _ as usize },
		16usize,
		concat!(
			"Offset of field: ",
			stringify!(__pthread_cond_s),
			"::",
			stringify!(__g_refs)
		)
	);
	assert_eq!(
		unsafe { &(*(::core::ptr::null::<__pthread_cond_s>())).__g_size as *const _ as usize },
		24usize,
		concat!(
			"Offset of field: ",
			stringify!(__pthread_cond_s),
			"::",
			stringify!(__g_size)
		)
	);
	assert_eq!(
		unsafe {
			&(*(::core::ptr::null::<__pthread_cond_s>())).__g1_orig_size as *const _ as usize
		},
		32usize,
		concat!(
			"Offset of field: ",
			stringify!(__pthread_cond_s),
			"::",
			stringify!(__g1_orig_size)
		)
	);
	assert_eq!(
		unsafe { &(*(::core::ptr::null::<__pthread_cond_s>())).__wrefs as *const _ as usize },
		36usize,
		concat!(
			"Offset of field: ",
			stringify!(__pthread_cond_s),
			"::",
			stringify!(__wrefs)
		)
	);
	assert_eq!(
		unsafe { &(*(::core::ptr::null::<__pthread_cond_s>())).__g_signals as *const _ as usize },
		40usize,
		concat!(
			"Offset of field: ",
			stringify!(__pthread_cond_s),
			"::",
			stringify!(__g_signals)
		)
	);
}
pub type pthread_t = ::std::os::raw::c_ulong;
#[repr(C)]
pub struct pthread_mutexattr_t {
	pub __size: __BindgenUnionField<[::std::os::raw::c_char; 4usize]>,
	pub __align: __BindgenUnionField<::std::os::raw::c_int>,
	pub bindgen_union_field: u32,
}
#[test]
fn bindgen_test_layout_pthread_mutexattr_t() {
	assert_eq!(
		::core::mem::size_of::<pthread_mutexattr_t>(),
		4usize,
		concat!("Size of: ", stringify!(pthread_mutexattr_t))
	);
	assert_eq!(
		::core::mem::align_of::<pthread_mutexattr_t>(),
		4usize,
		concat!("Alignment of ", stringify!(pthread_mutexattr_t))
	);
	assert_eq!(
		unsafe { &(*(::core::ptr::null::<pthread_mutexattr_t>())).__size as *const _ as usize },
		0usize,
		concat!(
			"Offset of field: ",
			stringify!(pthread_mutexattr_t),
			"::",
			stringify!(__size)
		)
	);
	assert_eq!(
		unsafe { &(*(::core::ptr::null::<pthread_mutexattr_t>())).__align as *const _ as usize },
		0usize,
		concat!(
			"Offset of field: ",
			stringify!(pthread_mutexattr_t),
			"::",
			stringify!(__align)
		)
	);
}
#[repr(C)]
pub struct pthread_condattr_t {
	pub __size: __BindgenUnionField<[::std::os::raw::c_char; 4usize]>,
	pub __align: __BindgenUnionField<::std::os::raw::c_int>,
	pub bindgen_union_field: u32,
}
#[test]
fn bindgen_test_layout_pthread_condattr_t() {
	assert_eq!(
		::core::mem::size_of::<pthread_condattr_t>(),
		4usize,
		concat!("Size of: ", stringify!(pthread_condattr_t))
	);
	assert_eq!(
		::core::mem::align_of::<pthread_condattr_t>(),
		4usize,
		concat!("Alignment of ", stringify!(pthread_condattr_t))
	);
	assert_eq!(
		unsafe { &(*(::core::ptr::null::<pthread_condattr_t>())).__size as *const _ as usize },
		0usize,
		concat!(
			"Offset of field: ",
			stringify!(pthread_condattr_t),
			"::",
			stringify!(__size)
		)
	);
	assert_eq!(
		unsafe { &(*(::core::ptr::null::<pthread_condattr_t>())).__align as *const _ as usize },
		0usize,
		concat!(
			"Offset of field: ",
			stringify!(pthread_condattr_t),
			"::",
			stringify!(__align)
		)
	);
}
pub type pthread_key_t = ::std::os::raw::c_uint;
pub type pthread_once_t = ::std::os::raw::c_int;
#[repr(C)]
pub struct pthread_attr_t {
	pub __size: __BindgenUnionField<[::std::os::raw::c_char; 56usize]>,
	pub __align: __BindgenUnionField<::std::os::raw::c_long>,
	pub bindgen_union_field: [u64; 7usize],
}
#[test]
fn bindgen_test_layout_pthread_attr_t() {
	assert_eq!(
		::core::mem::size_of::<pthread_attr_t>(),
		56usize,
		concat!("Size of: ", stringify!(pthread_attr_t))
	);
	assert_eq!(
		::core::mem::align_of::<pthread_attr_t>(),
		8usize,
		concat!("Alignment of ", stringify!(pthread_attr_t))
	);
	assert_eq!(
		unsafe { &(*(::core::ptr::null::<pthread_attr_t>())).__size as *const _ as usize },
		0usize,
		concat!(
			"Offset of field: ",
			stringify!(pthread_attr_t),
			"::",
			stringify!(__size)
		)
	);
	assert_eq!(
		unsafe { &(*(::core::ptr::null::<pthread_attr_t>())).__align as *const _ as usize },
		0usize,
		concat!(
			"Offset of field: ",
			stringify!(pthread_attr_t),
			"::",
			stringify!(__align)
		)
	);
}
#[repr(C)]
pub struct pthread_mutex_t {
	pub __data: __BindgenUnionField<__pthread_mutex_s>,
	pub __size: __BindgenUnionField<[::std::os::raw::c_char; 40usize]>,
	pub __align: __BindgenUnionField<::std::os::raw::c_long>,
	pub bindgen_union_field: [u64; 5usize],
}
#[test]
fn bindgen_test_layout_pthread_mutex_t() {
	assert_eq!(
		::core::mem::size_of::<pthread_mutex_t>(),
		40usize,
		concat!("Size of: ", stringify!(pthread_mutex_t))
	);
	assert_eq!(
		::core::mem::align_of::<pthread_mutex_t>(),
		8usize,
		concat!("Alignment of ", stringify!(pthread_mutex_t))
	);
	assert_eq!(
		unsafe { &(*(::core::ptr::null::<pthread_mutex_t>())).__data as *const _ as usize },
		0usize,
		concat!(
			"Offset of field: ",
			stringify!(pthread_mutex_t),
			"::",
			stringify!(__data)
		)
	);
	assert_eq!(
		unsafe { &(*(::core::ptr::null::<pthread_mutex_t>())).__size as *const _ as usize },
		0usize,
		concat!(
			"Offset of field: ",
			stringify!(pthread_mutex_t),
			"::",
			stringify!(__size)
		)
	);
	assert_eq!(
		unsafe { &(*(::core::ptr::null::<pthread_mutex_t>())).__align as *const _ as usize },
		0usize,
		concat!(
			"Offset of field: ",
			stringify!(pthread_mutex_t),
			"::",
			stringify!(__align)
		)
	);
}
#[repr(C)]
pub struct pthread_cond_t {
	pub __data: __BindgenUnionField<__pthread_cond_s>,
	pub __size: __BindgenUnionField<[::std::os::raw::c_char; 48usize]>,
	pub __align: __BindgenUnionField<::std::os::raw::c_longlong>,
	pub bindgen_union_field: [u64; 6usize],
}
#[test]
fn bindgen_test_layout_pthread_cond_t() {
	assert_eq!(
		::core::mem::size_of::<pthread_cond_t>(),
		48usize,
		concat!("Size of: ", stringify!(pthread_cond_t))
	);
	assert_eq!(
		::core::mem::align_of::<pthread_cond_t>(),
		8usize,
		concat!("Alignment of ", stringify!(pthread_cond_t))
	);
	assert_eq!(
		unsafe { &(*(::core::ptr::null::<pthread_cond_t>())).__data as *const _ as usize },
		0usize,
		concat!(
			"Offset of field: ",
			stringify!(pthread_cond_t),
			"::",
			stringify!(__data)
		)
	);
	assert_eq!(
		unsafe { &(*(::core::ptr::null::<pthread_cond_t>())).__size as *const _ as usize },
		0usize,
		concat!(
			"Offset of field: ",
			stringify!(pthread_cond_t),
			"::",
			stringify!(__size)
		)
	);
	assert_eq!(
		unsafe { &(*(::core::ptr::null::<pthread_cond_t>())).__align as *const _ as usize },
		0usize,
		concat!(
			"Offset of field: ",
			stringify!(pthread_cond_t),
			"::",
			stringify!(__align)
		)
	);
}
#[repr(C)]
pub struct pthread_rwlock_t {
	pub __data: __BindgenUnionField<__pthread_rwlock_arch_t>,
	pub __size: __BindgenUnionField<[::std::os::raw::c_char; 56usize]>,
	pub __align: __BindgenUnionField<::std::os::raw::c_long>,
	pub bindgen_union_field: [u64; 7usize],
}
#[test]
fn bindgen_test_layout_pthread_rwlock_t() {
	assert_eq!(
		::core::mem::size_of::<pthread_rwlock_t>(),
		56usize,
		concat!("Size of: ", stringify!(pthread_rwlock_t))
	);
	assert_eq!(
		::core::mem::align_of::<pthread_rwlock_t>(),
		8usize,
		concat!("Alignment of ", stringify!(pthread_rwlock_t))
	);
	assert_eq!(
		unsafe { &(*(::core::ptr::null::<pthread_rwlock_t>())).__data as *const _ as usize },
		0usize,
		concat!(
			"Offset of field: ",
			stringify!(pthread_rwlock_t),
			"::",
			stringify!(__data)
		)
	);
	assert_eq!(
		unsafe { &(*(::core::ptr::null::<pthread_rwlock_t>())).__size as *const _ as usize },
		0usize,
		concat!(
			"Offset of field: ",
			stringify!(pthread_rwlock_t),
			"::",
			stringify!(__size)
		)
	);
	assert_eq!(
		unsafe { &(*(::core::ptr::null::<pthread_rwlock_t>())).__align as *const _ as usize },
		0usize,
		concat!(
			"Offset of field: ",
			stringify!(pthread_rwlock_t),
			"::",
			stringify!(__align)
		)
	);
}
#[repr(C)]
pub struct pthread_rwlockattr_t {
	pub __size: __BindgenUnionField<[::std::os::raw::c_char; 8usize]>,
	pub __align: __BindgenUnionField<::std::os::raw::c_long>,
	pub bindgen_union_field: u64,
}
#[test]
fn bindgen_test_layout_pthread_rwlockattr_t() {
	assert_eq!(
		::core::mem::size_of::<pthread_rwlockattr_t>(),
		8usize,
		concat!("Size of: ", stringify!(pthread_rwlockattr_t))
	);
	assert_eq!(
		::core::mem::align_of::<pthread_rwlockattr_t>(),
		8usize,
		concat!("Alignment of ", stringify!(pthread_rwlockattr_t))
	);
	assert_eq!(
		unsafe { &(*(::core::ptr::null::<pthread_rwlockattr_t>())).__size as *const _ as usize },
		0usize,
		concat!(
			"Offset of field: ",
			stringify!(pthread_rwlockattr_t),
			"::",
			stringify!(__size)
		)
	);
	assert_eq!(
		unsafe { &(*(::core::ptr::null::<pthread_rwlockattr_t>())).__align as *const _ as usize },
		0usize,
		concat!(
			"Offset of field: ",
			stringify!(pthread_rwlockattr_t),
			"::",
			stringify!(__align)
		)
	);
}
pub type pthread_spinlock_t = ::std::os::raw::c_int;
#[repr(C)]
pub struct pthread_barrier_t {
	pub __size: __BindgenUnionField<[::std::os::raw::c_char; 32usize]>,
	pub __align: __BindgenUnionField<::std::os::raw::c_long>,
	pub bindgen_union_field: [u64; 4usize],
}
#[test]
fn bindgen_test_layout_pthread_barrier_t() {
	assert_eq!(
		::core::mem::size_of::<pthread_barrier_t>(),
		32usize,
		concat!("Size of: ", stringify!(pthread_barrier_t))
	);
	assert_eq!(
		::core::mem::align_of::<pthread_barrier_t>(),
		8usize,
		concat!("Alignment of ", stringify!(pthread_barrier_t))
	);
	assert_eq!(
		unsafe { &(*(::core::ptr::null::<pthread_barrier_t>())).__size as *const _ as usize },
		0usize,
		concat!(
			"Offset of field: ",
			stringify!(pthread_barrier_t),
			"::",
			stringify!(__size)
		)
	);
	assert_eq!(
		unsafe { &(*(::core::ptr::null::<pthread_barrier_t>())).__align as *const _ as usize },
		0usize,
		concat!(
			"Offset of field: ",
			stringify!(pthread_barrier_t),
			"::",
			stringify!(__align)
		)
	);
}
#[repr(C)]
pub struct pthread_barrierattr_t {
	pub __size: __BindgenUnionField<[::std::os::raw::c_char; 4usize]>,
	pub __align: __BindgenUnionField<::std::os::raw::c_int>,
	pub bindgen_union_field: u32,
}
#[test]
fn bindgen_test_layout_pthread_barrierattr_t() {
	assert_eq!(
		::core::mem::size_of::<pthread_barrierattr_t>(),
		4usize,
		concat!("Size of: ", stringify!(pthread_barrierattr_t))
	);
	assert_eq!(
		::core::mem::align_of::<pthread_barrierattr_t>(),
		4usize,
		concat!("Alignment of ", stringify!(pthread_barrierattr_t))
	);
	assert_eq!(
		unsafe { &(*(::core::ptr::null::<pthread_barrierattr_t>())).__size as *const _ as usize },
		0usize,
		concat!(
			"Offset of field: ",
			stringify!(pthread_barrierattr_t),
			"::",
			stringify!(__size)
		)
	);
	assert_eq!(
		unsafe { &(*(::core::ptr::null::<pthread_barrierattr_t>())).__align as *const _ as usize },
		0usize,
		concat!(
			"Offset of field: ",
			stringify!(pthread_barrierattr_t),
			"::",
			stringify!(__align)
		)
	);
}
extern "C" {
	pub fn random() -> ::std::os::raw::c_long;
}
extern "C" {
	pub fn srandom(__seed: ::std::os::raw::c_uint);
}
extern "C" {
	pub fn initstate(
		__seed: ::std::os::raw::c_uint,
		__statebuf: *mut ::std::os::raw::c_char,
		__statelen: size_t,
	) -> *mut ::std::os::raw::c_char;
}
extern "C" {
	pub fn setstate(__statebuf: *mut ::std::os::raw::c_char) -> *mut ::std::os::raw::c_char;
}
#[repr(C)]
pub struct random_data {
	pub fptr: *mut i32,
	pub rptr: *mut i32,
	pub state: *mut i32,
	pub rand_type: ::std::os::raw::c_int,
	pub rand_deg: ::std::os::raw::c_int,
	pub rand_sep: ::std::os::raw::c_int,
	pub end_ptr: *mut i32,
}
#[test]
fn bindgen_test_layout_random_data() {
	assert_eq!(
		::core::mem::size_of::<random_data>(),
		48usize,
		concat!("Size of: ", stringify!(random_data))
	);
	assert_eq!(
		::core::mem::align_of::<random_data>(),
		8usize,
		concat!("Alignment of ", stringify!(random_data))
	);
	assert_eq!(
		unsafe { &(*(::core::ptr::null::<random_data>())).fptr as *const _ as usize },
		0usize,
		concat!(
			"Offset of field: ",
			stringify!(random_data),
			"::",
			stringify!(fptr)
		)
	);
	assert_eq!(
		unsafe { &(*(::core::ptr::null::<random_data>())).rptr as *const _ as usize },
		8usize,
		concat!(
			"Offset of field: ",
			stringify!(random_data),
			"::",
			stringify!(rptr)
		)
	);
	assert_eq!(
		unsafe { &(*(::core::ptr::null::<random_data>())).state as *const _ as usize },
		16usize,
		concat!(
			"Offset of field: ",
			stringify!(random_data),
			"::",
			stringify!(state)
		)
	);
	assert_eq!(
		unsafe { &(*(::core::ptr::null::<random_data>())).rand_type as *const _ as usize },
		24usize,
		concat!(
			"Offset of field: ",
			stringify!(random_data),
			"::",
			stringify!(rand_type)
		)
	);
	assert_eq!(
		unsafe { &(*(::core::ptr::null::<random_data>())).rand_deg as *const _ as usize },
		28usize,
		concat!(
			"Offset of field: ",
			stringify!(random_data),
			"::",
			stringify!(rand_deg)
		)
	);
	assert_eq!(
		unsafe { &(*(::core::ptr::null::<random_data>())).rand_sep as *const _ as usize },
		32usize,
		concat!(
			"Offset of field: ",
			stringify!(random_data),
			"::",
			stringify!(rand_sep)
		)
	);
	assert_eq!(
		unsafe { &(*(::core::ptr::null::<random_data>())).end_ptr as *const _ as usize },
		40usize,
		concat!(
			"Offset of field: ",
			stringify!(random_data),
			"::",
			stringify!(end_ptr)
		)
	);
}
extern "C" {
	pub fn random_r(__buf: *mut random_data, __result: *mut i32) -> ::std::os::raw::c_int;
}
extern "C" {
	pub fn srandom_r(
		__seed: ::std::os::raw::c_uint,
		__buf: *mut random_data,
	) -> ::std::os::raw::c_int;
}
extern "C" {
	pub fn initstate_r(
		__seed: ::std::os::raw::c_uint,
		__statebuf: *mut ::std::os::raw::c_char,
		__statelen: size_t,
		__buf: *mut random_data,
	) -> ::std::os::raw::c_int;
}
extern "C" {
	pub fn setstate_r(
		__statebuf: *mut ::std::os::raw::c_char,
		__buf: *mut random_data,
	) -> ::std::os::raw::c_int;
}
extern "C" {
	pub fn rand() -> ::std::os::raw::c_int;
}
extern "C" {
	pub fn srand(__seed: ::std::os::raw::c_uint);
}
extern "C" {
	pub fn rand_r(__seed: *mut ::std::os::raw::c_uint) -> ::std::os::raw::c_int;
}
extern "C" {
	pub fn drand48() -> f64;
}
extern "C" {
	pub fn erand48(__xsubi: *mut ::std::os::raw::c_ushort) -> f64;
}
extern "C" {
	pub fn lrand48() -> ::std::os::raw::c_long;
}
extern "C" {
	pub fn nrand48(__xsubi: *mut ::std::os::raw::c_ushort) -> ::std::os::raw::c_long;
}
extern "C" {
	pub fn mrand48() -> ::std::os::raw::c_long;
}
extern "C" {
	pub fn jrand48(__xsubi: *mut ::std::os::raw::c_ushort) -> ::std::os::raw::c_long;
}
extern "C" {
	pub fn srand48(__seedval: ::std::os::raw::c_long);
}
extern "C" {
	pub fn seed48(__seed16v: *mut ::std::os::raw::c_ushort) -> *mut ::std::os::raw::c_ushort;
}
extern "C" {
	pub fn lcong48(__param: *mut ::std::os::raw::c_ushort);
}
#[repr(C)]
pub struct drand48_data {
	pub __x: [::std::os::raw::c_ushort; 3usize],
	pub __old_x: [::std::os::raw::c_ushort; 3usize],
	pub __c: ::std::os::raw::c_ushort,
	pub __init: ::std::os::raw::c_ushort,
	pub __a: ::std::os::raw::c_ulonglong,
}
#[test]
fn bindgen_test_layout_drand48_data() {
	assert_eq!(
		::core::mem::size_of::<drand48_data>(),
		24usize,
		concat!("Size of: ", stringify!(drand48_data))
	);
	assert_eq!(
		::core::mem::align_of::<drand48_data>(),
		8usize,
		concat!("Alignment of ", stringify!(drand48_data))
	);
	assert_eq!(
		unsafe { &(*(::core::ptr::null::<drand48_data>())).__x as *const _ as usize },
		0usize,
		concat!(
			"Offset of field: ",
			stringify!(drand48_data),
			"::",
			stringify!(__x)
		)
	);
	assert_eq!(
		unsafe { &(*(::core::ptr::null::<drand48_data>())).__old_x as *const _ as usize },
		6usize,
		concat!(
			"Offset of field: ",
			stringify!(drand48_data),
			"::",
			stringify!(__old_x)
		)
	);
	assert_eq!(
		unsafe { &(*(::core::ptr::null::<drand48_data>())).__c as *const _ as usize },
		12usize,
		concat!(
			"Offset of field: ",
			stringify!(drand48_data),
			"::",
			stringify!(__c)
		)
	);
	assert_eq!(
		unsafe { &(*(::core::ptr::null::<drand48_data>())).__init as *const _ as usize },
		14usize,
		concat!(
			"Offset of field: ",
			stringify!(drand48_data),
			"::",
			stringify!(__init)
		)
	);
	assert_eq!(
		unsafe { &(*(::core::ptr::null::<drand48_data>())).__a as *const _ as usize },
		16usize,
		concat!(
			"Offset of field: ",
			stringify!(drand48_data),
			"::",
			stringify!(__a)
		)
	);
}
extern "C" {
	pub fn drand48_r(__buffer: *mut drand48_data, __result: *mut f64) -> ::std::os::raw::c_int;
}
extern "C" {
	pub fn erand48_r(
		__xsubi: *mut ::std::os::raw::c_ushort,
		__buffer: *mut drand48_data,
		__result: *mut f64,
	) -> ::std::os::raw::c_int;
}
extern "C" {
	pub fn lrand48_r(
		__buffer: *mut drand48_data,
		__result: *mut ::std::os::raw::c_long,
	) -> ::std::os::raw::c_int;
}
extern "C" {
	pub fn nrand48_r(
		__xsubi: *mut ::std::os::raw::c_ushort,
		__buffer: *mut drand48_data,
		__result: *mut ::std::os::raw::c_long,
	) -> ::std::os::raw::c_int;
}
extern "C" {
	pub fn mrand48_r(
		__buffer: *mut drand48_data,
		__result: *mut ::std::os::raw::c_long,
	) -> ::std::os::raw::c_int;
}
extern "C" {
	pub fn jrand48_r(
		__xsubi: *mut ::std::os::raw::c_ushort,
		__buffer: *mut drand48_data,
		__result: *mut ::std::os::raw::c_long,
	) -> ::std::os::raw::c_int;
}
extern "C" {
	pub fn srand48_r(
		__seedval: ::std::os::raw::c_long,
		__buffer: *mut drand48_data,
	) -> ::std::os::raw::c_int;
}
extern "C" {
	pub fn seed48_r(
		__seed16v: *mut ::std::os::raw::c_ushort,
		__buffer: *mut drand48_data,
	) -> ::std::os::raw::c_int;
}
extern "C" {
	pub fn lcong48_r(
		__param: *mut ::std::os::raw::c_ushort,
		__buffer: *mut drand48_data,
	) -> ::std::os::raw::c_int;
}
extern "C" {
	pub fn malloc(__size: ::std::os::raw::c_ulong) -> *mut ::core::ffi::c_void;
}
extern "C" {
	pub fn calloc(
		__nmemb: ::std::os::raw::c_ulong,
		__size: ::std::os::raw::c_ulong,
	) -> *mut ::core::ffi::c_void;
}
extern "C" {
	pub fn realloc(
		__ptr: *mut ::core::ffi::c_void,
		__size: ::std::os::raw::c_ulong,
	) -> *mut ::core::ffi::c_void;
}
extern "C" {
	pub fn free(__ptr: *mut ::core::ffi::c_void);
}
extern "C" {
	pub fn alloca(__size: ::std::os::raw::c_ulong) -> *mut ::core::ffi::c_void;
}
extern "C" {
	pub fn valloc(__size: size_t) -> *mut ::core::ffi::c_void;
}
extern "C" {
	pub fn posix_memalign(
		__memptr: *mut *mut ::core::ffi::c_void,
		__alignment: size_t,
		__size: size_t,
	) -> ::std::os::raw::c_int;
}
extern "C" {
	pub fn aligned_alloc(__alignment: size_t, __size: size_t) -> *mut ::core::ffi::c_void;
}
extern "C" {
	pub fn abort();
}
extern "C" {
	pub fn atexit(__func: ::core::option::Option<unsafe extern "C" fn()>) -> ::std::os::raw::c_int;
}
extern "C" {
	pub fn at_quick_exit(
		__func: ::core::option::Option<unsafe extern "C" fn()>,
	) -> ::std::os::raw::c_int;
}
extern "C" {
	pub fn on_exit(
		__func: ::core::option::Option<
			unsafe extern "C" fn(__status: ::std::os::raw::c_int, __arg: *mut ::core::ffi::c_void),
		>,
		__arg: *mut ::core::ffi::c_void,
	) -> ::std::os::raw::c_int;
}
extern "C" {
	pub fn exit(__status: ::std::os::raw::c_int);
}
extern "C" {
	pub fn quick_exit(__status: ::std::os::raw::c_int);
}
extern "C" {
	pub fn _Exit(__status: ::std::os::raw::c_int);
}
extern "C" {
	pub fn getenv(__name: *const ::std::os::raw::c_char) -> *mut ::std::os::raw::c_char;
}
extern "C" {
	pub fn putenv(__string: *mut ::std::os::raw::c_char) -> ::std::os::raw::c_int;
}
extern "C" {
	pub fn setenv(
		__name: *const ::std::os::raw::c_char,
		__value: *const ::std::os::raw::c_char,
		__replace: ::std::os::raw::c_int,
	) -> ::std::os::raw::c_int;
}
extern "C" {
	pub fn unsetenv(__name: *const ::std::os::raw::c_char) -> ::std::os::raw::c_int;
}
extern "C" {
	pub fn clearenv() -> ::std::os::raw::c_int;
}
extern "C" {
	pub fn mktemp(__template: *mut ::std::os::raw::c_char) -> *mut ::std::os::raw::c_char;
}
extern "C" {
	pub fn mkstemp(__template: *mut ::std::os::raw::c_char) -> ::std::os::raw::c_int;
}
extern "C" {
	pub fn mkstemps(
		__template: *mut ::std::os::raw::c_char,
		__suffixlen: ::std::os::raw::c_int,
	) -> ::std::os::raw::c_int;
}
extern "C" {
	pub fn mkdtemp(__template: *mut ::std::os::raw::c_char) -> *mut ::std::os::raw::c_char;
}
extern "C" {
	pub fn system(__command: *const ::std::os::raw::c_char) -> ::std::os::raw::c_int;
}
extern "C" {
	pub fn realpath(
		__name: *const ::std::os::raw::c_char,
		__resolved: *mut ::std::os::raw::c_char,
	) -> *mut ::std::os::raw::c_char;
}
pub type __compar_fn_t = ::core::option::Option<
	unsafe extern "C" fn(
		arg1: *const ::core::ffi::c_void,
		arg2: *const ::core::ffi::c_void,
	) -> ::std::os::raw::c_int,
>;
extern "C" {
	pub fn bsearch(
		__key: *const ::core::ffi::c_void,
		__base: *const ::core::ffi::c_void,
		__nmemb: size_t,
		__size: size_t,
		__compar: __compar_fn_t,
	) -> *mut ::core::ffi::c_void;
}
extern "C" {
	pub fn qsort(
		__base: *mut ::core::ffi::c_void,
		__nmemb: size_t,
		__size: size_t,
		__compar: __compar_fn_t,
	);
}
extern "C" {
	pub fn abs(__x: ::std::os::raw::c_int) -> ::std::os::raw::c_int;
}
extern "C" {
	pub fn labs(__x: ::std::os::raw::c_long) -> ::std::os::raw::c_long;
}
extern "C" {
	pub fn llabs(__x: ::std::os::raw::c_longlong) -> ::std::os::raw::c_longlong;
}
extern "C" {
	pub fn div(__numer: ::std::os::raw::c_int, __denom: ::std::os::raw::c_int) -> div_t;
}
extern "C" {
	pub fn ldiv(__numer: ::std::os::raw::c_long, __denom: ::std::os::raw::c_long) -> ldiv_t;
}
extern "C" {
	pub fn lldiv(
		__numer: ::std::os::raw::c_longlong,
		__denom: ::std::os::raw::c_longlong,
	) -> lldiv_t;
}
extern "C" {
	pub fn ecvt(
		__value: f64,
		__ndigit: ::std::os::raw::c_int,
		__decpt: *mut ::std::os::raw::c_int,
		__sign: *mut ::std::os::raw::c_int,
	) -> *mut ::std::os::raw::c_char;
}
extern "C" {
	pub fn fcvt(
		__value: f64,
		__ndigit: ::std::os::raw::c_int,
		__decpt: *mut ::std::os::raw::c_int,
		__sign: *mut ::std::os::raw::c_int,
	) -> *mut ::std::os::raw::c_char;
}
extern "C" {
	pub fn gcvt(
		__value: f64,
		__ndigit: ::std::os::raw::c_int,
		__buf: *mut ::std::os::raw::c_char,
	) -> *mut ::std::os::raw::c_char;
}
extern "C" {
	pub fn qecvt(
		__value: u128,
		__ndigit: ::std::os::raw::c_int,
		__decpt: *mut ::std::os::raw::c_int,
		__sign: *mut ::std::os::raw::c_int,
	) -> *mut ::std::os::raw::c_char;
}
extern "C" {
	pub fn qfcvt(
		__value: u128,
		__ndigit: ::std::os::raw::c_int,
		__decpt: *mut ::std::os::raw::c_int,
		__sign: *mut ::std::os::raw::c_int,
	) -> *mut ::std::os::raw::c_char;
}
extern "C" {
	pub fn qgcvt(
		__value: u128,
		__ndigit: ::std::os::raw::c_int,
		__buf: *mut ::std::os::raw::c_char,
	) -> *mut ::std::os::raw::c_char;
}
extern "C" {
	pub fn ecvt_r(
		__value: f64,
		__ndigit: ::std::os::raw::c_int,
		__decpt: *mut ::std::os::raw::c_int,
		__sign: *mut ::std::os::raw::c_int,
		__buf: *mut ::std::os::raw::c_char,
		__len: size_t,
	) -> ::std::os::raw::c_int;
}
extern "C" {
	pub fn fcvt_r(
		__value: f64,
		__ndigit: ::std::os::raw::c_int,
		__decpt: *mut ::std::os::raw::c_int,
		__sign: *mut ::std::os::raw::c_int,
		__buf: *mut ::std::os::raw::c_char,
		__len: size_t,
	) -> ::std::os::raw::c_int;
}
extern "C" {
	pub fn qecvt_r(
		__value: u128,
		__ndigit: ::std::os::raw::c_int,
		__decpt: *mut ::std::os::raw::c_int,
		__sign: *mut ::std::os::raw::c_int,
		__buf: *mut ::std::os::raw::c_char,
		__len: size_t,
	) -> ::std::os::raw::c_int;
}
extern "C" {
	pub fn qfcvt_r(
		__value: u128,
		__ndigit: ::std::os::raw::c_int,
		__decpt: *mut ::std::os::raw::c_int,
		__sign: *mut ::std::os::raw::c_int,
		__buf: *mut ::std::os::raw::c_char,
		__len: size_t,
	) -> ::std::os::raw::c_int;
}
extern "C" {
	pub fn mblen(__s: *const ::std::os::raw::c_char, __n: size_t) -> ::std::os::raw::c_int;
}
extern "C" {
	pub fn mbtowc(
		__pwc: *mut wchar_t,
		__s: *const ::std::os::raw::c_char,
		__n: size_t,
	) -> ::std::os::raw::c_int;
}
extern "C" {
	pub fn wctomb(__s: *mut ::std::os::raw::c_char, __wchar: wchar_t) -> ::std::os::raw::c_int;
}
extern "C" {
	pub fn mbstowcs(
		__pwcs: *mut wchar_t,
		__s: *const ::std::os::raw::c_char,
		__n: size_t,
	) -> size_t;
}
extern "C" {
	pub fn wcstombs(
		__s: *mut ::std::os::raw::c_char,
		__pwcs: *const wchar_t,
		__n: size_t,
	) -> size_t;
}
extern "C" {
	pub fn rpmatch(__response: *const ::std::os::raw::c_char) -> ::std::os::raw::c_int;
}
extern "C" {
	pub fn getsubopt(
		__optionp: *mut *mut ::std::os::raw::c_char,
		__tokens: *const *mut ::std::os::raw::c_char,
		__valuep: *mut *mut ::std::os::raw::c_char,
	) -> ::std::os::raw::c_int;
}
extern "C" {
	pub fn getloadavg(__loadavg: *mut f64, __nelem: ::std::os::raw::c_int)
		-> ::std::os::raw::c_int;
}
pub type va_list = __builtin_va_list;
pub type __gnuc_va_list = __builtin_va_list;
#[repr(C)]
pub struct __mbstate_t {
	pub __count: ::std::os::raw::c_int,
	pub __value: __mbstate_t__bindgen_ty_1,
}
#[repr(C)]
pub struct __mbstate_t__bindgen_ty_1 {
	pub __wch: __BindgenUnionField<::std::os::raw::c_uint>,
	pub __wchb: __BindgenUnionField<[::std::os::raw::c_char; 4usize]>,
	pub bindgen_union_field: u32,
}
#[test]
fn bindgen_test_layout___mbstate_t__bindgen_ty_1() {
	assert_eq!(
		::core::mem::size_of::<__mbstate_t__bindgen_ty_1>(),
		4usize,
		concat!("Size of: ", stringify!(__mbstate_t__bindgen_ty_1))
	);
	assert_eq!(
		::core::mem::align_of::<__mbstate_t__bindgen_ty_1>(),
		4usize,
		concat!("Alignment of ", stringify!(__mbstate_t__bindgen_ty_1))
	);
	assert_eq!(
		unsafe {
			&(*(::core::ptr::null::<__mbstate_t__bindgen_ty_1>())).__wch as *const _ as usize
		},
		0usize,
		concat!(
			"Offset of field: ",
			stringify!(__mbstate_t__bindgen_ty_1),
			"::",
			stringify!(__wch)
		)
	);
	assert_eq!(
		unsafe {
			&(*(::core::ptr::null::<__mbstate_t__bindgen_ty_1>())).__wchb as *const _ as usize
		},
		0usize,
		concat!(
			"Offset of field: ",
			stringify!(__mbstate_t__bindgen_ty_1),
			"::",
			stringify!(__wchb)
		)
	);
}
#[test]
fn bindgen_test_layout___mbstate_t() {
	assert_eq!(
		::core::mem::size_of::<__mbstate_t>(),
		8usize,
		concat!("Size of: ", stringify!(__mbstate_t))
	);
	assert_eq!(
		::core::mem::align_of::<__mbstate_t>(),
		4usize,
		concat!("Alignment of ", stringify!(__mbstate_t))
	);
	assert_eq!(
		unsafe { &(*(::core::ptr::null::<__mbstate_t>())).__count as *const _ as usize },
		0usize,
		concat!(
			"Offset of field: ",
			stringify!(__mbstate_t),
			"::",
			stringify!(__count)
		)
	);
	assert_eq!(
		unsafe { &(*(::core::ptr::null::<__mbstate_t>())).__value as *const _ as usize },
		4usize,
		concat!(
			"Offset of field: ",
			stringify!(__mbstate_t),
			"::",
			stringify!(__value)
		)
	);
}
#[repr(C)]
pub struct _G_fpos_t {
	pub __pos: __off_t,
	pub __state: __mbstate_t,
}
#[test]
fn bindgen_test_layout__G_fpos_t() {
	assert_eq!(
		::core::mem::size_of::<_G_fpos_t>(),
		16usize,
		concat!("Size of: ", stringify!(_G_fpos_t))
	);
	assert_eq!(
		::core::mem::align_of::<_G_fpos_t>(),
		8usize,
		concat!("Alignment of ", stringify!(_G_fpos_t))
	);
	assert_eq!(
		unsafe { &(*(::core::ptr::null::<_G_fpos_t>())).__pos as *const _ as usize },
		0usize,
		concat!(
			"Offset of field: ",
			stringify!(_G_fpos_t),
			"::",
			stringify!(__pos)
		)
	);
	assert_eq!(
		unsafe { &(*(::core::ptr::null::<_G_fpos_t>())).__state as *const _ as usize },
		8usize,
		concat!(
			"Offset of field: ",
			stringify!(_G_fpos_t),
			"::",
			stringify!(__state)
		)
	);
}
pub type __fpos_t = _G_fpos_t;
#[repr(C)]
pub struct _G_fpos64_t {
	pub __pos: __off64_t,
	pub __state: __mbstate_t,
}
#[test]
fn bindgen_test_layout__G_fpos64_t() {
	assert_eq!(
		::core::mem::size_of::<_G_fpos64_t>(),
		16usize,
		concat!("Size of: ", stringify!(_G_fpos64_t))
	);
	assert_eq!(
		::core::mem::align_of::<_G_fpos64_t>(),
		8usize,
		concat!("Alignment of ", stringify!(_G_fpos64_t))
	);
	assert_eq!(
		unsafe { &(*(::core::ptr::null::<_G_fpos64_t>())).__pos as *const _ as usize },
		0usize,
		concat!(
			"Offset of field: ",
			stringify!(_G_fpos64_t),
			"::",
			stringify!(__pos)
		)
	);
	assert_eq!(
		unsafe { &(*(::core::ptr::null::<_G_fpos64_t>())).__state as *const _ as usize },
		8usize,
		concat!(
			"Offset of field: ",
			stringify!(_G_fpos64_t),
			"::",
			stringify!(__state)
		)
	);
}
pub type __fpos64_t = _G_fpos64_t;
pub type __FILE = _IO_FILE;
pub type FILE = _IO_FILE;
#[repr(C)]
pub struct _IO_marker {
	_unused: [u8; 0],
}
#[repr(C)]
pub struct _IO_codecvt {
	_unused: [u8; 0],
}
#[repr(C)]
pub struct _IO_wide_data {
	_unused: [u8; 0],
}
pub type _IO_lock_t = ::core::ffi::c_void;
#[repr(C)]
pub struct _IO_FILE {
	pub _flags: ::std::os::raw::c_int,
	pub _IO_read_ptr: *mut ::std::os::raw::c_char,
	pub _IO_read_end: *mut ::std::os::raw::c_char,
	pub _IO_read_base: *mut ::std::os::raw::c_char,
	pub _IO_write_base: *mut ::std::os::raw::c_char,
	pub _IO_write_ptr: *mut ::std::os::raw::c_char,
	pub _IO_write_end: *mut ::std::os::raw::c_char,
	pub _IO_buf_base: *mut ::std::os::raw::c_char,
	pub _IO_buf_end: *mut ::std::os::raw::c_char,
	pub _IO_save_base: *mut ::std::os::raw::c_char,
	pub _IO_backup_base: *mut ::std::os::raw::c_char,
	pub _IO_save_end: *mut ::std::os::raw::c_char,
	pub _markers: *mut _IO_marker,
	pub _chain: *mut _IO_FILE,
	pub _fileno: ::std::os::raw::c_int,
	pub _flags2: ::std::os::raw::c_int,
	pub _old_offset: __off_t,
	pub _cur_column: ::std::os::raw::c_ushort,
	pub _vtable_offset: ::std::os::raw::c_schar,
	pub _shortbuf: [::std::os::raw::c_char; 1usize],
	pub _lock: *mut _IO_lock_t,
	pub _offset: __off64_t,
	pub _codecvt: *mut _IO_codecvt,
	pub _wide_data: *mut _IO_wide_data,
	pub _freeres_list: *mut _IO_FILE,
	pub _freeres_buf: *mut ::core::ffi::c_void,
	pub __pad5: size_t,
	pub _mode: ::std::os::raw::c_int,
	pub _unused2: [::std::os::raw::c_char; 20usize],
}
#[test]
fn bindgen_test_layout__IO_FILE() {
	assert_eq!(
		::core::mem::size_of::<_IO_FILE>(),
		216usize,
		concat!("Size of: ", stringify!(_IO_FILE))
	);
	assert_eq!(
		::core::mem::align_of::<_IO_FILE>(),
		8usize,
		concat!("Alignment of ", stringify!(_IO_FILE))
	);
	assert_eq!(
		unsafe { &(*(::core::ptr::null::<_IO_FILE>()))._flags as *const _ as usize },
		0usize,
		concat!(
			"Offset of field: ",
			stringify!(_IO_FILE),
			"::",
			stringify!(_flags)
		)
	);
	assert_eq!(
		unsafe { &(*(::core::ptr::null::<_IO_FILE>()))._IO_read_ptr as *const _ as usize },
		8usize,
		concat!(
			"Offset of field: ",
			stringify!(_IO_FILE),
			"::",
			stringify!(_IO_read_ptr)
		)
	);
	assert_eq!(
		unsafe { &(*(::core::ptr::null::<_IO_FILE>()))._IO_read_end as *const _ as usize },
		16usize,
		concat!(
			"Offset of field: ",
			stringify!(_IO_FILE),
			"::",
			stringify!(_IO_read_end)
		)
	);
	assert_eq!(
		unsafe { &(*(::core::ptr::null::<_IO_FILE>()))._IO_read_base as *const _ as usize },
		24usize,
		concat!(
			"Offset of field: ",
			stringify!(_IO_FILE),
			"::",
			stringify!(_IO_read_base)
		)
	);
	assert_eq!(
		unsafe { &(*(::core::ptr::null::<_IO_FILE>()))._IO_write_base as *const _ as usize },
		32usize,
		concat!(
			"Offset of field: ",
			stringify!(_IO_FILE),
			"::",
			stringify!(_IO_write_base)
		)
	);
	assert_eq!(
		unsafe { &(*(::core::ptr::null::<_IO_FILE>()))._IO_write_ptr as *const _ as usize },
		40usize,
		concat!(
			"Offset of field: ",
			stringify!(_IO_FILE),
			"::",
			stringify!(_IO_write_ptr)
		)
	);
	assert_eq!(
		unsafe { &(*(::core::ptr::null::<_IO_FILE>()))._IO_write_end as *const _ as usize },
		48usize,
		concat!(
			"Offset of field: ",
			stringify!(_IO_FILE),
			"::",
			stringify!(_IO_write_end)
		)
	);
	assert_eq!(
		unsafe { &(*(::core::ptr::null::<_IO_FILE>()))._IO_buf_base as *const _ as usize },
		56usize,
		concat!(
			"Offset of field: ",
			stringify!(_IO_FILE),
			"::",
			stringify!(_IO_buf_base)
		)
	);
	assert_eq!(
		unsafe { &(*(::core::ptr::null::<_IO_FILE>()))._IO_buf_end as *const _ as usize },
		64usize,
		concat!(
			"Offset of field: ",
			stringify!(_IO_FILE),
			"::",
			stringify!(_IO_buf_end)
		)
	);
	assert_eq!(
		unsafe { &(*(::core::ptr::null::<_IO_FILE>()))._IO_save_base as *const _ as usize },
		72usize,
		concat!(
			"Offset of field: ",
			stringify!(_IO_FILE),
			"::",
			stringify!(_IO_save_base)
		)
	);
	assert_eq!(
		unsafe { &(*(::core::ptr::null::<_IO_FILE>()))._IO_backup_base as *const _ as usize },
		80usize,
		concat!(
			"Offset of field: ",
			stringify!(_IO_FILE),
			"::",
			stringify!(_IO_backup_base)
		)
	);
	assert_eq!(
		unsafe { &(*(::core::ptr::null::<_IO_FILE>()))._IO_save_end as *const _ as usize },
		88usize,
		concat!(
			"Offset of field: ",
			stringify!(_IO_FILE),
			"::",
			stringify!(_IO_save_end)
		)
	);
	assert_eq!(
		unsafe { &(*(::core::ptr::null::<_IO_FILE>()))._markers as *const _ as usize },
		96usize,
		concat!(
			"Offset of field: ",
			stringify!(_IO_FILE),
			"::",
			stringify!(_markers)
		)
	);
	assert_eq!(
		unsafe { &(*(::core::ptr::null::<_IO_FILE>()))._chain as *const _ as usize },
		104usize,
		concat!(
			"Offset of field: ",
			stringify!(_IO_FILE),
			"::",
			stringify!(_chain)
		)
	);
	assert_eq!(
		unsafe { &(*(::core::ptr::null::<_IO_FILE>()))._fileno as *const _ as usize },
		112usize,
		concat!(
			"Offset of field: ",
			stringify!(_IO_FILE),
			"::",
			stringify!(_fileno)
		)
	);
	assert_eq!(
		unsafe { &(*(::core::ptr::null::<_IO_FILE>()))._flags2 as *const _ as usize },
		116usize,
		concat!(
			"Offset of field: ",
			stringify!(_IO_FILE),
			"::",
			stringify!(_flags2)
		)
	);
	assert_eq!(
		unsafe { &(*(::core::ptr::null::<_IO_FILE>()))._old_offset as *const _ as usize },
		120usize,
		concat!(
			"Offset of field: ",
			stringify!(_IO_FILE),
			"::",
			stringify!(_old_offset)
		)
	);
	assert_eq!(
		unsafe { &(*(::core::ptr::null::<_IO_FILE>()))._cur_column as *const _ as usize },
		128usize,
		concat!(
			"Offset of field: ",
			stringify!(_IO_FILE),
			"::",
			stringify!(_cur_column)
		)
	);
	assert_eq!(
		unsafe { &(*(::core::ptr::null::<_IO_FILE>()))._vtable_offset as *const _ as usize },
		130usize,
		concat!(
			"Offset of field: ",
			stringify!(_IO_FILE),
			"::",
			stringify!(_vtable_offset)
		)
	);
	assert_eq!(
		unsafe { &(*(::core::ptr::null::<_IO_FILE>()))._shortbuf as *const _ as usize },
		131usize,
		concat!(
			"Offset of field: ",
			stringify!(_IO_FILE),
			"::",
			stringify!(_shortbuf)
		)
	);
	assert_eq!(
		unsafe { &(*(::core::ptr::null::<_IO_FILE>()))._lock as *const _ as usize },
		136usize,
		concat!(
			"Offset of field: ",
			stringify!(_IO_FILE),
			"::",
			stringify!(_lock)
		)
	);
	assert_eq!(
		unsafe { &(*(::core::ptr::null::<_IO_FILE>()))._offset as *const _ as usize },
		144usize,
		concat!(
			"Offset of field: ",
			stringify!(_IO_FILE),
			"::",
			stringify!(_offset)
		)
	);
	assert_eq!(
		unsafe { &(*(::core::ptr::null::<_IO_FILE>()))._codecvt as *const _ as usize },
		152usize,
		concat!(
			"Offset of field: ",
			stringify!(_IO_FILE),
			"::",
			stringify!(_codecvt)
		)
	);
	assert_eq!(
		unsafe { &(*(::core::ptr::null::<_IO_FILE>()))._wide_data as *const _ as usize },
		160usize,
		concat!(
			"Offset of field: ",
			stringify!(_IO_FILE),
			"::",
			stringify!(_wide_data)
		)
	);
	assert_eq!(
		unsafe { &(*(::core::ptr::null::<_IO_FILE>()))._freeres_list as *const _ as usize },
		168usize,
		concat!(
			"Offset of field: ",
			stringify!(_IO_FILE),
			"::",
			stringify!(_freeres_list)
		)
	);
	assert_eq!(
		unsafe { &(*(::core::ptr::null::<_IO_FILE>()))._freeres_buf as *const _ as usize },
		176usize,
		concat!(
			"Offset of field: ",
			stringify!(_IO_FILE),
			"::",
			stringify!(_freeres_buf)
		)
	);
	assert_eq!(
		unsafe { &(*(::core::ptr::null::<_IO_FILE>())).__pad5 as *const _ as usize },
		184usize,
		concat!(
			"Offset of field: ",
			stringify!(_IO_FILE),
			"::",
			stringify!(__pad5)
		)
	);
	assert_eq!(
		unsafe { &(*(::core::ptr::null::<_IO_FILE>()))._mode as *const _ as usize },
		192usize,
		concat!(
			"Offset of field: ",
			stringify!(_IO_FILE),
			"::",
			stringify!(_mode)
		)
	);
	assert_eq!(
		unsafe { &(*(::core::ptr::null::<_IO_FILE>()))._unused2 as *const _ as usize },
		196usize,
		concat!(
			"Offset of field: ",
			stringify!(_IO_FILE),
			"::",
			stringify!(_unused2)
		)
	);
}
pub type fpos_t = __fpos_t;
extern "C" {
	pub static mut stdin: *mut FILE;
}
extern "C" {
	pub static mut stdout: *mut FILE;
}
extern "C" {
	pub static mut stderr: *mut FILE;
}
extern "C" {
	pub fn remove(__filename: *const ::std::os::raw::c_char) -> ::std::os::raw::c_int;
}
extern "C" {
	pub fn rename(
		__old: *const ::std::os::raw::c_char,
		__new: *const ::std::os::raw::c_char,
	) -> ::std::os::raw::c_int;
}
extern "C" {
	pub fn renameat(
		__oldfd: ::std::os::raw::c_int,
		__old: *const ::std::os::raw::c_char,
		__newfd: ::std::os::raw::c_int,
		__new: *const ::std::os::raw::c_char,
	) -> ::std::os::raw::c_int;
}
extern "C" {
	pub fn tmpfile() -> *mut FILE;
}
extern "C" {
	pub fn tmpnam(__s: *mut ::std::os::raw::c_char) -> *mut ::std::os::raw::c_char;
}
extern "C" {
	pub fn tmpnam_r(__s: *mut ::std::os::raw::c_char) -> *mut ::std::os::raw::c_char;
}
extern "C" {
	pub fn tempnam(
		__dir: *const ::std::os::raw::c_char,
		__pfx: *const ::std::os::raw::c_char,
	) -> *mut ::std::os::raw::c_char;
}
extern "C" {
	pub fn fclose(__stream: *mut FILE) -> ::std::os::raw::c_int;
}
extern "C" {
	pub fn fflush(__stream: *mut FILE) -> ::std::os::raw::c_int;
}
extern "C" {
	pub fn fflush_unlocked(__stream: *mut FILE) -> ::std::os::raw::c_int;
}
extern "C" {
	pub fn fopen(
		__filename: *const ::std::os::raw::c_char,
		__modes: *const ::std::os::raw::c_char,
	) -> *mut FILE;
}
extern "C" {
	pub fn freopen(
		__filename: *const ::std::os::raw::c_char,
		__modes: *const ::std::os::raw::c_char,
		__stream: *mut FILE,
	) -> *mut FILE;
}
extern "C" {
	pub fn fdopen(__fd: ::std::os::raw::c_int, __modes: *const ::std::os::raw::c_char)
		-> *mut FILE;
}
extern "C" {
	pub fn fmemopen(
		__s: *mut ::core::ffi::c_void,
		__len: size_t,
		__modes: *const ::std::os::raw::c_char,
	) -> *mut FILE;
}
extern "C" {
	pub fn open_memstream(
		__bufloc: *mut *mut ::std::os::raw::c_char,
		__sizeloc: *mut size_t,
	) -> *mut FILE;
}
extern "C" {
	pub fn setbuf(__stream: *mut FILE, __buf: *mut ::std::os::raw::c_char);
}
extern "C" {
	pub fn setvbuf(
		__stream: *mut FILE,
		__buf: *mut ::std::os::raw::c_char,
		__modes: ::std::os::raw::c_int,
		__n: size_t,
	) -> ::std::os::raw::c_int;
}
extern "C" {
	pub fn setbuffer(__stream: *mut FILE, __buf: *mut ::std::os::raw::c_char, __size: size_t);
}
extern "C" {
	pub fn setlinebuf(__stream: *mut FILE);
}
extern "C" {
	pub fn fprintf(
		__stream: *mut FILE,
		__format: *const ::std::os::raw::c_char,
		...
	) -> ::std::os::raw::c_int;
}
extern "C" {
	pub fn printf(__format: *const ::std::os::raw::c_char, ...) -> ::std::os::raw::c_int;
}
extern "C" {
	pub fn sprintf(
		__s: *mut ::std::os::raw::c_char,
		__format: *const ::std::os::raw::c_char,
		...
	) -> ::std::os::raw::c_int;
}
extern "C" {
	pub fn vfprintf(
		__s: *mut FILE,
		__format: *const ::std::os::raw::c_char,
		__arg: *mut __va_list_tag,
	) -> ::std::os::raw::c_int;
}
extern "C" {
	pub fn vprintf(
		__format: *const ::std::os::raw::c_char,
		__arg: *mut __va_list_tag,
	) -> ::std::os::raw::c_int;
}
extern "C" {
	pub fn vsprintf(
		__s: *mut ::std::os::raw::c_char,
		__format: *const ::std::os::raw::c_char,
		__arg: *mut __va_list_tag,
	) -> ::std::os::raw::c_int;
}
extern "C" {
	pub fn snprintf(
		__s: *mut ::std::os::raw::c_char,
		__maxlen: ::std::os::raw::c_ulong,
		__format: *const ::std::os::raw::c_char,
		...
	) -> ::std::os::raw::c_int;
}
extern "C" {
	pub fn vsnprintf(
		__s: *mut ::std::os::raw::c_char,
		__maxlen: ::std::os::raw::c_ulong,
		__format: *const ::std::os::raw::c_char,
		__arg: *mut __va_list_tag,
	) -> ::std::os::raw::c_int;
}
extern "C" {
	pub fn vdprintf(
		__fd: ::std::os::raw::c_int,
		__fmt: *const ::std::os::raw::c_char,
		__arg: *mut __va_list_tag,
	) -> ::std::os::raw::c_int;
}
extern "C" {
	pub fn dprintf(
		__fd: ::std::os::raw::c_int,
		__fmt: *const ::std::os::raw::c_char,
		...
	) -> ::std::os::raw::c_int;
}
extern "C" {
	pub fn fscanf(
		__stream: *mut FILE,
		__format: *const ::std::os::raw::c_char,
		...
	) -> ::std::os::raw::c_int;
}
extern "C" {
	pub fn scanf(__format: *const ::std::os::raw::c_char, ...) -> ::std::os::raw::c_int;
}
extern "C" {
	pub fn sscanf(
		__s: *const ::std::os::raw::c_char,
		__format: *const ::std::os::raw::c_char,
		...
	) -> ::std::os::raw::c_int;
}
extern "C" {
	#[link_name = "\u{1}__isoc99_fscanf"]
	pub fn fscanf1(
		__stream: *mut FILE,
		__format: *const ::std::os::raw::c_char,
		...
	) -> ::std::os::raw::c_int;
}
extern "C" {
	#[link_name = "\u{1}__isoc99_scanf"]
	pub fn scanf1(__format: *const ::std::os::raw::c_char, ...) -> ::std::os::raw::c_int;
}
extern "C" {
	#[link_name = "\u{1}__isoc99_sscanf"]
	pub fn sscanf1(
		__s: *const ::std::os::raw::c_char,
		__format: *const ::std::os::raw::c_char,
		...
	) -> ::std::os::raw::c_int;
}
extern "C" {
	pub fn vfscanf(
		__s: *mut FILE,
		__format: *const ::std::os::raw::c_char,
		__arg: *mut __va_list_tag,
	) -> ::std::os::raw::c_int;
}
extern "C" {
	pub fn vscanf(
		__format: *const ::std::os::raw::c_char,
		__arg: *mut __va_list_tag,
	) -> ::std::os::raw::c_int;
}
extern "C" {
	pub fn vsscanf(
		__s: *const ::std::os::raw::c_char,
		__format: *const ::std::os::raw::c_char,
		__arg: *mut __va_list_tag,
	) -> ::std::os::raw::c_int;
}
extern "C" {
	#[link_name = "\u{1}__isoc99_vfscanf"]
	pub fn vfscanf1(
		__s: *mut FILE,
		__format: *const ::std::os::raw::c_char,
		__arg: *mut __va_list_tag,
	) -> ::std::os::raw::c_int;
}
extern "C" {
	#[link_name = "\u{1}__isoc99_vscanf"]
	pub fn vscanf1(
		__format: *const ::std::os::raw::c_char,
		__arg: *mut __va_list_tag,
	) -> ::std::os::raw::c_int;
}
extern "C" {
	#[link_name = "\u{1}__isoc99_vsscanf"]
	pub fn vsscanf1(
		__s: *const ::std::os::raw::c_char,
		__format: *const ::std::os::raw::c_char,
		__arg: *mut __va_list_tag,
	) -> ::std::os::raw::c_int;
}
extern "C" {
	pub fn fgetc(__stream: *mut FILE) -> ::std::os::raw::c_int;
}
extern "C" {
	pub fn getc(__stream: *mut FILE) -> ::std::os::raw::c_int;
}
extern "C" {
	pub fn getchar() -> ::std::os::raw::c_int;
}
extern "C" {
	pub fn getc_unlocked(__stream: *mut FILE) -> ::std::os::raw::c_int;
}
extern "C" {
	pub fn getchar_unlocked() -> ::std::os::raw::c_int;
}
extern "C" {
	pub fn fgetc_unlocked(__stream: *mut FILE) -> ::std::os::raw::c_int;
}
extern "C" {
	pub fn fputc(__c: ::std::os::raw::c_int, __stream: *mut FILE) -> ::std::os::raw::c_int;
}
extern "C" {
	pub fn putc(__c: ::std::os::raw::c_int, __stream: *mut FILE) -> ::std::os::raw::c_int;
}
extern "C" {
	pub fn putchar(__c: ::std::os::raw::c_int) -> ::std::os::raw::c_int;
}
extern "C" {
	pub fn fputc_unlocked(__c: ::std::os::raw::c_int, __stream: *mut FILE)
		-> ::std::os::raw::c_int;
}
extern "C" {
	pub fn putc_unlocked(__c: ::std::os::raw::c_int, __stream: *mut FILE) -> ::std::os::raw::c_int;
}
extern "C" {
	pub fn putchar_unlocked(__c: ::std::os::raw::c_int) -> ::std::os::raw::c_int;
}
extern "C" {
	pub fn getw(__stream: *mut FILE) -> ::std::os::raw::c_int;
}
extern "C" {
	pub fn putw(__w: ::std::os::raw::c_int, __stream: *mut FILE) -> ::std::os::raw::c_int;
}
extern "C" {
	pub fn fgets(
		__s: *mut ::std::os::raw::c_char,
		__n: ::std::os::raw::c_int,
		__stream: *mut FILE,
	) -> *mut ::std::os::raw::c_char;
}
extern "C" {
	pub fn __getdelim(
		__lineptr: *mut *mut ::std::os::raw::c_char,
		__n: *mut size_t,
		__delimiter: ::std::os::raw::c_int,
		__stream: *mut FILE,
	) -> __ssize_t;
}
extern "C" {
	pub fn getdelim(
		__lineptr: *mut *mut ::std::os::raw::c_char,
		__n: *mut size_t,
		__delimiter: ::std::os::raw::c_int,
		__stream: *mut FILE,
	) -> __ssize_t;
}
extern "C" {
	pub fn getline(
		__lineptr: *mut *mut ::std::os::raw::c_char,
		__n: *mut size_t,
		__stream: *mut FILE,
	) -> __ssize_t;
}
extern "C" {
	pub fn fputs(__s: *const ::std::os::raw::c_char, __stream: *mut FILE) -> ::std::os::raw::c_int;
}
extern "C" {
	pub fn puts(__s: *const ::std::os::raw::c_char) -> ::std::os::raw::c_int;
}
extern "C" {
	pub fn ungetc(__c: ::std::os::raw::c_int, __stream: *mut FILE) -> ::std::os::raw::c_int;
}
extern "C" {
	pub fn fread(
		__ptr: *mut ::core::ffi::c_void,
		__size: ::std::os::raw::c_ulong,
		__n: ::std::os::raw::c_ulong,
		__stream: *mut FILE,
	) -> ::std::os::raw::c_ulong;
}
extern "C" {
	pub fn fwrite(
		__ptr: *const ::core::ffi::c_void,
		__size: ::std::os::raw::c_ulong,
		__n: ::std::os::raw::c_ulong,
		__s: *mut FILE,
	) -> ::std::os::raw::c_ulong;
}
extern "C" {
	pub fn fread_unlocked(
		__ptr: *mut ::core::ffi::c_void,
		__size: size_t,
		__n: size_t,
		__stream: *mut FILE,
	) -> size_t;
}
extern "C" {
	pub fn fwrite_unlocked(
		__ptr: *const ::core::ffi::c_void,
		__size: size_t,
		__n: size_t,
		__stream: *mut FILE,
	) -> size_t;
}
extern "C" {
	pub fn fseek(
		__stream: *mut FILE,
		__off: ::std::os::raw::c_long,
		__whence: ::std::os::raw::c_int,
	) -> ::std::os::raw::c_int;
}
extern "C" {
	pub fn ftell(__stream: *mut FILE) -> ::std::os::raw::c_long;
}
extern "C" {
	pub fn rewind(__stream: *mut FILE);
}
extern "C" {
	pub fn fseeko(
		__stream: *mut FILE,
		__off: __off_t,
		__whence: ::std::os::raw::c_int,
	) -> ::std::os::raw::c_int;
}
extern "C" {
	pub fn ftello(__stream: *mut FILE) -> __off_t;
}
extern "C" {
	pub fn fgetpos(__stream: *mut FILE, __pos: *mut fpos_t) -> ::std::os::raw::c_int;
}
extern "C" {
	pub fn fsetpos(__stream: *mut FILE, __pos: *const fpos_t) -> ::std::os::raw::c_int;
}
extern "C" {
	pub fn clearerr(__stream: *mut FILE);
}
extern "C" {
	pub fn feof(__stream: *mut FILE) -> ::std::os::raw::c_int;
}
extern "C" {
	pub fn ferror(__stream: *mut FILE) -> ::std::os::raw::c_int;
}
extern "C" {
	pub fn clearerr_unlocked(__stream: *mut FILE);
}
extern "C" {
	pub fn feof_unlocked(__stream: *mut FILE) -> ::std::os::raw::c_int;
}
extern "C" {
	pub fn ferror_unlocked(__stream: *mut FILE) -> ::std::os::raw::c_int;
}
extern "C" {
	pub fn perror(__s: *const ::std::os::raw::c_char);
}
extern "C" {
	pub static mut sys_nerr: ::std::os::raw::c_int;
}
extern "C" {
	pub static mut sys_errlist: [*const ::std::os::raw::c_char; 0usize];
}
extern "C" {
	pub fn fileno(__stream: *mut FILE) -> ::std::os::raw::c_int;
}
extern "C" {
	pub fn fileno_unlocked(__stream: *mut FILE) -> ::std::os::raw::c_int;
}
extern "C" {
	pub fn popen(
		__command: *const ::std::os::raw::c_char,
		__modes: *const ::std::os::raw::c_char,
	) -> *mut FILE;
}
extern "C" {
	pub fn pclose(__stream: *mut FILE) -> ::std::os::raw::c_int;
}
extern "C" {
	pub fn ctermid(__s: *mut ::std::os::raw::c_char) -> *mut ::std::os::raw::c_char;
}
extern "C" {
	pub fn flockfile(__stream: *mut FILE);
}
extern "C" {
	pub fn ftrylockfile(__stream: *mut FILE) -> ::std::os::raw::c_int;
}
extern "C" {
	pub fn funlockfile(__stream: *mut FILE);
}
extern "C" {
	pub fn __uflow(arg1: *mut FILE) -> ::std::os::raw::c_int;
}
extern "C" {
	pub fn __overflow(arg1: *mut FILE, arg2: ::std::os::raw::c_int) -> ::std::os::raw::c_int;
}
extern "C" {
	pub fn memcpy(
		__dest: *mut ::core::ffi::c_void,
		__src: *const ::core::ffi::c_void,
		__n: ::std::os::raw::c_ulong,
	) -> *mut ::core::ffi::c_void;
}
extern "C" {
	pub fn memmove(
		__dest: *mut ::core::ffi::c_void,
		__src: *const ::core::ffi::c_void,
		__n: ::std::os::raw::c_ulong,
	) -> *mut ::core::ffi::c_void;
}
extern "C" {
	pub fn memccpy(
		__dest: *mut ::core::ffi::c_void,
		__src: *const ::core::ffi::c_void,
		__c: ::std::os::raw::c_int,
		__n: size_t,
	) -> *mut ::core::ffi::c_void;
}
extern "C" {
	pub fn memset(
		__s: *mut ::core::ffi::c_void,
		__c: ::std::os::raw::c_int,
		__n: ::std::os::raw::c_ulong,
	) -> *mut ::core::ffi::c_void;
}
extern "C" {
	pub fn memcmp(
		__s1: *const ::core::ffi::c_void,
		__s2: *const ::core::ffi::c_void,
		__n: ::std::os::raw::c_ulong,
	) -> ::std::os::raw::c_int;
}
extern "C" {
	pub fn memchr(
		__s: *const ::core::ffi::c_void,
		__c: ::std::os::raw::c_int,
		__n: ::std::os::raw::c_ulong,
	) -> *mut ::core::ffi::c_void;
}
extern "C" {
	pub fn strcpy(
		__dest: *mut ::std::os::raw::c_char,
		__src: *const ::std::os::raw::c_char,
	) -> *mut ::std::os::raw::c_char;
}
extern "C" {
	pub fn strncpy(
		__dest: *mut ::std::os::raw::c_char,
		__src: *const ::std::os::raw::c_char,
		__n: ::std::os::raw::c_ulong,
	) -> *mut ::std::os::raw::c_char;
}
extern "C" {
	pub fn strcat(
		__dest: *mut ::std::os::raw::c_char,
		__src: *const ::std::os::raw::c_char,
	) -> *mut ::std::os::raw::c_char;
}
extern "C" {
	pub fn strncat(
		__dest: *mut ::std::os::raw::c_char,
		__src: *const ::std::os::raw::c_char,
		__n: ::std::os::raw::c_ulong,
	) -> *mut ::std::os::raw::c_char;
}
extern "C" {
	pub fn strcmp(
		__s1: *const ::std::os::raw::c_char,
		__s2: *const ::std::os::raw::c_char,
	) -> ::std::os::raw::c_int;
}
extern "C" {
	pub fn strncmp(
		__s1: *const ::std::os::raw::c_char,
		__s2: *const ::std::os::raw::c_char,
		__n: ::std::os::raw::c_ulong,
	) -> ::std::os::raw::c_int;
}
extern "C" {
	pub fn strcoll(
		__s1: *const ::std::os::raw::c_char,
		__s2: *const ::std::os::raw::c_char,
	) -> ::std::os::raw::c_int;
}
extern "C" {
	pub fn strxfrm(
		__dest: *mut ::std::os::raw::c_char,
		__src: *const ::std::os::raw::c_char,
		__n: ::std::os::raw::c_ulong,
	) -> ::std::os::raw::c_ulong;
}
#[repr(C)]
pub struct __locale_struct {
	pub __locales: [*mut __locale_data; 13usize],
	pub __ctype_b: *const ::std::os::raw::c_ushort,
	pub __ctype_tolower: *const ::std::os::raw::c_int,
	pub __ctype_toupper: *const ::std::os::raw::c_int,
	pub __names: [*const ::std::os::raw::c_char; 13usize],
}
#[test]
fn bindgen_test_layout___locale_struct() {
	assert_eq!(
		::core::mem::size_of::<__locale_struct>(),
		232usize,
		concat!("Size of: ", stringify!(__locale_struct))
	);
	assert_eq!(
		::core::mem::align_of::<__locale_struct>(),
		8usize,
		concat!("Alignment of ", stringify!(__locale_struct))
	);
	assert_eq!(
		unsafe { &(*(::core::ptr::null::<__locale_struct>())).__locales as *const _ as usize },
		0usize,
		concat!(
			"Offset of field: ",
			stringify!(__locale_struct),
			"::",
			stringify!(__locales)
		)
	);
	assert_eq!(
		unsafe { &(*(::core::ptr::null::<__locale_struct>())).__ctype_b as *const _ as usize },
		104usize,
		concat!(
			"Offset of field: ",
			stringify!(__locale_struct),
			"::",
			stringify!(__ctype_b)
		)
	);
	assert_eq!(
		unsafe {
			&(*(::core::ptr::null::<__locale_struct>())).__ctype_tolower as *const _ as usize
		},
		112usize,
		concat!(
			"Offset of field: ",
			stringify!(__locale_struct),
			"::",
			stringify!(__ctype_tolower)
		)
	);
	assert_eq!(
		unsafe {
			&(*(::core::ptr::null::<__locale_struct>())).__ctype_toupper as *const _ as usize
		},
		120usize,
		concat!(
			"Offset of field: ",
			stringify!(__locale_struct),
			"::",
			stringify!(__ctype_toupper)
		)
	);
	assert_eq!(
		unsafe { &(*(::core::ptr::null::<__locale_struct>())).__names as *const _ as usize },
		128usize,
		concat!(
			"Offset of field: ",
			stringify!(__locale_struct),
			"::",
			stringify!(__names)
		)
	);
}
pub type __locale_t = *mut __locale_struct;
pub type locale_t = __locale_t;
extern "C" {
	pub fn strcoll_l(
		__s1: *const ::std::os::raw::c_char,
		__s2: *const ::std::os::raw::c_char,
		__l: locale_t,
	) -> ::std::os::raw::c_int;
}
extern "C" {
	pub fn strxfrm_l(
		__dest: *mut ::std::os::raw::c_char,
		__src: *const ::std::os::raw::c_char,
		__n: size_t,
		__l: locale_t,
	) -> size_t;
}
extern "C" {
	pub fn strdup(__s: *const ::std::os::raw::c_char) -> *mut ::std::os::raw::c_char;
}
extern "C" {
	pub fn strndup(
		__string: *const ::std::os::raw::c_char,
		__n: ::std::os::raw::c_ulong,
	) -> *mut ::std::os::raw::c_char;
}
extern "C" {
	pub fn strchr(
		__s: *const ::std::os::raw::c_char,
		__c: ::std::os::raw::c_int,
	) -> *mut ::std::os::raw::c_char;
}
extern "C" {
	pub fn strrchr(
		__s: *const ::std::os::raw::c_char,
		__c: ::std::os::raw::c_int,
	) -> *mut ::std::os::raw::c_char;
}
extern "C" {
	pub fn strcspn(
		__s: *const ::std::os::raw::c_char,
		__reject: *const ::std::os::raw::c_char,
	) -> ::std::os::raw::c_ulong;
}
extern "C" {
	pub fn strspn(
		__s: *const ::std::os::raw::c_char,
		__accept: *const ::std::os::raw::c_char,
	) -> ::std::os::raw::c_ulong;
}
extern "C" {
	pub fn strpbrk(
		__s: *const ::std::os::raw::c_char,
		__accept: *const ::std::os::raw::c_char,
	) -> *mut ::std::os::raw::c_char;
}
extern "C" {
	pub fn strstr(
		__haystack: *const ::std::os::raw::c_char,
		__needle: *const ::std::os::raw::c_char,
	) -> *mut ::std::os::raw::c_char;
}
extern "C" {
	pub fn strtok(
		__s: *mut ::std::os::raw::c_char,
		__delim: *const ::std::os::raw::c_char,
	) -> *mut ::std::os::raw::c_char;
}
extern "C" {
	pub fn __strtok_r(
		__s: *mut ::std::os::raw::c_char,
		__delim: *const ::std::os::raw::c_char,
		__save_ptr: *mut *mut ::std::os::raw::c_char,
	) -> *mut ::std::os::raw::c_char;
}
extern "C" {
	pub fn strtok_r(
		__s: *mut ::std::os::raw::c_char,
		__delim: *const ::std::os::raw::c_char,
		__save_ptr: *mut *mut ::std::os::raw::c_char,
	) -> *mut ::std::os::raw::c_char;
}
extern "C" {
	pub fn strlen(__s: *const ::std::os::raw::c_char) -> ::std::os::raw::c_ulong;
}
extern "C" {
	pub fn strnlen(__string: *const ::std::os::raw::c_char, __maxlen: size_t) -> size_t;
}
extern "C" {
	pub fn strerror(__errnum: ::std::os::raw::c_int) -> *mut ::std::os::raw::c_char;
}
extern "C" {
	#[link_name = "\u{1}__xpg_strerror_r"]
	pub fn strerror_r(
		__errnum: ::std::os::raw::c_int,
		__buf: *mut ::std::os::raw::c_char,
		__buflen: size_t,
	) -> ::std::os::raw::c_int;
}
extern "C" {
	pub fn strerror_l(
		__errnum: ::std::os::raw::c_int,
		__l: locale_t,
	) -> *mut ::std::os::raw::c_char;
}
extern "C" {
	pub fn bcmp(
		__s1: *const ::core::ffi::c_void,
		__s2: *const ::core::ffi::c_void,
		__n: size_t,
	) -> ::std::os::raw::c_int;
}
extern "C" {
	pub fn bcopy(__src: *const ::core::ffi::c_void, __dest: *mut ::core::ffi::c_void, __n: size_t);
}
extern "C" {
	pub fn bzero(__s: *mut ::core::ffi::c_void, __n: ::std::os::raw::c_ulong);
}
extern "C" {
	pub fn index(
		__s: *const ::std::os::raw::c_char,
		__c: ::std::os::raw::c_int,
	) -> *mut ::std::os::raw::c_char;
}
extern "C" {
	pub fn rindex(
		__s: *const ::std::os::raw::c_char,
		__c: ::std::os::raw::c_int,
	) -> *mut ::std::os::raw::c_char;
}
extern "C" {
	pub fn ffs(__i: ::std::os::raw::c_int) -> ::std::os::raw::c_int;
}
extern "C" {
	pub fn ffsl(__l: ::std::os::raw::c_long) -> ::std::os::raw::c_int;
}
extern "C" {
	pub fn ffsll(__ll: ::std::os::raw::c_longlong) -> ::std::os::raw::c_int;
}
extern "C" {
	pub fn strcasecmp(
		__s1: *const ::std::os::raw::c_char,
		__s2: *const ::std::os::raw::c_char,
	) -> ::std::os::raw::c_int;
}
extern "C" {
	pub fn strncasecmp(
		__s1: *const ::std::os::raw::c_char,
		__s2: *const ::std::os::raw::c_char,
		__n: ::std::os::raw::c_ulong,
	) -> ::std::os::raw::c_int;
}
extern "C" {
	pub fn strcasecmp_l(
		__s1: *const ::std::os::raw::c_char,
		__s2: *const ::std::os::raw::c_char,
		__loc: locale_t,
	) -> ::std::os::raw::c_int;
}
extern "C" {
	pub fn strncasecmp_l(
		__s1: *const ::std::os::raw::c_char,
		__s2: *const ::std::os::raw::c_char,
		__n: size_t,
		__loc: locale_t,
	) -> ::std::os::raw::c_int;
}
extern "C" {
	pub fn explicit_bzero(__s: *mut ::core::ffi::c_void, __n: size_t);
}
extern "C" {
	pub fn strsep(
		__stringp: *mut *mut ::std::os::raw::c_char,
		__delim: *const ::std::os::raw::c_char,
	) -> *mut ::std::os::raw::c_char;
}
extern "C" {
	pub fn strsignal(__sig: ::std::os::raw::c_int) -> *mut ::std::os::raw::c_char;
}
extern "C" {
	pub fn __stpcpy(
		__dest: *mut ::std::os::raw::c_char,
		__src: *const ::std::os::raw::c_char,
	) -> *mut ::std::os::raw::c_char;
}
extern "C" {
	pub fn stpcpy(
		__dest: *mut ::std::os::raw::c_char,
		__src: *const ::std::os::raw::c_char,
	) -> *mut ::std::os::raw::c_char;
}
extern "C" {
	pub fn __stpncpy(
		__dest: *mut ::std::os::raw::c_char,
		__src: *const ::std::os::raw::c_char,
		__n: size_t,
	) -> *mut ::std::os::raw::c_char;
}
extern "C" {
	pub fn stpncpy(
		__dest: *mut ::std::os::raw::c_char,
		__src: *const ::std::os::raw::c_char,
		__n: ::std::os::raw::c_ulong,
	) -> *mut ::std::os::raw::c_char;
}
pub type JSAMPLE = ::std::os::raw::c_uchar;
pub type JCOEF = ::std::os::raw::c_short;
pub type JOCTET = ::std::os::raw::c_uchar;
pub type UINT8 = ::std::os::raw::c_uchar;
pub type UINT16 = ::std::os::raw::c_ushort;
pub type INT16 = ::std::os::raw::c_short;
pub type INT32 = ::std::os::raw::c_long;
pub type JDIMENSION = ::std::os::raw::c_uint;
pub type boolean = ::std::os::raw::c_int;
pub type JSAMPROW = *mut JSAMPLE;
pub type JSAMPARRAY = *mut JSAMPROW;
pub type JSAMPIMAGE = *mut JSAMPARRAY;
pub type JBLOCK = [JCOEF; 64usize];
pub type JBLOCKROW = *mut JBLOCK;
pub type JBLOCKARRAY = *mut JBLOCKROW;
pub type JBLOCKIMAGE = *mut JBLOCKARRAY;
pub type JCOEFPTR = *mut JCOEF;
#[repr(C)]
pub struct JQUANT_TBL {
	pub quantval: [UINT16; 64usize],
	pub sent_table: boolean,
}
#[test]
fn bindgen_test_layout_JQUANT_TBL() {
	assert_eq!(
		::core::mem::size_of::<JQUANT_TBL>(),
		132usize,
		concat!("Size of: ", stringify!(JQUANT_TBL))
	);
	assert_eq!(
		::core::mem::align_of::<JQUANT_TBL>(),
		4usize,
		concat!("Alignment of ", stringify!(JQUANT_TBL))
	);
	assert_eq!(
		unsafe { &(*(::core::ptr::null::<JQUANT_TBL>())).quantval as *const _ as usize },
		0usize,
		concat!(
			"Offset of field: ",
			stringify!(JQUANT_TBL),
			"::",
			stringify!(quantval)
		)
	);
	assert_eq!(
		unsafe { &(*(::core::ptr::null::<JQUANT_TBL>())).sent_table as *const _ as usize },
		128usize,
		concat!(
			"Offset of field: ",
			stringify!(JQUANT_TBL),
			"::",
			stringify!(sent_table)
		)
	);
}
#[repr(C)]
pub struct JHUFF_TBL {
	pub bits: [UINT8; 17usize],
	pub huffval: [UINT8; 256usize],
	pub sent_table: boolean,
}
#[test]
fn bindgen_test_layout_JHUFF_TBL() {
	assert_eq!(
		::core::mem::size_of::<JHUFF_TBL>(),
		280usize,
		concat!("Size of: ", stringify!(JHUFF_TBL))
	);
	assert_eq!(
		::core::mem::align_of::<JHUFF_TBL>(),
		4usize,
		concat!("Alignment of ", stringify!(JHUFF_TBL))
	);
	assert_eq!(
		unsafe { &(*(::core::ptr::null::<JHUFF_TBL>())).bits as *const _ as usize },
		0usize,
		concat!(
			"Offset of field: ",
			stringify!(JHUFF_TBL),
			"::",
			stringify!(bits)
		)
	);
	assert_eq!(
		unsafe { &(*(::core::ptr::null::<JHUFF_TBL>())).huffval as *const _ as usize },
		17usize,
		concat!(
			"Offset of field: ",
			stringify!(JHUFF_TBL),
			"::",
			stringify!(huffval)
		)
	);
	assert_eq!(
		unsafe { &(*(::core::ptr::null::<JHUFF_TBL>())).sent_table as *const _ as usize },
		276usize,
		concat!(
			"Offset of field: ",
			stringify!(JHUFF_TBL),
			"::",
			stringify!(sent_table)
		)
	);
}
#[repr(C)]
pub struct jpeg_component_info {
	pub component_id: ::std::os::raw::c_int,
	pub component_index: ::std::os::raw::c_int,
	pub h_samp_factor: ::std::os::raw::c_int,
	pub v_samp_factor: ::std::os::raw::c_int,
	pub quant_tbl_no: ::std::os::raw::c_int,
	pub dc_tbl_no: ::std::os::raw::c_int,
	pub ac_tbl_no: ::std::os::raw::c_int,
	pub width_in_blocks: JDIMENSION,
	pub height_in_blocks: JDIMENSION,
	pub DCT_scaled_size: ::std::os::raw::c_int,
	pub downsampled_width: JDIMENSION,
	pub downsampled_height: JDIMENSION,
	pub component_needed: boolean,
	pub MCU_width: ::std::os::raw::c_int,
	pub MCU_height: ::std::os::raw::c_int,
	pub MCU_blocks: ::std::os::raw::c_int,
	pub MCU_sample_width: ::std::os::raw::c_int,
	pub last_col_width: ::std::os::raw::c_int,
	pub last_row_height: ::std::os::raw::c_int,
	pub quant_table: *mut JQUANT_TBL,
	pub dct_table: *mut ::core::ffi::c_void,
}
#[test]
fn bindgen_test_layout_jpeg_component_info() {
	assert_eq!(
		::core::mem::size_of::<jpeg_component_info>(),
		96usize,
		concat!("Size of: ", stringify!(jpeg_component_info))
	);
	assert_eq!(
		::core::mem::align_of::<jpeg_component_info>(),
		8usize,
		concat!("Alignment of ", stringify!(jpeg_component_info))
	);
	assert_eq!(
		unsafe {
			&(*(::core::ptr::null::<jpeg_component_info>())).component_id as *const _ as usize
		},
		0usize,
		concat!(
			"Offset of field: ",
			stringify!(jpeg_component_info),
			"::",
			stringify!(component_id)
		)
	);
	assert_eq!(
		unsafe {
			&(*(::core::ptr::null::<jpeg_component_info>())).component_index as *const _ as usize
		},
		4usize,
		concat!(
			"Offset of field: ",
			stringify!(jpeg_component_info),
			"::",
			stringify!(component_index)
		)
	);
	assert_eq!(
		unsafe {
			&(*(::core::ptr::null::<jpeg_component_info>())).h_samp_factor as *const _ as usize
		},
		8usize,
		concat!(
			"Offset of field: ",
			stringify!(jpeg_component_info),
			"::",
			stringify!(h_samp_factor)
		)
	);
	assert_eq!(
		unsafe {
			&(*(::core::ptr::null::<jpeg_component_info>())).v_samp_factor as *const _ as usize
		},
		12usize,
		concat!(
			"Offset of field: ",
			stringify!(jpeg_component_info),
			"::",
			stringify!(v_samp_factor)
		)
	);
	assert_eq!(
		unsafe {
			&(*(::core::ptr::null::<jpeg_component_info>())).quant_tbl_no as *const _ as usize
		},
		16usize,
		concat!(
			"Offset of field: ",
			stringify!(jpeg_component_info),
			"::",
			stringify!(quant_tbl_no)
		)
	);
	assert_eq!(
		unsafe { &(*(::core::ptr::null::<jpeg_component_info>())).dc_tbl_no as *const _ as usize },
		20usize,
		concat!(
			"Offset of field: ",
			stringify!(jpeg_component_info),
			"::",
			stringify!(dc_tbl_no)
		)
	);
	assert_eq!(
		unsafe { &(*(::core::ptr::null::<jpeg_component_info>())).ac_tbl_no as *const _ as usize },
		24usize,
		concat!(
			"Offset of field: ",
			stringify!(jpeg_component_info),
			"::",
			stringify!(ac_tbl_no)
		)
	);
	assert_eq!(
		unsafe {
			&(*(::core::ptr::null::<jpeg_component_info>())).width_in_blocks as *const _ as usize
		},
		28usize,
		concat!(
			"Offset of field: ",
			stringify!(jpeg_component_info),
			"::",
			stringify!(width_in_blocks)
		)
	);
	assert_eq!(
		unsafe {
			&(*(::core::ptr::null::<jpeg_component_info>())).height_in_blocks as *const _ as usize
		},
		32usize,
		concat!(
			"Offset of field: ",
			stringify!(jpeg_component_info),
			"::",
			stringify!(height_in_blocks)
		)
	);
	assert_eq!(
		unsafe {
			&(*(::core::ptr::null::<jpeg_component_info>())).DCT_scaled_size as *const _ as usize
		},
		36usize,
		concat!(
			"Offset of field: ",
			stringify!(jpeg_component_info),
			"::",
			stringify!(DCT_scaled_size)
		)
	);
	assert_eq!(
		unsafe {
			&(*(::core::ptr::null::<jpeg_component_info>())).downsampled_width as *const _ as usize
		},
		40usize,
		concat!(
			"Offset of field: ",
			stringify!(jpeg_component_info),
			"::",
			stringify!(downsampled_width)
		)
	);
	assert_eq!(
		unsafe {
			&(*(::core::ptr::null::<jpeg_component_info>())).downsampled_height as *const _ as usize
		},
		44usize,
		concat!(
			"Offset of field: ",
			stringify!(jpeg_component_info),
			"::",
			stringify!(downsampled_height)
		)
	);
	assert_eq!(
		unsafe {
			&(*(::core::ptr::null::<jpeg_component_info>())).component_needed as *const _ as usize
		},
		48usize,
		concat!(
			"Offset of field: ",
			stringify!(jpeg_component_info),
			"::",
			stringify!(component_needed)
		)
	);
	assert_eq!(
		unsafe { &(*(::core::ptr::null::<jpeg_component_info>())).MCU_width as *const _ as usize },
		52usize,
		concat!(
			"Offset of field: ",
			stringify!(jpeg_component_info),
			"::",
			stringify!(MCU_width)
		)
	);
	assert_eq!(
		unsafe { &(*(::core::ptr::null::<jpeg_component_info>())).MCU_height as *const _ as usize },
		56usize,
		concat!(
			"Offset of field: ",
			stringify!(jpeg_component_info),
			"::",
			stringify!(MCU_height)
		)
	);
	assert_eq!(
		unsafe { &(*(::core::ptr::null::<jpeg_component_info>())).MCU_blocks as *const _ as usize },
		60usize,
		concat!(
			"Offset of field: ",
			stringify!(jpeg_component_info),
			"::",
			stringify!(MCU_blocks)
		)
	);
	assert_eq!(
		unsafe {
			&(*(::core::ptr::null::<jpeg_component_info>())).MCU_sample_width as *const _ as usize
		},
		64usize,
		concat!(
			"Offset of field: ",
			stringify!(jpeg_component_info),
			"::",
			stringify!(MCU_sample_width)
		)
	);
	assert_eq!(
		unsafe {
			&(*(::core::ptr::null::<jpeg_component_info>())).last_col_width as *const _ as usize
		},
		68usize,
		concat!(
			"Offset of field: ",
			stringify!(jpeg_component_info),
			"::",
			stringify!(last_col_width)
		)
	);
	assert_eq!(
		unsafe {
			&(*(::core::ptr::null::<jpeg_component_info>())).last_row_height as *const _ as usize
		},
		72usize,
		concat!(
			"Offset of field: ",
			stringify!(jpeg_component_info),
			"::",
			stringify!(last_row_height)
		)
	);
	assert_eq!(
		unsafe {
			&(*(::core::ptr::null::<jpeg_component_info>())).quant_table as *const _ as usize
		},
		80usize,
		concat!(
			"Offset of field: ",
			stringify!(jpeg_component_info),
			"::",
			stringify!(quant_table)
		)
	);
	assert_eq!(
		unsafe { &(*(::core::ptr::null::<jpeg_component_info>())).dct_table as *const _ as usize },
		88usize,
		concat!(
			"Offset of field: ",
			stringify!(jpeg_component_info),
			"::",
			stringify!(dct_table)
		)
	);
}
#[repr(C)]
pub struct jpeg_scan_info {
	pub comps_in_scan: ::std::os::raw::c_int,
	pub component_index: [::std::os::raw::c_int; 4usize],
	pub Ss: ::std::os::raw::c_int,
	pub Se: ::std::os::raw::c_int,
	pub Ah: ::std::os::raw::c_int,
	pub Al: ::std::os::raw::c_int,
}
#[test]
fn bindgen_test_layout_jpeg_scan_info() {
	assert_eq!(
		::core::mem::size_of::<jpeg_scan_info>(),
		36usize,
		concat!("Size of: ", stringify!(jpeg_scan_info))
	);
	assert_eq!(
		::core::mem::align_of::<jpeg_scan_info>(),
		4usize,
		concat!("Alignment of ", stringify!(jpeg_scan_info))
	);
	assert_eq!(
		unsafe { &(*(::core::ptr::null::<jpeg_scan_info>())).comps_in_scan as *const _ as usize },
		0usize,
		concat!(
			"Offset of field: ",
			stringify!(jpeg_scan_info),
			"::",
			stringify!(comps_in_scan)
		)
	);
	assert_eq!(
		unsafe { &(*(::core::ptr::null::<jpeg_scan_info>())).component_index as *const _ as usize },
		4usize,
		concat!(
			"Offset of field: ",
			stringify!(jpeg_scan_info),
			"::",
			stringify!(component_index)
		)
	);
	assert_eq!(
		unsafe { &(*(::core::ptr::null::<jpeg_scan_info>())).Ss as *const _ as usize },
		20usize,
		concat!(
			"Offset of field: ",
			stringify!(jpeg_scan_info),
			"::",
			stringify!(Ss)
		)
	);
	assert_eq!(
		unsafe { &(*(::core::ptr::null::<jpeg_scan_info>())).Se as *const _ as usize },
		24usize,
		concat!(
			"Offset of field: ",
			stringify!(jpeg_scan_info),
			"::",
			stringify!(Se)
		)
	);
	assert_eq!(
		unsafe { &(*(::core::ptr::null::<jpeg_scan_info>())).Ah as *const _ as usize },
		28usize,
		concat!(
			"Offset of field: ",
			stringify!(jpeg_scan_info),
			"::",
			stringify!(Ah)
		)
	);
	assert_eq!(
		unsafe { &(*(::core::ptr::null::<jpeg_scan_info>())).Al as *const _ as usize },
		32usize,
		concat!(
			"Offset of field: ",
			stringify!(jpeg_scan_info),
			"::",
			stringify!(Al)
		)
	);
}
pub type jpeg_saved_marker_ptr = *mut jpeg_marker_struct;
#[repr(C)]
pub struct jpeg_marker_struct {
	pub next: jpeg_saved_marker_ptr,
	pub marker: UINT8,
	pub original_length: ::std::os::raw::c_uint,
	pub data_length: ::std::os::raw::c_uint,
	pub data: *mut JOCTET,
}
#[test]
fn bindgen_test_layout_jpeg_marker_struct() {
	assert_eq!(
		::core::mem::size_of::<jpeg_marker_struct>(),
		32usize,
		concat!("Size of: ", stringify!(jpeg_marker_struct))
	);
	assert_eq!(
		::core::mem::align_of::<jpeg_marker_struct>(),
		8usize,
		concat!("Alignment of ", stringify!(jpeg_marker_struct))
	);
	assert_eq!(
		unsafe { &(*(::core::ptr::null::<jpeg_marker_struct>())).next as *const _ as usize },
		0usize,
		concat!(
			"Offset of field: ",
			stringify!(jpeg_marker_struct),
			"::",
			stringify!(next)
		)
	);
	assert_eq!(
		unsafe { &(*(::core::ptr::null::<jpeg_marker_struct>())).marker as *const _ as usize },
		8usize,
		concat!(
			"Offset of field: ",
			stringify!(jpeg_marker_struct),
			"::",
			stringify!(marker)
		)
	);
	assert_eq!(
		unsafe {
			&(*(::core::ptr::null::<jpeg_marker_struct>())).original_length as *const _ as usize
		},
		12usize,
		concat!(
			"Offset of field: ",
			stringify!(jpeg_marker_struct),
			"::",
			stringify!(original_length)
		)
	);
	assert_eq!(
		unsafe { &(*(::core::ptr::null::<jpeg_marker_struct>())).data_length as *const _ as usize },
		16usize,
		concat!(
			"Offset of field: ",
			stringify!(jpeg_marker_struct),
			"::",
			stringify!(data_length)
		)
	);
	assert_eq!(
		unsafe { &(*(::core::ptr::null::<jpeg_marker_struct>())).data as *const _ as usize },
		24usize,
		concat!(
			"Offset of field: ",
			stringify!(jpeg_marker_struct),
			"::",
			stringify!(data)
		)
	);
}
pub const J_COLOR_SPACE_JCS_UNKNOWN: J_COLOR_SPACE = 0;
pub const J_COLOR_SPACE_JCS_GRAYSCALE: J_COLOR_SPACE = 1;
pub const J_COLOR_SPACE_JCS_RGB: J_COLOR_SPACE = 2;
pub const J_COLOR_SPACE_JCS_YCbCr: J_COLOR_SPACE = 3;
pub const J_COLOR_SPACE_JCS_CMYK: J_COLOR_SPACE = 4;
pub const J_COLOR_SPACE_JCS_YCCK: J_COLOR_SPACE = 5;
pub const J_COLOR_SPACE_JCS_EXT_RGB: J_COLOR_SPACE = 6;
pub const J_COLOR_SPACE_JCS_EXT_RGBX: J_COLOR_SPACE = 7;
pub const J_COLOR_SPACE_JCS_EXT_BGR: J_COLOR_SPACE = 8;
pub const J_COLOR_SPACE_JCS_EXT_BGRX: J_COLOR_SPACE = 9;
pub const J_COLOR_SPACE_JCS_EXT_XBGR: J_COLOR_SPACE = 10;
pub const J_COLOR_SPACE_JCS_EXT_XRGB: J_COLOR_SPACE = 11;
pub const J_COLOR_SPACE_JCS_EXT_RGBA: J_COLOR_SPACE = 12;
pub const J_COLOR_SPACE_JCS_EXT_BGRA: J_COLOR_SPACE = 13;
pub const J_COLOR_SPACE_JCS_EXT_ABGR: J_COLOR_SPACE = 14;
pub const J_COLOR_SPACE_JCS_EXT_ARGB: J_COLOR_SPACE = 15;
pub const J_COLOR_SPACE_JCS_RGB565: J_COLOR_SPACE = 16;
pub type J_COLOR_SPACE = u32;
pub const J_DCT_METHOD_JDCT_ISLOW: J_DCT_METHOD = 0;
pub const J_DCT_METHOD_JDCT_IFAST: J_DCT_METHOD = 1;
pub const J_DCT_METHOD_JDCT_FLOAT: J_DCT_METHOD = 2;
pub type J_DCT_METHOD = u32;
pub const J_DITHER_MODE_JDITHER_NONE: J_DITHER_MODE = 0;
pub const J_DITHER_MODE_JDITHER_ORDERED: J_DITHER_MODE = 1;
pub const J_DITHER_MODE_JDITHER_FS: J_DITHER_MODE = 2;
pub type J_DITHER_MODE = u32;
pub const J_BOOLEAN_PARAM_JBOOLEAN_OPTIMIZE_SCANS: J_BOOLEAN_PARAM = 1745618462;
pub const J_BOOLEAN_PARAM_JBOOLEAN_TRELLIS_QUANT: J_BOOLEAN_PARAM = 3306299443;
pub const J_BOOLEAN_PARAM_JBOOLEAN_TRELLIS_QUANT_DC: J_BOOLEAN_PARAM = 865946636;
pub const J_BOOLEAN_PARAM_JBOOLEAN_TRELLIS_EOB_OPT: J_BOOLEAN_PARAM = 3623303040;
pub const J_BOOLEAN_PARAM_JBOOLEAN_USE_LAMBDA_WEIGHT_TBL: J_BOOLEAN_PARAM = 865973855;
pub const J_BOOLEAN_PARAM_JBOOLEAN_USE_SCANS_IN_TRELLIS: J_BOOLEAN_PARAM = 4253291573;
pub const J_BOOLEAN_PARAM_JBOOLEAN_TRELLIS_Q_OPT: J_BOOLEAN_PARAM = 3777684073;
pub const J_BOOLEAN_PARAM_JBOOLEAN_OVERSHOOT_DERINGING: J_BOOLEAN_PARAM = 1061927929;
pub type J_BOOLEAN_PARAM = u32;
pub const J_FLOAT_PARAM_JFLOAT_LAMBDA_LOG_SCALE1: J_FLOAT_PARAM = 1533126041;
pub const J_FLOAT_PARAM_JFLOAT_LAMBDA_LOG_SCALE2: J_FLOAT_PARAM = 3116084739;
pub const J_FLOAT_PARAM_JFLOAT_TRELLIS_DELTA_DC_WEIGHT: J_FLOAT_PARAM = 326587475;
pub type J_FLOAT_PARAM = u32;
pub const J_INT_PARAM_JINT_COMPRESS_PROFILE: J_INT_PARAM = 3918628389;
pub const J_INT_PARAM_JINT_TRELLIS_FREQ_SPLIT: J_INT_PARAM = 1873801511;
pub const J_INT_PARAM_JINT_TRELLIS_NUM_LOOPS: J_INT_PARAM = 3057565497;
pub const J_INT_PARAM_JINT_BASE_QUANT_TBL_IDX: J_INT_PARAM = 1145645745;
pub const J_INT_PARAM_JINT_DC_SCAN_OPT_MODE: J_INT_PARAM = 199732540;
pub type J_INT_PARAM = u32;
pub const JCP_MAX_COMPRESSION: _bindgen_ty_1 = 1560820397;
pub const JCP_FASTEST: _bindgen_ty_1 = 720002228;
pub type _bindgen_ty_1 = u32;
#[repr(C)]
pub struct jpeg_common_struct {
	pub err: *mut jpeg_error_mgr,
	pub mem: *mut jpeg_memory_mgr,
	pub progress: *mut jpeg_progress_mgr,
	pub client_data: *mut ::core::ffi::c_void,
	pub is_decompressor: boolean,
	pub global_state: ::std::os::raw::c_int,
}
#[test]
fn bindgen_test_layout_jpeg_common_struct() {
	assert_eq!(
		::core::mem::size_of::<jpeg_common_struct>(),
		40usize,
		concat!("Size of: ", stringify!(jpeg_common_struct))
	);
	assert_eq!(
		::core::mem::align_of::<jpeg_common_struct>(),
		8usize,
		concat!("Alignment of ", stringify!(jpeg_common_struct))
	);
	assert_eq!(
		unsafe { &(*(::core::ptr::null::<jpeg_common_struct>())).err as *const _ as usize },
		0usize,
		concat!(
			"Offset of field: ",
			stringify!(jpeg_common_struct),
			"::",
			stringify!(err)
		)
	);
	assert_eq!(
		unsafe { &(*(::core::ptr::null::<jpeg_common_struct>())).mem as *const _ as usize },
		8usize,
		concat!(
			"Offset of field: ",
			stringify!(jpeg_common_struct),
			"::",
			stringify!(mem)
		)
	);
	assert_eq!(
		unsafe { &(*(::core::ptr::null::<jpeg_common_struct>())).progress as *const _ as usize },
		16usize,
		concat!(
			"Offset of field: ",
			stringify!(jpeg_common_struct),
			"::",
			stringify!(progress)
		)
	);
	assert_eq!(
		unsafe { &(*(::core::ptr::null::<jpeg_common_struct>())).client_data as *const _ as usize },
		24usize,
		concat!(
			"Offset of field: ",
			stringify!(jpeg_common_struct),
			"::",
			stringify!(client_data)
		)
	);
	assert_eq!(
		unsafe {
			&(*(::core::ptr::null::<jpeg_common_struct>())).is_decompressor as *const _ as usize
		},
		32usize,
		concat!(
			"Offset of field: ",
			stringify!(jpeg_common_struct),
			"::",
			stringify!(is_decompressor)
		)
	);
	assert_eq!(
		unsafe {
			&(*(::core::ptr::null::<jpeg_common_struct>())).global_state as *const _ as usize
		},
		36usize,
		concat!(
			"Offset of field: ",
			stringify!(jpeg_common_struct),
			"::",
			stringify!(global_state)
		)
	);
}
pub type j_common_ptr = *mut jpeg_common_struct;
pub type j_compress_ptr = *mut jpeg_compress_struct;
pub type j_decompress_ptr = *mut jpeg_decompress_struct;
#[repr(C)]
pub struct jpeg_compress_struct {
	pub err: *mut jpeg_error_mgr,
	pub mem: *mut jpeg_memory_mgr,
	pub progress: *mut jpeg_progress_mgr,
	pub client_data: *mut ::core::ffi::c_void,
	pub is_decompressor: boolean,
	pub global_state: ::std::os::raw::c_int,
	pub dest: *mut jpeg_destination_mgr,
	pub image_width: JDIMENSION,
	pub image_height: JDIMENSION,
	pub input_components: ::std::os::raw::c_int,
	pub in_color_space: J_COLOR_SPACE,
	pub input_gamma: f64,
	pub data_precision: ::std::os::raw::c_int,
	pub num_components: ::std::os::raw::c_int,
	pub jpeg_color_space: J_COLOR_SPACE,
	pub comp_info: *mut jpeg_component_info,
	pub quant_tbl_ptrs: [*mut JQUANT_TBL; 4usize],
	pub dc_huff_tbl_ptrs: [*mut JHUFF_TBL; 4usize],
	pub ac_huff_tbl_ptrs: [*mut JHUFF_TBL; 4usize],
	pub arith_dc_L: [UINT8; 16usize],
	pub arith_dc_U: [UINT8; 16usize],
	pub arith_ac_K: [UINT8; 16usize],
	pub num_scans: ::std::os::raw::c_int,
	pub scan_info: *const jpeg_scan_info,
	pub raw_data_in: boolean,
	pub arith_code: boolean,
	pub optimize_coding: boolean,
	pub CCIR601_sampling: boolean,
	pub smoothing_factor: ::std::os::raw::c_int,
	pub dct_method: J_DCT_METHOD,
	pub restart_interval: ::std::os::raw::c_uint,
	pub restart_in_rows: ::std::os::raw::c_int,
	pub write_JFIF_header: boolean,
	pub JFIF_major_version: UINT8,
	pub JFIF_minor_version: UINT8,
	pub density_unit: UINT8,
	pub X_density: UINT16,
	pub Y_density: UINT16,
	pub write_Adobe_marker: boolean,
	pub next_scanline: JDIMENSION,
	pub progressive_mode: boolean,
	pub max_h_samp_factor: ::std::os::raw::c_int,
	pub max_v_samp_factor: ::std::os::raw::c_int,
	pub total_iMCU_rows: JDIMENSION,
	pub comps_in_scan: ::std::os::raw::c_int,
	pub cur_comp_info: [*mut jpeg_component_info; 4usize],
	pub MCUs_per_row: JDIMENSION,
	pub MCU_rows_in_scan: JDIMENSION,
	pub blocks_in_MCU: ::std::os::raw::c_int,
	pub MCU_membership: [::std::os::raw::c_int; 10usize],
	pub Ss: ::std::os::raw::c_int,
	pub Se: ::std::os::raw::c_int,
	pub Ah: ::std::os::raw::c_int,
	pub Al: ::std::os::raw::c_int,
	pub master: *mut jpeg_comp_master,
	pub main: *mut jpeg_c_main_controller,
	pub prep: *mut jpeg_c_prep_controller,
	pub coef: *mut jpeg_c_coef_controller,
	pub marker: *mut jpeg_marker_writer,
	pub cconvert: *mut jpeg_color_converter,
	pub downsample: *mut jpeg_downsampler,
	pub fdct: *mut jpeg_forward_dct,
	pub entropy: *mut jpeg_entropy_encoder,
	pub script_space: *mut jpeg_scan_info,
	pub script_space_size: ::std::os::raw::c_int,
}
#[test]
fn bindgen_test_layout_jpeg_compress_struct() {
	assert_eq!(
		::core::mem::size_of::<jpeg_compress_struct>(),
		520usize,
		concat!("Size of: ", stringify!(jpeg_compress_struct))
	);
	assert_eq!(
		::core::mem::align_of::<jpeg_compress_struct>(),
		8usize,
		concat!("Alignment of ", stringify!(jpeg_compress_struct))
	);
	assert_eq!(
		unsafe { &(*(::core::ptr::null::<jpeg_compress_struct>())).err as *const _ as usize },
		0usize,
		concat!(
			"Offset of field: ",
			stringify!(jpeg_compress_struct),
			"::",
			stringify!(err)
		)
	);
	assert_eq!(
		unsafe { &(*(::core::ptr::null::<jpeg_compress_struct>())).mem as *const _ as usize },
		8usize,
		concat!(
			"Offset of field: ",
			stringify!(jpeg_compress_struct),
			"::",
			stringify!(mem)
		)
	);
	assert_eq!(
		unsafe { &(*(::core::ptr::null::<jpeg_compress_struct>())).progress as *const _ as usize },
		16usize,
		concat!(
			"Offset of field: ",
			stringify!(jpeg_compress_struct),
			"::",
			stringify!(progress)
		)
	);
	assert_eq!(
		unsafe {
			&(*(::core::ptr::null::<jpeg_compress_struct>())).client_data as *const _ as usize
		},
		24usize,
		concat!(
			"Offset of field: ",
			stringify!(jpeg_compress_struct),
			"::",
			stringify!(client_data)
		)
	);
	assert_eq!(
		unsafe {
			&(*(::core::ptr::null::<jpeg_compress_struct>())).is_decompressor as *const _ as usize
		},
		32usize,
		concat!(
			"Offset of field: ",
			stringify!(jpeg_compress_struct),
			"::",
			stringify!(is_decompressor)
		)
	);
	assert_eq!(
		unsafe {
			&(*(::core::ptr::null::<jpeg_compress_struct>())).global_state as *const _ as usize
		},
		36usize,
		concat!(
			"Offset of field: ",
			stringify!(jpeg_compress_struct),
			"::",
			stringify!(global_state)
		)
	);
	assert_eq!(
		unsafe { &(*(::core::ptr::null::<jpeg_compress_struct>())).dest as *const _ as usize },
		40usize,
		concat!(
			"Offset of field: ",
			stringify!(jpeg_compress_struct),
			"::",
			stringify!(dest)
		)
	);
	assert_eq!(
		unsafe {
			&(*(::core::ptr::null::<jpeg_compress_struct>())).image_width as *const _ as usize
		},
		48usize,
		concat!(
			"Offset of field: ",
			stringify!(jpeg_compress_struct),
			"::",
			stringify!(image_width)
		)
	);
	assert_eq!(
		unsafe {
			&(*(::core::ptr::null::<jpeg_compress_struct>())).image_height as *const _ as usize
		},
		52usize,
		concat!(
			"Offset of field: ",
			stringify!(jpeg_compress_struct),
			"::",
			stringify!(image_height)
		)
	);
	assert_eq!(
		unsafe {
			&(*(::core::ptr::null::<jpeg_compress_struct>())).input_components as *const _ as usize
		},
		56usize,
		concat!(
			"Offset of field: ",
			stringify!(jpeg_compress_struct),
			"::",
			stringify!(input_components)
		)
	);
	assert_eq!(
		unsafe {
			&(*(::core::ptr::null::<jpeg_compress_struct>())).in_color_space as *const _ as usize
		},
		60usize,
		concat!(
			"Offset of field: ",
			stringify!(jpeg_compress_struct),
			"::",
			stringify!(in_color_space)
		)
	);
	assert_eq!(
		unsafe {
			&(*(::core::ptr::null::<jpeg_compress_struct>())).input_gamma as *const _ as usize
		},
		64usize,
		concat!(
			"Offset of field: ",
			stringify!(jpeg_compress_struct),
			"::",
			stringify!(input_gamma)
		)
	);
	assert_eq!(
		unsafe {
			&(*(::core::ptr::null::<jpeg_compress_struct>())).data_precision as *const _ as usize
		},
		72usize,
		concat!(
			"Offset of field: ",
			stringify!(jpeg_compress_struct),
			"::",
			stringify!(data_precision)
		)
	);
	assert_eq!(
		unsafe {
			&(*(::core::ptr::null::<jpeg_compress_struct>())).num_components as *const _ as usize
		},
		76usize,
		concat!(
			"Offset of field: ",
			stringify!(jpeg_compress_struct),
			"::",
			stringify!(num_components)
		)
	);
	assert_eq!(
		unsafe {
			&(*(::core::ptr::null::<jpeg_compress_struct>())).jpeg_color_space as *const _ as usize
		},
		80usize,
		concat!(
			"Offset of field: ",
			stringify!(jpeg_compress_struct),
			"::",
			stringify!(jpeg_color_space)
		)
	);
	assert_eq!(
		unsafe { &(*(::core::ptr::null::<jpeg_compress_struct>())).comp_info as *const _ as usize },
		88usize,
		concat!(
			"Offset of field: ",
			stringify!(jpeg_compress_struct),
			"::",
			stringify!(comp_info)
		)
	);
	assert_eq!(
		unsafe {
			&(*(::core::ptr::null::<jpeg_compress_struct>())).quant_tbl_ptrs as *const _ as usize
		},
		96usize,
		concat!(
			"Offset of field: ",
			stringify!(jpeg_compress_struct),
			"::",
			stringify!(quant_tbl_ptrs)
		)
	);
	assert_eq!(
		unsafe {
			&(*(::core::ptr::null::<jpeg_compress_struct>())).dc_huff_tbl_ptrs as *const _ as usize
		},
		128usize,
		concat!(
			"Offset of field: ",
			stringify!(jpeg_compress_struct),
			"::",
			stringify!(dc_huff_tbl_ptrs)
		)
	);
	assert_eq!(
		unsafe {
			&(*(::core::ptr::null::<jpeg_compress_struct>())).ac_huff_tbl_ptrs as *const _ as usize
		},
		160usize,
		concat!(
			"Offset of field: ",
			stringify!(jpeg_compress_struct),
			"::",
			stringify!(ac_huff_tbl_ptrs)
		)
	);
	assert_eq!(
		unsafe {
			&(*(::core::ptr::null::<jpeg_compress_struct>())).arith_dc_L as *const _ as usize
		},
		192usize,
		concat!(
			"Offset of field: ",
			stringify!(jpeg_compress_struct),
			"::",
			stringify!(arith_dc_L)
		)
	);
	assert_eq!(
		unsafe {
			&(*(::core::ptr::null::<jpeg_compress_struct>())).arith_dc_U as *const _ as usize
		},
		208usize,
		concat!(
			"Offset of field: ",
			stringify!(jpeg_compress_struct),
			"::",
			stringify!(arith_dc_U)
		)
	);
	assert_eq!(
		unsafe {
			&(*(::core::ptr::null::<jpeg_compress_struct>())).arith_ac_K as *const _ as usize
		},
		224usize,
		concat!(
			"Offset of field: ",
			stringify!(jpeg_compress_struct),
			"::",
			stringify!(arith_ac_K)
		)
	);
	assert_eq!(
		unsafe { &(*(::core::ptr::null::<jpeg_compress_struct>())).num_scans as *const _ as usize },
		240usize,
		concat!(
			"Offset of field: ",
			stringify!(jpeg_compress_struct),
			"::",
			stringify!(num_scans)
		)
	);
	assert_eq!(
		unsafe { &(*(::core::ptr::null::<jpeg_compress_struct>())).scan_info as *const _ as usize },
		248usize,
		concat!(
			"Offset of field: ",
			stringify!(jpeg_compress_struct),
			"::",
			stringify!(scan_info)
		)
	);
	assert_eq!(
		unsafe {
			&(*(::core::ptr::null::<jpeg_compress_struct>())).raw_data_in as *const _ as usize
		},
		256usize,
		concat!(
			"Offset of field: ",
			stringify!(jpeg_compress_struct),
			"::",
			stringify!(raw_data_in)
		)
	);
	assert_eq!(
		unsafe {
			&(*(::core::ptr::null::<jpeg_compress_struct>())).arith_code as *const _ as usize
		},
		260usize,
		concat!(
			"Offset of field: ",
			stringify!(jpeg_compress_struct),
			"::",
			stringify!(arith_code)
		)
	);
	assert_eq!(
		unsafe {
			&(*(::core::ptr::null::<jpeg_compress_struct>())).optimize_coding as *const _ as usize
		},
		264usize,
		concat!(
			"Offset of field: ",
			stringify!(jpeg_compress_struct),
			"::",
			stringify!(optimize_coding)
		)
	);
	assert_eq!(
		unsafe {
			&(*(::core::ptr::null::<jpeg_compress_struct>())).CCIR601_sampling as *const _ as usize
		},
		268usize,
		concat!(
			"Offset of field: ",
			stringify!(jpeg_compress_struct),
			"::",
			stringify!(CCIR601_sampling)
		)
	);
	assert_eq!(
		unsafe {
			&(*(::core::ptr::null::<jpeg_compress_struct>())).smoothing_factor as *const _ as usize
		},
		272usize,
		concat!(
			"Offset of field: ",
			stringify!(jpeg_compress_struct),
			"::",
			stringify!(smoothing_factor)
		)
	);
	assert_eq!(
		unsafe {
			&(*(::core::ptr::null::<jpeg_compress_struct>())).dct_method as *const _ as usize
		},
		276usize,
		concat!(
			"Offset of field: ",
			stringify!(jpeg_compress_struct),
			"::",
			stringify!(dct_method)
		)
	);
	assert_eq!(
		unsafe {
			&(*(::core::ptr::null::<jpeg_compress_struct>())).restart_interval as *const _ as usize
		},
		280usize,
		concat!(
			"Offset of field: ",
			stringify!(jpeg_compress_struct),
			"::",
			stringify!(restart_interval)
		)
	);
	assert_eq!(
		unsafe {
			&(*(::core::ptr::null::<jpeg_compress_struct>())).restart_in_rows as *const _ as usize
		},
		284usize,
		concat!(
			"Offset of field: ",
			stringify!(jpeg_compress_struct),
			"::",
			stringify!(restart_in_rows)
		)
	);
	assert_eq!(
		unsafe {
			&(*(::core::ptr::null::<jpeg_compress_struct>())).write_JFIF_header as *const _ as usize
		},
		288usize,
		concat!(
			"Offset of field: ",
			stringify!(jpeg_compress_struct),
			"::",
			stringify!(write_JFIF_header)
		)
	);
	assert_eq!(
		unsafe {
			&(*(::core::ptr::null::<jpeg_compress_struct>())).JFIF_major_version as *const _
				as usize
		},
		292usize,
		concat!(
			"Offset of field: ",
			stringify!(jpeg_compress_struct),
			"::",
			stringify!(JFIF_major_version)
		)
	);
	assert_eq!(
		unsafe {
			&(*(::core::ptr::null::<jpeg_compress_struct>())).JFIF_minor_version as *const _
				as usize
		},
		293usize,
		concat!(
			"Offset of field: ",
			stringify!(jpeg_compress_struct),
			"::",
			stringify!(JFIF_minor_version)
		)
	);
	assert_eq!(
		unsafe {
			&(*(::core::ptr::null::<jpeg_compress_struct>())).density_unit as *const _ as usize
		},
		294usize,
		concat!(
			"Offset of field: ",
			stringify!(jpeg_compress_struct),
			"::",
			stringify!(density_unit)
		)
	);
	assert_eq!(
		unsafe { &(*(::core::ptr::null::<jpeg_compress_struct>())).X_density as *const _ as usize },
		296usize,
		concat!(
			"Offset of field: ",
			stringify!(jpeg_compress_struct),
			"::",
			stringify!(X_density)
		)
	);
	assert_eq!(
		unsafe { &(*(::core::ptr::null::<jpeg_compress_struct>())).Y_density as *const _ as usize },
		298usize,
		concat!(
			"Offset of field: ",
			stringify!(jpeg_compress_struct),
			"::",
			stringify!(Y_density)
		)
	);
	assert_eq!(
		unsafe {
			&(*(::core::ptr::null::<jpeg_compress_struct>())).write_Adobe_marker as *const _
				as usize
		},
		300usize,
		concat!(
			"Offset of field: ",
			stringify!(jpeg_compress_struct),
			"::",
			stringify!(write_Adobe_marker)
		)
	);
	assert_eq!(
		unsafe {
			&(*(::core::ptr::null::<jpeg_compress_struct>())).next_scanline as *const _ as usize
		},
		304usize,
		concat!(
			"Offset of field: ",
			stringify!(jpeg_compress_struct),
			"::",
			stringify!(next_scanline)
		)
	);
	assert_eq!(
		unsafe {
			&(*(::core::ptr::null::<jpeg_compress_struct>())).progressive_mode as *const _ as usize
		},
		308usize,
		concat!(
			"Offset of field: ",
			stringify!(jpeg_compress_struct),
			"::",
			stringify!(progressive_mode)
		)
	);
	assert_eq!(
		unsafe {
			&(*(::core::ptr::null::<jpeg_compress_struct>())).max_h_samp_factor as *const _ as usize
		},
		312usize,
		concat!(
			"Offset of field: ",
			stringify!(jpeg_compress_struct),
			"::",
			stringify!(max_h_samp_factor)
		)
	);
	assert_eq!(
		unsafe {
			&(*(::core::ptr::null::<jpeg_compress_struct>())).max_v_samp_factor as *const _ as usize
		},
		316usize,
		concat!(
			"Offset of field: ",
			stringify!(jpeg_compress_struct),
			"::",
			stringify!(max_v_samp_factor)
		)
	);
	assert_eq!(
		unsafe {
			&(*(::core::ptr::null::<jpeg_compress_struct>())).total_iMCU_rows as *const _ as usize
		},
		320usize,
		concat!(
			"Offset of field: ",
			stringify!(jpeg_compress_struct),
			"::",
			stringify!(total_iMCU_rows)
		)
	);
	assert_eq!(
		unsafe {
			&(*(::core::ptr::null::<jpeg_compress_struct>())).comps_in_scan as *const _ as usize
		},
		324usize,
		concat!(
			"Offset of field: ",
			stringify!(jpeg_compress_struct),
			"::",
			stringify!(comps_in_scan)
		)
	);
	assert_eq!(
		unsafe {
			&(*(::core::ptr::null::<jpeg_compress_struct>())).cur_comp_info as *const _ as usize
		},
		328usize,
		concat!(
			"Offset of field: ",
			stringify!(jpeg_compress_struct),
			"::",
			stringify!(cur_comp_info)
		)
	);
	assert_eq!(
		unsafe {
			&(*(::core::ptr::null::<jpeg_compress_struct>())).MCUs_per_row as *const _ as usize
		},
		360usize,
		concat!(
			"Offset of field: ",
			stringify!(jpeg_compress_struct),
			"::",
			stringify!(MCUs_per_row)
		)
	);
	assert_eq!(
		unsafe {
			&(*(::core::ptr::null::<jpeg_compress_struct>())).MCU_rows_in_scan as *const _ as usize
		},
		364usize,
		concat!(
			"Offset of field: ",
			stringify!(jpeg_compress_struct),
			"::",
			stringify!(MCU_rows_in_scan)
		)
	);
	assert_eq!(
		unsafe {
			&(*(::core::ptr::null::<jpeg_compress_struct>())).blocks_in_MCU as *const _ as usize
		},
		368usize,
		concat!(
			"Offset of field: ",
			stringify!(jpeg_compress_struct),
			"::",
			stringify!(blocks_in_MCU)
		)
	);
	assert_eq!(
		unsafe {
			&(*(::core::ptr::null::<jpeg_compress_struct>())).MCU_membership as *const _ as usize
		},
		372usize,
		concat!(
			"Offset of field: ",
			stringify!(jpeg_compress_struct),
			"::",
			stringify!(MCU_membership)
		)
	);
	assert_eq!(
		unsafe { &(*(::core::ptr::null::<jpeg_compress_struct>())).Ss as *const _ as usize },
		412usize,
		concat!(
			"Offset of field: ",
			stringify!(jpeg_compress_struct),
			"::",
			stringify!(Ss)
		)
	);
	assert_eq!(
		unsafe { &(*(::core::ptr::null::<jpeg_compress_struct>())).Se as *const _ as usize },
		416usize,
		concat!(
			"Offset of field: ",
			stringify!(jpeg_compress_struct),
			"::",
			stringify!(Se)
		)
	);
	assert_eq!(
		unsafe { &(*(::core::ptr::null::<jpeg_compress_struct>())).Ah as *const _ as usize },
		420usize,
		concat!(
			"Offset of field: ",
			stringify!(jpeg_compress_struct),
			"::",
			stringify!(Ah)
		)
	);
	assert_eq!(
		unsafe { &(*(::core::ptr::null::<jpeg_compress_struct>())).Al as *const _ as usize },
		424usize,
		concat!(
			"Offset of field: ",
			stringify!(jpeg_compress_struct),
			"::",
			stringify!(Al)
		)
	);
	assert_eq!(
		unsafe { &(*(::core::ptr::null::<jpeg_compress_struct>())).master as *const _ as usize },
		432usize,
		concat!(
			"Offset of field: ",
			stringify!(jpeg_compress_struct),
			"::",
			stringify!(master)
		)
	);
	assert_eq!(
		unsafe { &(*(::core::ptr::null::<jpeg_compress_struct>())).main as *const _ as usize },
		440usize,
		concat!(
			"Offset of field: ",
			stringify!(jpeg_compress_struct),
			"::",
			stringify!(main)
		)
	);
	assert_eq!(
		unsafe { &(*(::core::ptr::null::<jpeg_compress_struct>())).prep as *const _ as usize },
		448usize,
		concat!(
			"Offset of field: ",
			stringify!(jpeg_compress_struct),
			"::",
			stringify!(prep)
		)
	);
	assert_eq!(
		unsafe { &(*(::core::ptr::null::<jpeg_compress_struct>())).coef as *const _ as usize },
		456usize,
		concat!(
			"Offset of field: ",
			stringify!(jpeg_compress_struct),
			"::",
			stringify!(coef)
		)
	);
	assert_eq!(
		unsafe { &(*(::core::ptr::null::<jpeg_compress_struct>())).marker as *const _ as usize },
		464usize,
		concat!(
			"Offset of field: ",
			stringify!(jpeg_compress_struct),
			"::",
			stringify!(marker)
		)
	);
	assert_eq!(
		unsafe { &(*(::core::ptr::null::<jpeg_compress_struct>())).cconvert as *const _ as usize },
		472usize,
		concat!(
			"Offset of field: ",
			stringify!(jpeg_compress_struct),
			"::",
			stringify!(cconvert)
		)
	);
	assert_eq!(
		unsafe {
			&(*(::core::ptr::null::<jpeg_compress_struct>())).downsample as *const _ as usize
		},
		480usize,
		concat!(
			"Offset of field: ",
			stringify!(jpeg_compress_struct),
			"::",
			stringify!(downsample)
		)
	);
	assert_eq!(
		unsafe { &(*(::core::ptr::null::<jpeg_compress_struct>())).fdct as *const _ as usize },
		488usize,
		concat!(
			"Offset of field: ",
			stringify!(jpeg_compress_struct),
			"::",
			stringify!(fdct)
		)
	);
	assert_eq!(
		unsafe { &(*(::core::ptr::null::<jpeg_compress_struct>())).entropy as *const _ as usize },
		496usize,
		concat!(
			"Offset of field: ",
			stringify!(jpeg_compress_struct),
			"::",
			stringify!(entropy)
		)
	);
	assert_eq!(
		unsafe {
			&(*(::core::ptr::null::<jpeg_compress_struct>())).script_space as *const _ as usize
		},
		504usize,
		concat!(
			"Offset of field: ",
			stringify!(jpeg_compress_struct),
			"::",
			stringify!(script_space)
		)
	);
	assert_eq!(
		unsafe {
			&(*(::core::ptr::null::<jpeg_compress_struct>())).script_space_size as *const _ as usize
		},
		512usize,
		concat!(
			"Offset of field: ",
			stringify!(jpeg_compress_struct),
			"::",
			stringify!(script_space_size)
		)
	);
}
pub type jpeg_idct_method = ::core::option::Option<
	unsafe extern "C" fn(
		cinfo: j_decompress_ptr,
		compptr: *mut jpeg_component_info,
		coef_block: JCOEFPTR,
		output_buf: JSAMPARRAY,
		output_col: JDIMENSION,
	),
>;
pub type jpeg_idct_method_selector = ::core::option::Option<
	unsafe extern "C" fn(
		cinfo: j_decompress_ptr,
		compptr: *mut jpeg_component_info,
		set_idct_method: *mut jpeg_idct_method,
		set_idct_category: *mut ::std::os::raw::c_int,
	),
>;
#[repr(C)]
pub struct jpeg_decompress_struct {
	pub err: *mut jpeg_error_mgr,
	pub mem: *mut jpeg_memory_mgr,
	pub progress: *mut jpeg_progress_mgr,
	pub client_data: *mut ::core::ffi::c_void,
	pub is_decompressor: boolean,
	pub global_state: ::std::os::raw::c_int,
	pub src: *mut jpeg_source_mgr,
	pub image_width: JDIMENSION,
	pub image_height: JDIMENSION,
	pub num_components: ::std::os::raw::c_int,
	pub jpeg_color_space: J_COLOR_SPACE,
	pub out_color_space: J_COLOR_SPACE,
	pub scale_num: ::std::os::raw::c_uint,
	pub scale_denom: ::std::os::raw::c_uint,
	pub output_gamma: f64,
	pub buffered_image: boolean,
	pub raw_data_out: boolean,
	pub dct_method: J_DCT_METHOD,
	pub do_fancy_upsampling: boolean,
	pub do_block_smoothing: boolean,
	pub quantize_colors: boolean,
	pub dither_mode: J_DITHER_MODE,
	pub two_pass_quantize: boolean,
	pub desired_number_of_colors: ::std::os::raw::c_int,
	pub enable_1pass_quant: boolean,
	pub enable_external_quant: boolean,
	pub enable_2pass_quant: boolean,
	pub output_width: JDIMENSION,
	pub output_height: JDIMENSION,
	pub out_color_components: ::std::os::raw::c_int,
	pub output_components: ::std::os::raw::c_int,
	pub rec_outbuf_height: ::std::os::raw::c_int,
	pub actual_number_of_colors: ::std::os::raw::c_int,
	pub colormap: JSAMPARRAY,
	pub output_scanline: JDIMENSION,
	pub input_scan_number: ::std::os::raw::c_int,
	pub input_iMCU_row: JDIMENSION,
	pub output_scan_number: ::std::os::raw::c_int,
	pub output_iMCU_row: JDIMENSION,
	pub coef_bits: *mut [::std::os::raw::c_int; 64usize],
	pub quant_tbl_ptrs: [*mut JQUANT_TBL; 4usize],
	pub dc_huff_tbl_ptrs: [*mut JHUFF_TBL; 4usize],
	pub ac_huff_tbl_ptrs: [*mut JHUFF_TBL; 4usize],
	pub data_precision: ::std::os::raw::c_int,
	pub comp_info: *mut jpeg_component_info,
	pub progressive_mode: boolean,
	pub arith_code: boolean,
	pub arith_dc_L: [UINT8; 16usize],
	pub arith_dc_U: [UINT8; 16usize],
	pub arith_ac_K: [UINT8; 16usize],
	pub restart_interval: ::std::os::raw::c_uint,
	pub saw_JFIF_marker: boolean,
	pub JFIF_major_version: UINT8,
	pub JFIF_minor_version: UINT8,
	pub density_unit: UINT8,
	pub X_density: UINT16,
	pub Y_density: UINT16,
	pub saw_Adobe_marker: boolean,
	pub Adobe_transform: UINT8,
	pub CCIR601_sampling: boolean,
	pub marker_list: jpeg_saved_marker_ptr,
	pub max_h_samp_factor: ::std::os::raw::c_int,
	pub max_v_samp_factor: ::std::os::raw::c_int,
	pub min_DCT_scaled_size: ::std::os::raw::c_int,
	pub total_iMCU_rows: JDIMENSION,
	pub sample_range_limit: *mut JSAMPLE,
	pub comps_in_scan: ::std::os::raw::c_int,
	pub cur_comp_info: [*mut jpeg_component_info; 4usize],
	pub MCUs_per_row: JDIMENSION,
	pub MCU_rows_in_scan: JDIMENSION,
	pub blocks_in_MCU: ::std::os::raw::c_int,
	pub MCU_membership: [::std::os::raw::c_int; 10usize],
	pub Ss: ::std::os::raw::c_int,
	pub Se: ::std::os::raw::c_int,
	pub Ah: ::std::os::raw::c_int,
	pub Al: ::std::os::raw::c_int,
	pub unread_marker: ::std::os::raw::c_int,
	pub master: *mut jpeg_decomp_master,
	pub main: *mut jpeg_d_main_controller,
	pub coef: *mut jpeg_d_coef_controller,
	pub post: *mut jpeg_d_post_controller,
	pub inputctl: *mut jpeg_input_controller,
	pub marker: *mut jpeg_marker_reader,
	pub entropy: *mut jpeg_entropy_decoder,
	pub idct: *mut jpeg_inverse_dct,
	pub upsample: *mut jpeg_upsampler,
	pub cconvert: *mut jpeg_color_deconverter,
	pub cquantize: *mut jpeg_color_quantizer,
}
#[test]
fn bindgen_test_layout_jpeg_decompress_struct() {
	assert_eq!(
		::core::mem::size_of::<jpeg_decompress_struct>(),
		632usize,
		concat!("Size of: ", stringify!(jpeg_decompress_struct))
	);
	assert_eq!(
		::core::mem::align_of::<jpeg_decompress_struct>(),
		8usize,
		concat!("Alignment of ", stringify!(jpeg_decompress_struct))
	);
	assert_eq!(
		unsafe { &(*(::core::ptr::null::<jpeg_decompress_struct>())).err as *const _ as usize },
		0usize,
		concat!(
			"Offset of field: ",
			stringify!(jpeg_decompress_struct),
			"::",
			stringify!(err)
		)
	);
	assert_eq!(
		unsafe { &(*(::core::ptr::null::<jpeg_decompress_struct>())).mem as *const _ as usize },
		8usize,
		concat!(
			"Offset of field: ",
			stringify!(jpeg_decompress_struct),
			"::",
			stringify!(mem)
		)
	);
	assert_eq!(
		unsafe {
			&(*(::core::ptr::null::<jpeg_decompress_struct>())).progress as *const _ as usize
		},
		16usize,
		concat!(
			"Offset of field: ",
			stringify!(jpeg_decompress_struct),
			"::",
			stringify!(progress)
		)
	);
	assert_eq!(
		unsafe {
			&(*(::core::ptr::null::<jpeg_decompress_struct>())).client_data as *const _ as usize
		},
		24usize,
		concat!(
			"Offset of field: ",
			stringify!(jpeg_decompress_struct),
			"::",
			stringify!(client_data)
		)
	);
	assert_eq!(
		unsafe {
			&(*(::core::ptr::null::<jpeg_decompress_struct>())).is_decompressor as *const _ as usize
		},
		32usize,
		concat!(
			"Offset of field: ",
			stringify!(jpeg_decompress_struct),
			"::",
			stringify!(is_decompressor)
		)
	);
	assert_eq!(
		unsafe {
			&(*(::core::ptr::null::<jpeg_decompress_struct>())).global_state as *const _ as usize
		},
		36usize,
		concat!(
			"Offset of field: ",
			stringify!(jpeg_decompress_struct),
			"::",
			stringify!(global_state)
		)
	);
	assert_eq!(
		unsafe { &(*(::core::ptr::null::<jpeg_decompress_struct>())).src as *const _ as usize },
		40usize,
		concat!(
			"Offset of field: ",
			stringify!(jpeg_decompress_struct),
			"::",
			stringify!(src)
		)
	);
	assert_eq!(
		unsafe {
			&(*(::core::ptr::null::<jpeg_decompress_struct>())).image_width as *const _ as usize
		},
		48usize,
		concat!(
			"Offset of field: ",
			stringify!(jpeg_decompress_struct),
			"::",
			stringify!(image_width)
		)
	);
	assert_eq!(
		unsafe {
			&(*(::core::ptr::null::<jpeg_decompress_struct>())).image_height as *const _ as usize
		},
		52usize,
		concat!(
			"Offset of field: ",
			stringify!(jpeg_decompress_struct),
			"::",
			stringify!(image_height)
		)
	);
	assert_eq!(
		unsafe {
			&(*(::core::ptr::null::<jpeg_decompress_struct>())).num_components as *const _ as usize
		},
		56usize,
		concat!(
			"Offset of field: ",
			stringify!(jpeg_decompress_struct),
			"::",
			stringify!(num_components)
		)
	);
	assert_eq!(
		unsafe {
			&(*(::core::ptr::null::<jpeg_decompress_struct>())).jpeg_color_space as *const _
				as usize
		},
		60usize,
		concat!(
			"Offset of field: ",
			stringify!(jpeg_decompress_struct),
			"::",
			stringify!(jpeg_color_space)
		)
	);
	assert_eq!(
		unsafe {
			&(*(::core::ptr::null::<jpeg_decompress_struct>())).out_color_space as *const _ as usize
		},
		64usize,
		concat!(
			"Offset of field: ",
			stringify!(jpeg_decompress_struct),
			"::",
			stringify!(out_color_space)
		)
	);
	assert_eq!(
		unsafe {
			&(*(::core::ptr::null::<jpeg_decompress_struct>())).scale_num as *const _ as usize
		},
		68usize,
		concat!(
			"Offset of field: ",
			stringify!(jpeg_decompress_struct),
			"::",
			stringify!(scale_num)
		)
	);
	assert_eq!(
		unsafe {
			&(*(::core::ptr::null::<jpeg_decompress_struct>())).scale_denom as *const _ as usize
		},
		72usize,
		concat!(
			"Offset of field: ",
			stringify!(jpeg_decompress_struct),
			"::",
			stringify!(scale_denom)
		)
	);
	assert_eq!(
		unsafe {
			&(*(::core::ptr::null::<jpeg_decompress_struct>())).output_gamma as *const _ as usize
		},
		80usize,
		concat!(
			"Offset of field: ",
			stringify!(jpeg_decompress_struct),
			"::",
			stringify!(output_gamma)
		)
	);
	assert_eq!(
		unsafe {
			&(*(::core::ptr::null::<jpeg_decompress_struct>())).buffered_image as *const _ as usize
		},
		88usize,
		concat!(
			"Offset of field: ",
			stringify!(jpeg_decompress_struct),
			"::",
			stringify!(buffered_image)
		)
	);
	assert_eq!(
		unsafe {
			&(*(::core::ptr::null::<jpeg_decompress_struct>())).raw_data_out as *const _ as usize
		},
		92usize,
		concat!(
			"Offset of field: ",
			stringify!(jpeg_decompress_struct),
			"::",
			stringify!(raw_data_out)
		)
	);
	assert_eq!(
		unsafe {
			&(*(::core::ptr::null::<jpeg_decompress_struct>())).dct_method as *const _ as usize
		},
		96usize,
		concat!(
			"Offset of field: ",
			stringify!(jpeg_decompress_struct),
			"::",
			stringify!(dct_method)
		)
	);
	assert_eq!(
		unsafe {
			&(*(::core::ptr::null::<jpeg_decompress_struct>())).do_fancy_upsampling as *const _
				as usize
		},
		100usize,
		concat!(
			"Offset of field: ",
			stringify!(jpeg_decompress_struct),
			"::",
			stringify!(do_fancy_upsampling)
		)
	);
	assert_eq!(
		unsafe {
			&(*(::core::ptr::null::<jpeg_decompress_struct>())).do_block_smoothing as *const _
				as usize
		},
		104usize,
		concat!(
			"Offset of field: ",
			stringify!(jpeg_decompress_struct),
			"::",
			stringify!(do_block_smoothing)
		)
	);
	assert_eq!(
		unsafe {
			&(*(::core::ptr::null::<jpeg_decompress_struct>())).quantize_colors as *const _ as usize
		},
		108usize,
		concat!(
			"Offset of field: ",
			stringify!(jpeg_decompress_struct),
			"::",
			stringify!(quantize_colors)
		)
	);
	assert_eq!(
		unsafe {
			&(*(::core::ptr::null::<jpeg_decompress_struct>())).dither_mode as *const _ as usize
		},
		112usize,
		concat!(
			"Offset of field: ",
			stringify!(jpeg_decompress_struct),
			"::",
			stringify!(dither_mode)
		)
	);
	assert_eq!(
		unsafe {
			&(*(::core::ptr::null::<jpeg_decompress_struct>())).two_pass_quantize as *const _
				as usize
		},
		116usize,
		concat!(
			"Offset of field: ",
			stringify!(jpeg_decompress_struct),
			"::",
			stringify!(two_pass_quantize)
		)
	);
	assert_eq!(
		unsafe {
			&(*(::core::ptr::null::<jpeg_decompress_struct>())).desired_number_of_colors as *const _
				as usize
		},
		120usize,
		concat!(
			"Offset of field: ",
			stringify!(jpeg_decompress_struct),
			"::",
			stringify!(desired_number_of_colors)
		)
	);
	assert_eq!(
		unsafe {
			&(*(::core::ptr::null::<jpeg_decompress_struct>())).enable_1pass_quant as *const _
				as usize
		},
		124usize,
		concat!(
			"Offset of field: ",
			stringify!(jpeg_decompress_struct),
			"::",
			stringify!(enable_1pass_quant)
		)
	);
	assert_eq!(
		unsafe {
			&(*(::core::ptr::null::<jpeg_decompress_struct>())).enable_external_quant as *const _
				as usize
		},
		128usize,
		concat!(
			"Offset of field: ",
			stringify!(jpeg_decompress_struct),
			"::",
			stringify!(enable_external_quant)
		)
	);
	assert_eq!(
		unsafe {
			&(*(::core::ptr::null::<jpeg_decompress_struct>())).enable_2pass_quant as *const _
				as usize
		},
		132usize,
		concat!(
			"Offset of field: ",
			stringify!(jpeg_decompress_struct),
			"::",
			stringify!(enable_2pass_quant)
		)
	);
	assert_eq!(
		unsafe {
			&(*(::core::ptr::null::<jpeg_decompress_struct>())).output_width as *const _ as usize
		},
		136usize,
		concat!(
			"Offset of field: ",
			stringify!(jpeg_decompress_struct),
			"::",
			stringify!(output_width)
		)
	);
	assert_eq!(
		unsafe {
			&(*(::core::ptr::null::<jpeg_decompress_struct>())).output_height as *const _ as usize
		},
		140usize,
		concat!(
			"Offset of field: ",
			stringify!(jpeg_decompress_struct),
			"::",
			stringify!(output_height)
		)
	);
	assert_eq!(
		unsafe {
			&(*(::core::ptr::null::<jpeg_decompress_struct>())).out_color_components as *const _
				as usize
		},
		144usize,
		concat!(
			"Offset of field: ",
			stringify!(jpeg_decompress_struct),
			"::",
			stringify!(out_color_components)
		)
	);
	assert_eq!(
		unsafe {
			&(*(::core::ptr::null::<jpeg_decompress_struct>())).output_components as *const _
				as usize
		},
		148usize,
		concat!(
			"Offset of field: ",
			stringify!(jpeg_decompress_struct),
			"::",
			stringify!(output_components)
		)
	);
	assert_eq!(
		unsafe {
			&(*(::core::ptr::null::<jpeg_decompress_struct>())).rec_outbuf_height as *const _
				as usize
		},
		152usize,
		concat!(
			"Offset of field: ",
			stringify!(jpeg_decompress_struct),
			"::",
			stringify!(rec_outbuf_height)
		)
	);
	assert_eq!(
		unsafe {
			&(*(::core::ptr::null::<jpeg_decompress_struct>())).actual_number_of_colors as *const _
				as usize
		},
		156usize,
		concat!(
			"Offset of field: ",
			stringify!(jpeg_decompress_struct),
			"::",
			stringify!(actual_number_of_colors)
		)
	);
	assert_eq!(
		unsafe {
			&(*(::core::ptr::null::<jpeg_decompress_struct>())).colormap as *const _ as usize
		},
		160usize,
		concat!(
			"Offset of field: ",
			stringify!(jpeg_decompress_struct),
			"::",
			stringify!(colormap)
		)
	);
	assert_eq!(
		unsafe {
			&(*(::core::ptr::null::<jpeg_decompress_struct>())).output_scanline as *const _ as usize
		},
		168usize,
		concat!(
			"Offset of field: ",
			stringify!(jpeg_decompress_struct),
			"::",
			stringify!(output_scanline)
		)
	);
	assert_eq!(
		unsafe {
			&(*(::core::ptr::null::<jpeg_decompress_struct>())).input_scan_number as *const _
				as usize
		},
		172usize,
		concat!(
			"Offset of field: ",
			stringify!(jpeg_decompress_struct),
			"::",
			stringify!(input_scan_number)
		)
	);
	assert_eq!(
		unsafe {
			&(*(::core::ptr::null::<jpeg_decompress_struct>())).input_iMCU_row as *const _ as usize
		},
		176usize,
		concat!(
			"Offset of field: ",
			stringify!(jpeg_decompress_struct),
			"::",
			stringify!(input_iMCU_row)
		)
	);
	assert_eq!(
		unsafe {
			&(*(::core::ptr::null::<jpeg_decompress_struct>())).output_scan_number as *const _
				as usize
		},
		180usize,
		concat!(
			"Offset of field: ",
			stringify!(jpeg_decompress_struct),
			"::",
			stringify!(output_scan_number)
		)
	);
	assert_eq!(
		unsafe {
			&(*(::core::ptr::null::<jpeg_decompress_struct>())).output_iMCU_row as *const _ as usize
		},
		184usize,
		concat!(
			"Offset of field: ",
			stringify!(jpeg_decompress_struct),
			"::",
			stringify!(output_iMCU_row)
		)
	);
	assert_eq!(
		unsafe {
			&(*(::core::ptr::null::<jpeg_decompress_struct>())).coef_bits as *const _ as usize
		},
		192usize,
		concat!(
			"Offset of field: ",
			stringify!(jpeg_decompress_struct),
			"::",
			stringify!(coef_bits)
		)
	);
	assert_eq!(
		unsafe {
			&(*(::core::ptr::null::<jpeg_decompress_struct>())).quant_tbl_ptrs as *const _ as usize
		},
		200usize,
		concat!(
			"Offset of field: ",
			stringify!(jpeg_decompress_struct),
			"::",
			stringify!(quant_tbl_ptrs)
		)
	);
	assert_eq!(
		unsafe {
			&(*(::core::ptr::null::<jpeg_decompress_struct>())).dc_huff_tbl_ptrs as *const _
				as usize
		},
		232usize,
		concat!(
			"Offset of field: ",
			stringify!(jpeg_decompress_struct),
			"::",
			stringify!(dc_huff_tbl_ptrs)
		)
	);
	assert_eq!(
		unsafe {
			&(*(::core::ptr::null::<jpeg_decompress_struct>())).ac_huff_tbl_ptrs as *const _
				as usize
		},
		264usize,
		concat!(
			"Offset of field: ",
			stringify!(jpeg_decompress_struct),
			"::",
			stringify!(ac_huff_tbl_ptrs)
		)
	);
	assert_eq!(
		unsafe {
			&(*(::core::ptr::null::<jpeg_decompress_struct>())).data_precision as *const _ as usize
		},
		296usize,
		concat!(
			"Offset of field: ",
			stringify!(jpeg_decompress_struct),
			"::",
			stringify!(data_precision)
		)
	);
	assert_eq!(
		unsafe {
			&(*(::core::ptr::null::<jpeg_decompress_struct>())).comp_info as *const _ as usize
		},
		304usize,
		concat!(
			"Offset of field: ",
			stringify!(jpeg_decompress_struct),
			"::",
			stringify!(comp_info)
		)
	);
	assert_eq!(
		unsafe {
			&(*(::core::ptr::null::<jpeg_decompress_struct>())).progressive_mode as *const _
				as usize
		},
		312usize,
		concat!(
			"Offset of field: ",
			stringify!(jpeg_decompress_struct),
			"::",
			stringify!(progressive_mode)
		)
	);
	assert_eq!(
		unsafe {
			&(*(::core::ptr::null::<jpeg_decompress_struct>())).arith_code as *const _ as usize
		},
		316usize,
		concat!(
			"Offset of field: ",
			stringify!(jpeg_decompress_struct),
			"::",
			stringify!(arith_code)
		)
	);
	assert_eq!(
		unsafe {
			&(*(::core::ptr::null::<jpeg_decompress_struct>())).arith_dc_L as *const _ as usize
		},
		320usize,
		concat!(
			"Offset of field: ",
			stringify!(jpeg_decompress_struct),
			"::",
			stringify!(arith_dc_L)
		)
	);
	assert_eq!(
		unsafe {
			&(*(::core::ptr::null::<jpeg_decompress_struct>())).arith_dc_U as *const _ as usize
		},
		336usize,
		concat!(
			"Offset of field: ",
			stringify!(jpeg_decompress_struct),
			"::",
			stringify!(arith_dc_U)
		)
	);
	assert_eq!(
		unsafe {
			&(*(::core::ptr::null::<jpeg_decompress_struct>())).arith_ac_K as *const _ as usize
		},
		352usize,
		concat!(
			"Offset of field: ",
			stringify!(jpeg_decompress_struct),
			"::",
			stringify!(arith_ac_K)
		)
	);
	assert_eq!(
		unsafe {
			&(*(::core::ptr::null::<jpeg_decompress_struct>())).restart_interval as *const _
				as usize
		},
		368usize,
		concat!(
			"Offset of field: ",
			stringify!(jpeg_decompress_struct),
			"::",
			stringify!(restart_interval)
		)
	);
	assert_eq!(
		unsafe {
			&(*(::core::ptr::null::<jpeg_decompress_struct>())).saw_JFIF_marker as *const _ as usize
		},
		372usize,
		concat!(
			"Offset of field: ",
			stringify!(jpeg_decompress_struct),
			"::",
			stringify!(saw_JFIF_marker)
		)
	);
	assert_eq!(
		unsafe {
			&(*(::core::ptr::null::<jpeg_decompress_struct>())).JFIF_major_version as *const _
				as usize
		},
		376usize,
		concat!(
			"Offset of field: ",
			stringify!(jpeg_decompress_struct),
			"::",
			stringify!(JFIF_major_version)
		)
	);
	assert_eq!(
		unsafe {
			&(*(::core::ptr::null::<jpeg_decompress_struct>())).JFIF_minor_version as *const _
				as usize
		},
		377usize,
		concat!(
			"Offset of field: ",
			stringify!(jpeg_decompress_struct),
			"::",
			stringify!(JFIF_minor_version)
		)
	);
	assert_eq!(
		unsafe {
			&(*(::core::ptr::null::<jpeg_decompress_struct>())).density_unit as *const _ as usize
		},
		378usize,
		concat!(
			"Offset of field: ",
			stringify!(jpeg_decompress_struct),
			"::",
			stringify!(density_unit)
		)
	);
	assert_eq!(
		unsafe {
			&(*(::core::ptr::null::<jpeg_decompress_struct>())).X_density as *const _ as usize
		},
		380usize,
		concat!(
			"Offset of field: ",
			stringify!(jpeg_decompress_struct),
			"::",
			stringify!(X_density)
		)
	);
	assert_eq!(
		unsafe {
			&(*(::core::ptr::null::<jpeg_decompress_struct>())).Y_density as *const _ as usize
		},
		382usize,
		concat!(
			"Offset of field: ",
			stringify!(jpeg_decompress_struct),
			"::",
			stringify!(Y_density)
		)
	);
	assert_eq!(
		unsafe {
			&(*(::core::ptr::null::<jpeg_decompress_struct>())).saw_Adobe_marker as *const _
				as usize
		},
		384usize,
		concat!(
			"Offset of field: ",
			stringify!(jpeg_decompress_struct),
			"::",
			stringify!(saw_Adobe_marker)
		)
	);
	assert_eq!(
		unsafe {
			&(*(::core::ptr::null::<jpeg_decompress_struct>())).Adobe_transform as *const _ as usize
		},
		388usize,
		concat!(
			"Offset of field: ",
			stringify!(jpeg_decompress_struct),
			"::",
			stringify!(Adobe_transform)
		)
	);
	assert_eq!(
		unsafe {
			&(*(::core::ptr::null::<jpeg_decompress_struct>())).CCIR601_sampling as *const _
				as usize
		},
		392usize,
		concat!(
			"Offset of field: ",
			stringify!(jpeg_decompress_struct),
			"::",
			stringify!(CCIR601_sampling)
		)
	);
	assert_eq!(
		unsafe {
			&(*(::core::ptr::null::<jpeg_decompress_struct>())).marker_list as *const _ as usize
		},
		400usize,
		concat!(
			"Offset of field: ",
			stringify!(jpeg_decompress_struct),
			"::",
			stringify!(marker_list)
		)
	);
	assert_eq!(
		unsafe {
			&(*(::core::ptr::null::<jpeg_decompress_struct>())).max_h_samp_factor as *const _
				as usize
		},
		408usize,
		concat!(
			"Offset of field: ",
			stringify!(jpeg_decompress_struct),
			"::",
			stringify!(max_h_samp_factor)
		)
	);
	assert_eq!(
		unsafe {
			&(*(::core::ptr::null::<jpeg_decompress_struct>())).max_v_samp_factor as *const _
				as usize
		},
		412usize,
		concat!(
			"Offset of field: ",
			stringify!(jpeg_decompress_struct),
			"::",
			stringify!(max_v_samp_factor)
		)
	);
	assert_eq!(
		unsafe {
			&(*(::core::ptr::null::<jpeg_decompress_struct>())).min_DCT_scaled_size as *const _
				as usize
		},
		416usize,
		concat!(
			"Offset of field: ",
			stringify!(jpeg_decompress_struct),
			"::",
			stringify!(min_DCT_scaled_size)
		)
	);
	assert_eq!(
		unsafe {
			&(*(::core::ptr::null::<jpeg_decompress_struct>())).total_iMCU_rows as *const _ as usize
		},
		420usize,
		concat!(
			"Offset of field: ",
			stringify!(jpeg_decompress_struct),
			"::",
			stringify!(total_iMCU_rows)
		)
	);
	assert_eq!(
		unsafe {
			&(*(::core::ptr::null::<jpeg_decompress_struct>())).sample_range_limit as *const _
				as usize
		},
		424usize,
		concat!(
			"Offset of field: ",
			stringify!(jpeg_decompress_struct),
			"::",
			stringify!(sample_range_limit)
		)
	);
	assert_eq!(
		unsafe {
			&(*(::core::ptr::null::<jpeg_decompress_struct>())).comps_in_scan as *const _ as usize
		},
		432usize,
		concat!(
			"Offset of field: ",
			stringify!(jpeg_decompress_struct),
			"::",
			stringify!(comps_in_scan)
		)
	);
	assert_eq!(
		unsafe {
			&(*(::core::ptr::null::<jpeg_decompress_struct>())).cur_comp_info as *const _ as usize
		},
		440usize,
		concat!(
			"Offset of field: ",
			stringify!(jpeg_decompress_struct),
			"::",
			stringify!(cur_comp_info)
		)
	);
	assert_eq!(
		unsafe {
			&(*(::core::ptr::null::<jpeg_decompress_struct>())).MCUs_per_row as *const _ as usize
		},
		472usize,
		concat!(
			"Offset of field: ",
			stringify!(jpeg_decompress_struct),
			"::",
			stringify!(MCUs_per_row)
		)
	);
	assert_eq!(
		unsafe {
			&(*(::core::ptr::null::<jpeg_decompress_struct>())).MCU_rows_in_scan as *const _
				as usize
		},
		476usize,
		concat!(
			"Offset of field: ",
			stringify!(jpeg_decompress_struct),
			"::",
			stringify!(MCU_rows_in_scan)
		)
	);
	assert_eq!(
		unsafe {
			&(*(::core::ptr::null::<jpeg_decompress_struct>())).blocks_in_MCU as *const _ as usize
		},
		480usize,
		concat!(
			"Offset of field: ",
			stringify!(jpeg_decompress_struct),
			"::",
			stringify!(blocks_in_MCU)
		)
	);
	assert_eq!(
		unsafe {
			&(*(::core::ptr::null::<jpeg_decompress_struct>())).MCU_membership as *const _ as usize
		},
		484usize,
		concat!(
			"Offset of field: ",
			stringify!(jpeg_decompress_struct),
			"::",
			stringify!(MCU_membership)
		)
	);
	assert_eq!(
		unsafe { &(*(::core::ptr::null::<jpeg_decompress_struct>())).Ss as *const _ as usize },
		524usize,
		concat!(
			"Offset of field: ",
			stringify!(jpeg_decompress_struct),
			"::",
			stringify!(Ss)
		)
	);
	assert_eq!(
		unsafe { &(*(::core::ptr::null::<jpeg_decompress_struct>())).Se as *const _ as usize },
		528usize,
		concat!(
			"Offset of field: ",
			stringify!(jpeg_decompress_struct),
			"::",
			stringify!(Se)
		)
	);
	assert_eq!(
		unsafe { &(*(::core::ptr::null::<jpeg_decompress_struct>())).Ah as *const _ as usize },
		532usize,
		concat!(
			"Offset of field: ",
			stringify!(jpeg_decompress_struct),
			"::",
			stringify!(Ah)
		)
	);
	assert_eq!(
		unsafe { &(*(::core::ptr::null::<jpeg_decompress_struct>())).Al as *const _ as usize },
		536usize,
		concat!(
			"Offset of field: ",
			stringify!(jpeg_decompress_struct),
			"::",
			stringify!(Al)
		)
	);
	assert_eq!(
		unsafe {
			&(*(::core::ptr::null::<jpeg_decompress_struct>())).unread_marker as *const _ as usize
		},
		540usize,
		concat!(
			"Offset of field: ",
			stringify!(jpeg_decompress_struct),
			"::",
			stringify!(unread_marker)
		)
	);
	assert_eq!(
		unsafe { &(*(::core::ptr::null::<jpeg_decompress_struct>())).master as *const _ as usize },
		544usize,
		concat!(
			"Offset of field: ",
			stringify!(jpeg_decompress_struct),
			"::",
			stringify!(master)
		)
	);
	assert_eq!(
		unsafe { &(*(::core::ptr::null::<jpeg_decompress_struct>())).main as *const _ as usize },
		552usize,
		concat!(
			"Offset of field: ",
			stringify!(jpeg_decompress_struct),
			"::",
			stringify!(main)
		)
	);
	assert_eq!(
		unsafe { &(*(::core::ptr::null::<jpeg_decompress_struct>())).coef as *const _ as usize },
		560usize,
		concat!(
			"Offset of field: ",
			stringify!(jpeg_decompress_struct),
			"::",
			stringify!(coef)
		)
	);
	assert_eq!(
		unsafe { &(*(::core::ptr::null::<jpeg_decompress_struct>())).post as *const _ as usize },
		568usize,
		concat!(
			"Offset of field: ",
			stringify!(jpeg_decompress_struct),
			"::",
			stringify!(post)
		)
	);
	assert_eq!(
		unsafe {
			&(*(::core::ptr::null::<jpeg_decompress_struct>())).inputctl as *const _ as usize
		},
		576usize,
		concat!(
			"Offset of field: ",
			stringify!(jpeg_decompress_struct),
			"::",
			stringify!(inputctl)
		)
	);
	assert_eq!(
		unsafe { &(*(::core::ptr::null::<jpeg_decompress_struct>())).marker as *const _ as usize },
		584usize,
		concat!(
			"Offset of field: ",
			stringify!(jpeg_decompress_struct),
			"::",
			stringify!(marker)
		)
	);
	assert_eq!(
		unsafe { &(*(::core::ptr::null::<jpeg_decompress_struct>())).entropy as *const _ as usize },
		592usize,
		concat!(
			"Offset of field: ",
			stringify!(jpeg_decompress_struct),
			"::",
			stringify!(entropy)
		)
	);
	assert_eq!(
		unsafe { &(*(::core::ptr::null::<jpeg_decompress_struct>())).idct as *const _ as usize },
		600usize,
		concat!(
			"Offset of field: ",
			stringify!(jpeg_decompress_struct),
			"::",
			stringify!(idct)
		)
	);
	assert_eq!(
		unsafe {
			&(*(::core::ptr::null::<jpeg_decompress_struct>())).upsample as *const _ as usize
		},
		608usize,
		concat!(
			"Offset of field: ",
			stringify!(jpeg_decompress_struct),
			"::",
			stringify!(upsample)
		)
	);
	assert_eq!(
		unsafe {
			&(*(::core::ptr::null::<jpeg_decompress_struct>())).cconvert as *const _ as usize
		},
		616usize,
		concat!(
			"Offset of field: ",
			stringify!(jpeg_decompress_struct),
			"::",
			stringify!(cconvert)
		)
	);
	assert_eq!(
		unsafe {
			&(*(::core::ptr::null::<jpeg_decompress_struct>())).cquantize as *const _ as usize
		},
		624usize,
		concat!(
			"Offset of field: ",
			stringify!(jpeg_decompress_struct),
			"::",
			stringify!(cquantize)
		)
	);
}
#[repr(C)]
pub struct jpeg_error_mgr {
	pub error_exit: ::core::option::Option<unsafe extern "C" fn(cinfo: j_common_ptr)>,
	pub emit_message: ::core::option::Option<
		unsafe extern "C" fn(cinfo: j_common_ptr, msg_level: ::std::os::raw::c_int),
	>,
	pub output_message: ::core::option::Option<unsafe extern "C" fn(cinfo: j_common_ptr)>,
	pub format_message: ::core::option::Option<
		unsafe extern "C" fn(cinfo: j_common_ptr, buffer: *mut ::std::os::raw::c_char),
	>,
	pub reset_error_mgr: ::core::option::Option<unsafe extern "C" fn(cinfo: j_common_ptr)>,
	pub msg_code: ::std::os::raw::c_int,
	pub msg_parm: jpeg_error_mgr__bindgen_ty_1,
	pub trace_level: ::std::os::raw::c_int,
	pub num_warnings: ::std::os::raw::c_long,
	pub jpeg_message_table: *const *const ::std::os::raw::c_char,
	pub last_jpeg_message: ::std::os::raw::c_int,
	pub addon_message_table: *const *const ::std::os::raw::c_char,
	pub first_addon_message: ::std::os::raw::c_int,
	pub last_addon_message: ::std::os::raw::c_int,
}
#[repr(C)]
pub struct jpeg_error_mgr__bindgen_ty_1 {
	pub i: __BindgenUnionField<[::std::os::raw::c_int; 8usize]>,
	pub s: __BindgenUnionField<[::std::os::raw::c_char; 80usize]>,
	pub bindgen_union_field: [u32; 20usize],
}
#[test]
fn bindgen_test_layout_jpeg_error_mgr__bindgen_ty_1() {
	assert_eq!(
		::core::mem::size_of::<jpeg_error_mgr__bindgen_ty_1>(),
		80usize,
		concat!("Size of: ", stringify!(jpeg_error_mgr__bindgen_ty_1))
	);
	assert_eq!(
		::core::mem::align_of::<jpeg_error_mgr__bindgen_ty_1>(),
		4usize,
		concat!("Alignment of ", stringify!(jpeg_error_mgr__bindgen_ty_1))
	);
	assert_eq!(
		unsafe { &(*(::core::ptr::null::<jpeg_error_mgr__bindgen_ty_1>())).i as *const _ as usize },
		0usize,
		concat!(
			"Offset of field: ",
			stringify!(jpeg_error_mgr__bindgen_ty_1),
			"::",
			stringify!(i)
		)
	);
	assert_eq!(
		unsafe { &(*(::core::ptr::null::<jpeg_error_mgr__bindgen_ty_1>())).s as *const _ as usize },
		0usize,
		concat!(
			"Offset of field: ",
			stringify!(jpeg_error_mgr__bindgen_ty_1),
			"::",
			stringify!(s)
		)
	);
}
#[test]
fn bindgen_test_layout_jpeg_error_mgr() {
	assert_eq!(
		::core::mem::size_of::<jpeg_error_mgr>(),
		168usize,
		concat!("Size of: ", stringify!(jpeg_error_mgr))
	);
	assert_eq!(
		::core::mem::align_of::<jpeg_error_mgr>(),
		8usize,
		concat!("Alignment of ", stringify!(jpeg_error_mgr))
	);
	assert_eq!(
		unsafe { &(*(::core::ptr::null::<jpeg_error_mgr>())).error_exit as *const _ as usize },
		0usize,
		concat!(
			"Offset of field: ",
			stringify!(jpeg_error_mgr),
			"::",
			stringify!(error_exit)
		)
	);
	assert_eq!(
		unsafe { &(*(::core::ptr::null::<jpeg_error_mgr>())).emit_message as *const _ as usize },
		8usize,
		concat!(
			"Offset of field: ",
			stringify!(jpeg_error_mgr),
			"::",
			stringify!(emit_message)
		)
	);
	assert_eq!(
		unsafe { &(*(::core::ptr::null::<jpeg_error_mgr>())).output_message as *const _ as usize },
		16usize,
		concat!(
			"Offset of field: ",
			stringify!(jpeg_error_mgr),
			"::",
			stringify!(output_message)
		)
	);
	assert_eq!(
		unsafe { &(*(::core::ptr::null::<jpeg_error_mgr>())).format_message as *const _ as usize },
		24usize,
		concat!(
			"Offset of field: ",
			stringify!(jpeg_error_mgr),
			"::",
			stringify!(format_message)
		)
	);
	assert_eq!(
		unsafe { &(*(::core::ptr::null::<jpeg_error_mgr>())).reset_error_mgr as *const _ as usize },
		32usize,
		concat!(
			"Offset of field: ",
			stringify!(jpeg_error_mgr),
			"::",
			stringify!(reset_error_mgr)
		)
	);
	assert_eq!(
		unsafe { &(*(::core::ptr::null::<jpeg_error_mgr>())).msg_code as *const _ as usize },
		40usize,
		concat!(
			"Offset of field: ",
			stringify!(jpeg_error_mgr),
			"::",
			stringify!(msg_code)
		)
	);
	assert_eq!(
		unsafe { &(*(::core::ptr::null::<jpeg_error_mgr>())).msg_parm as *const _ as usize },
		44usize,
		concat!(
			"Offset of field: ",
			stringify!(jpeg_error_mgr),
			"::",
			stringify!(msg_parm)
		)
	);
	assert_eq!(
		unsafe { &(*(::core::ptr::null::<jpeg_error_mgr>())).trace_level as *const _ as usize },
		124usize,
		concat!(
			"Offset of field: ",
			stringify!(jpeg_error_mgr),
			"::",
			stringify!(trace_level)
		)
	);
	assert_eq!(
		unsafe { &(*(::core::ptr::null::<jpeg_error_mgr>())).num_warnings as *const _ as usize },
		128usize,
		concat!(
			"Offset of field: ",
			stringify!(jpeg_error_mgr),
			"::",
			stringify!(num_warnings)
		)
	);
	assert_eq!(
		unsafe {
			&(*(::core::ptr::null::<jpeg_error_mgr>())).jpeg_message_table as *const _ as usize
		},
		136usize,
		concat!(
			"Offset of field: ",
			stringify!(jpeg_error_mgr),
			"::",
			stringify!(jpeg_message_table)
		)
	);
	assert_eq!(
		unsafe {
			&(*(::core::ptr::null::<jpeg_error_mgr>())).last_jpeg_message as *const _ as usize
		},
		144usize,
		concat!(
			"Offset of field: ",
			stringify!(jpeg_error_mgr),
			"::",
			stringify!(last_jpeg_message)
		)
	);
	assert_eq!(
		unsafe {
			&(*(::core::ptr::null::<jpeg_error_mgr>())).addon_message_table as *const _ as usize
		},
		152usize,
		concat!(
			"Offset of field: ",
			stringify!(jpeg_error_mgr),
			"::",
			stringify!(addon_message_table)
		)
	);
	assert_eq!(
		unsafe {
			&(*(::core::ptr::null::<jpeg_error_mgr>())).first_addon_message as *const _ as usize
		},
		160usize,
		concat!(
			"Offset of field: ",
			stringify!(jpeg_error_mgr),
			"::",
			stringify!(first_addon_message)
		)
	);
	assert_eq!(
		unsafe {
			&(*(::core::ptr::null::<jpeg_error_mgr>())).last_addon_message as *const _ as usize
		},
		164usize,
		concat!(
			"Offset of field: ",
			stringify!(jpeg_error_mgr),
			"::",
			stringify!(last_addon_message)
		)
	);
}
#[repr(C)]
pub struct jpeg_progress_mgr {
	pub progress_monitor: ::core::option::Option<unsafe extern "C" fn(cinfo: j_common_ptr)>,
	pub pass_counter: ::std::os::raw::c_long,
	pub pass_limit: ::std::os::raw::c_long,
	pub completed_passes: ::std::os::raw::c_int,
	pub total_passes: ::std::os::raw::c_int,
}
#[test]
fn bindgen_test_layout_jpeg_progress_mgr() {
	assert_eq!(
		::core::mem::size_of::<jpeg_progress_mgr>(),
		32usize,
		concat!("Size of: ", stringify!(jpeg_progress_mgr))
	);
	assert_eq!(
		::core::mem::align_of::<jpeg_progress_mgr>(),
		8usize,
		concat!("Alignment of ", stringify!(jpeg_progress_mgr))
	);
	assert_eq!(
		unsafe {
			&(*(::core::ptr::null::<jpeg_progress_mgr>())).progress_monitor as *const _ as usize
		},
		0usize,
		concat!(
			"Offset of field: ",
			stringify!(jpeg_progress_mgr),
			"::",
			stringify!(progress_monitor)
		)
	);
	assert_eq!(
		unsafe { &(*(::core::ptr::null::<jpeg_progress_mgr>())).pass_counter as *const _ as usize },
		8usize,
		concat!(
			"Offset of field: ",
			stringify!(jpeg_progress_mgr),
			"::",
			stringify!(pass_counter)
		)
	);
	assert_eq!(
		unsafe { &(*(::core::ptr::null::<jpeg_progress_mgr>())).pass_limit as *const _ as usize },
		16usize,
		concat!(
			"Offset of field: ",
			stringify!(jpeg_progress_mgr),
			"::",
			stringify!(pass_limit)
		)
	);
	assert_eq!(
		unsafe {
			&(*(::core::ptr::null::<jpeg_progress_mgr>())).completed_passes as *const _ as usize
		},
		24usize,
		concat!(
			"Offset of field: ",
			stringify!(jpeg_progress_mgr),
			"::",
			stringify!(completed_passes)
		)
	);
	assert_eq!(
		unsafe { &(*(::core::ptr::null::<jpeg_progress_mgr>())).total_passes as *const _ as usize },
		28usize,
		concat!(
			"Offset of field: ",
			stringify!(jpeg_progress_mgr),
			"::",
			stringify!(total_passes)
		)
	);
}
#[repr(C)]
pub struct jpeg_destination_mgr {
	pub next_output_byte: *mut JOCTET,
	pub free_in_buffer: size_t,
	pub init_destination: ::core::option::Option<unsafe extern "C" fn(cinfo: j_compress_ptr)>,
	pub empty_output_buffer:
		::core::option::Option<unsafe extern "C" fn(cinfo: j_compress_ptr) -> boolean>,
	pub term_destination: ::core::option::Option<unsafe extern "C" fn(cinfo: j_compress_ptr)>,
}
#[test]
fn bindgen_test_layout_jpeg_destination_mgr() {
	assert_eq!(
		::core::mem::size_of::<jpeg_destination_mgr>(),
		40usize,
		concat!("Size of: ", stringify!(jpeg_destination_mgr))
	);
	assert_eq!(
		::core::mem::align_of::<jpeg_destination_mgr>(),
		8usize,
		concat!("Alignment of ", stringify!(jpeg_destination_mgr))
	);
	assert_eq!(
		unsafe {
			&(*(::core::ptr::null::<jpeg_destination_mgr>())).next_output_byte as *const _ as usize
		},
		0usize,
		concat!(
			"Offset of field: ",
			stringify!(jpeg_destination_mgr),
			"::",
			stringify!(next_output_byte)
		)
	);
	assert_eq!(
		unsafe {
			&(*(::core::ptr::null::<jpeg_destination_mgr>())).free_in_buffer as *const _ as usize
		},
		8usize,
		concat!(
			"Offset of field: ",
			stringify!(jpeg_destination_mgr),
			"::",
			stringify!(free_in_buffer)
		)
	);
	assert_eq!(
		unsafe {
			&(*(::core::ptr::null::<jpeg_destination_mgr>())).init_destination as *const _ as usize
		},
		16usize,
		concat!(
			"Offset of field: ",
			stringify!(jpeg_destination_mgr),
			"::",
			stringify!(init_destination)
		)
	);
	assert_eq!(
		unsafe {
			&(*(::core::ptr::null::<jpeg_destination_mgr>())).empty_output_buffer as *const _
				as usize
		},
		24usize,
		concat!(
			"Offset of field: ",
			stringify!(jpeg_destination_mgr),
			"::",
			stringify!(empty_output_buffer)
		)
	);
	assert_eq!(
		unsafe {
			&(*(::core::ptr::null::<jpeg_destination_mgr>())).term_destination as *const _ as usize
		},
		32usize,
		concat!(
			"Offset of field: ",
			stringify!(jpeg_destination_mgr),
			"::",
			stringify!(term_destination)
		)
	);
}
#[repr(C)]
pub struct jpeg_source_mgr {
	pub next_input_byte: *const JOCTET,
	pub bytes_in_buffer: size_t,
	pub init_source: ::core::option::Option<unsafe extern "C" fn(cinfo: j_decompress_ptr)>,
	pub fill_input_buffer:
		::core::option::Option<unsafe extern "C" fn(cinfo: j_decompress_ptr) -> boolean>,
	pub skip_input_data: ::core::option::Option<
		unsafe extern "C" fn(cinfo: j_decompress_ptr, num_bytes: ::std::os::raw::c_long),
	>,
	pub resync_to_restart: ::core::option::Option<
		unsafe extern "C" fn(cinfo: j_decompress_ptr, desired: ::std::os::raw::c_int) -> boolean,
	>,
	pub term_source: ::core::option::Option<unsafe extern "C" fn(cinfo: j_decompress_ptr)>,
}
#[test]
fn bindgen_test_layout_jpeg_source_mgr() {
	assert_eq!(
		::core::mem::size_of::<jpeg_source_mgr>(),
		56usize,
		concat!("Size of: ", stringify!(jpeg_source_mgr))
	);
	assert_eq!(
		::core::mem::align_of::<jpeg_source_mgr>(),
		8usize,
		concat!("Alignment of ", stringify!(jpeg_source_mgr))
	);
	assert_eq!(
		unsafe {
			&(*(::core::ptr::null::<jpeg_source_mgr>())).next_input_byte as *const _ as usize
		},
		0usize,
		concat!(
			"Offset of field: ",
			stringify!(jpeg_source_mgr),
			"::",
			stringify!(next_input_byte)
		)
	);
	assert_eq!(
		unsafe {
			&(*(::core::ptr::null::<jpeg_source_mgr>())).bytes_in_buffer as *const _ as usize
		},
		8usize,
		concat!(
			"Offset of field: ",
			stringify!(jpeg_source_mgr),
			"::",
			stringify!(bytes_in_buffer)
		)
	);
	assert_eq!(
		unsafe { &(*(::core::ptr::null::<jpeg_source_mgr>())).init_source as *const _ as usize },
		16usize,
		concat!(
			"Offset of field: ",
			stringify!(jpeg_source_mgr),
			"::",
			stringify!(init_source)
		)
	);
	assert_eq!(
		unsafe {
			&(*(::core::ptr::null::<jpeg_source_mgr>())).fill_input_buffer as *const _ as usize
		},
		24usize,
		concat!(
			"Offset of field: ",
			stringify!(jpeg_source_mgr),
			"::",
			stringify!(fill_input_buffer)
		)
	);
	assert_eq!(
		unsafe {
			&(*(::core::ptr::null::<jpeg_source_mgr>())).skip_input_data as *const _ as usize
		},
		32usize,
		concat!(
			"Offset of field: ",
			stringify!(jpeg_source_mgr),
			"::",
			stringify!(skip_input_data)
		)
	);
	assert_eq!(
		unsafe {
			&(*(::core::ptr::null::<jpeg_source_mgr>())).resync_to_restart as *const _ as usize
		},
		40usize,
		concat!(
			"Offset of field: ",
			stringify!(jpeg_source_mgr),
			"::",
			stringify!(resync_to_restart)
		)
	);
	assert_eq!(
		unsafe { &(*(::core::ptr::null::<jpeg_source_mgr>())).term_source as *const _ as usize },
		48usize,
		concat!(
			"Offset of field: ",
			stringify!(jpeg_source_mgr),
			"::",
			stringify!(term_source)
		)
	);
}
#[repr(C)]
pub struct jvirt_sarray_control {
	_unused: [u8; 0],
}
pub type jvirt_sarray_ptr = *mut jvirt_sarray_control;
#[repr(C)]
pub struct jvirt_barray_control {
	_unused: [u8; 0],
}
pub type jvirt_barray_ptr = *mut jvirt_barray_control;
#[repr(C)]
pub struct jpeg_memory_mgr {
	pub alloc_small: ::core::option::Option<
		unsafe extern "C" fn(
			cinfo: j_common_ptr,
			pool_id: ::std::os::raw::c_int,
			sizeofobject: size_t,
		) -> *mut ::core::ffi::c_void,
	>,
	pub alloc_large: ::core::option::Option<
		unsafe extern "C" fn(
			cinfo: j_common_ptr,
			pool_id: ::std::os::raw::c_int,
			sizeofobject: size_t,
		) -> *mut ::core::ffi::c_void,
	>,
	pub alloc_sarray: ::core::option::Option<
		unsafe extern "C" fn(
			cinfo: j_common_ptr,
			pool_id: ::std::os::raw::c_int,
			samplesperrow: JDIMENSION,
			numrows: JDIMENSION,
		) -> JSAMPARRAY,
	>,
	pub alloc_barray: ::core::option::Option<
		unsafe extern "C" fn(
			cinfo: j_common_ptr,
			pool_id: ::std::os::raw::c_int,
			blocksperrow: JDIMENSION,
			numrows: JDIMENSION,
		) -> JBLOCKARRAY,
	>,
	pub request_virt_sarray: ::core::option::Option<
		unsafe extern "C" fn(
			cinfo: j_common_ptr,
			pool_id: ::std::os::raw::c_int,
			pre_zero: boolean,
			samplesperrow: JDIMENSION,
			numrows: JDIMENSION,
			maxaccess: JDIMENSION,
		) -> jvirt_sarray_ptr,
	>,
	pub request_virt_barray: ::core::option::Option<
		unsafe extern "C" fn(
			cinfo: j_common_ptr,
			pool_id: ::std::os::raw::c_int,
			pre_zero: boolean,
			blocksperrow: JDIMENSION,
			numrows: JDIMENSION,
			maxaccess: JDIMENSION,
		) -> jvirt_barray_ptr,
	>,
	pub realize_virt_arrays: ::core::option::Option<unsafe extern "C" fn(cinfo: j_common_ptr)>,
	pub access_virt_sarray: ::core::option::Option<
		unsafe extern "C" fn(
			cinfo: j_common_ptr,
			ptr: jvirt_sarray_ptr,
			start_row: JDIMENSION,
			num_rows: JDIMENSION,
			writable: boolean,
		) -> JSAMPARRAY,
	>,
	pub access_virt_barray: ::core::option::Option<
		unsafe extern "C" fn(
			cinfo: j_common_ptr,
			ptr: jvirt_barray_ptr,
			start_row: JDIMENSION,
			num_rows: JDIMENSION,
			writable: boolean,
		) -> JBLOCKARRAY,
	>,
	pub free_pool: ::core::option::Option<
		unsafe extern "C" fn(cinfo: j_common_ptr, pool_id: ::std::os::raw::c_int),
	>,
	pub self_destruct: ::core::option::Option<unsafe extern "C" fn(cinfo: j_common_ptr)>,
	pub max_memory_to_use: ::std::os::raw::c_long,
	pub max_alloc_chunk: ::std::os::raw::c_long,
}
#[test]
fn bindgen_test_layout_jpeg_memory_mgr() {
	assert_eq!(
		::core::mem::size_of::<jpeg_memory_mgr>(),
		104usize,
		concat!("Size of: ", stringify!(jpeg_memory_mgr))
	);
	assert_eq!(
		::core::mem::align_of::<jpeg_memory_mgr>(),
		8usize,
		concat!("Alignment of ", stringify!(jpeg_memory_mgr))
	);
	assert_eq!(
		unsafe { &(*(::core::ptr::null::<jpeg_memory_mgr>())).alloc_small as *const _ as usize },
		0usize,
		concat!(
			"Offset of field: ",
			stringify!(jpeg_memory_mgr),
			"::",
			stringify!(alloc_small)
		)
	);
	assert_eq!(
		unsafe { &(*(::core::ptr::null::<jpeg_memory_mgr>())).alloc_large as *const _ as usize },
		8usize,
		concat!(
			"Offset of field: ",
			stringify!(jpeg_memory_mgr),
			"::",
			stringify!(alloc_large)
		)
	);
	assert_eq!(
		unsafe { &(*(::core::ptr::null::<jpeg_memory_mgr>())).alloc_sarray as *const _ as usize },
		16usize,
		concat!(
			"Offset of field: ",
			stringify!(jpeg_memory_mgr),
			"::",
			stringify!(alloc_sarray)
		)
	);
	assert_eq!(
		unsafe { &(*(::core::ptr::null::<jpeg_memory_mgr>())).alloc_barray as *const _ as usize },
		24usize,
		concat!(
			"Offset of field: ",
			stringify!(jpeg_memory_mgr),
			"::",
			stringify!(alloc_barray)
		)
	);
	assert_eq!(
		unsafe {
			&(*(::core::ptr::null::<jpeg_memory_mgr>())).request_virt_sarray as *const _ as usize
		},
		32usize,
		concat!(
			"Offset of field: ",
			stringify!(jpeg_memory_mgr),
			"::",
			stringify!(request_virt_sarray)
		)
	);
	assert_eq!(
		unsafe {
			&(*(::core::ptr::null::<jpeg_memory_mgr>())).request_virt_barray as *const _ as usize
		},
		40usize,
		concat!(
			"Offset of field: ",
			stringify!(jpeg_memory_mgr),
			"::",
			stringify!(request_virt_barray)
		)
	);
	assert_eq!(
		unsafe {
			&(*(::core::ptr::null::<jpeg_memory_mgr>())).realize_virt_arrays as *const _ as usize
		},
		48usize,
		concat!(
			"Offset of field: ",
			stringify!(jpeg_memory_mgr),
			"::",
			stringify!(realize_virt_arrays)
		)
	);
	assert_eq!(
		unsafe {
			&(*(::core::ptr::null::<jpeg_memory_mgr>())).access_virt_sarray as *const _ as usize
		},
		56usize,
		concat!(
			"Offset of field: ",
			stringify!(jpeg_memory_mgr),
			"::",
			stringify!(access_virt_sarray)
		)
	);
	assert_eq!(
		unsafe {
			&(*(::core::ptr::null::<jpeg_memory_mgr>())).access_virt_barray as *const _ as usize
		},
		64usize,
		concat!(
			"Offset of field: ",
			stringify!(jpeg_memory_mgr),
			"::",
			stringify!(access_virt_barray)
		)
	);
	assert_eq!(
		unsafe { &(*(::core::ptr::null::<jpeg_memory_mgr>())).free_pool as *const _ as usize },
		72usize,
		concat!(
			"Offset of field: ",
			stringify!(jpeg_memory_mgr),
			"::",
			stringify!(free_pool)
		)
	);
	assert_eq!(
		unsafe { &(*(::core::ptr::null::<jpeg_memory_mgr>())).self_destruct as *const _ as usize },
		80usize,
		concat!(
			"Offset of field: ",
			stringify!(jpeg_memory_mgr),
			"::",
			stringify!(self_destruct)
		)
	);
	assert_eq!(
		unsafe {
			&(*(::core::ptr::null::<jpeg_memory_mgr>())).max_memory_to_use as *const _ as usize
		},
		88usize,
		concat!(
			"Offset of field: ",
			stringify!(jpeg_memory_mgr),
			"::",
			stringify!(max_memory_to_use)
		)
	);
	assert_eq!(
		unsafe {
			&(*(::core::ptr::null::<jpeg_memory_mgr>())).max_alloc_chunk as *const _ as usize
		},
		96usize,
		concat!(
			"Offset of field: ",
			stringify!(jpeg_memory_mgr),
			"::",
			stringify!(max_alloc_chunk)
		)
	);
}
pub type jpeg_marker_parser_method =
	::core::option::Option<unsafe extern "C" fn(cinfo: j_decompress_ptr) -> boolean>;
extern "C" {
	pub fn jpeg_std_error(err: *mut jpeg_error_mgr) -> *mut jpeg_error_mgr;
}
extern "C" {
	pub fn jpeg_CreateCompress(
		cinfo: j_compress_ptr,
		version: ::std::os::raw::c_int,
		structsize: size_t,
	);
}
extern "C" {
	pub fn jpeg_CreateDecompress(
		cinfo: j_decompress_ptr,
		version: ::std::os::raw::c_int,
		structsize: size_t,
	);
}
extern "C" {
	pub fn jpeg_destroy_compress(cinfo: j_compress_ptr);
}
extern "C" {
	pub fn jpeg_destroy_decompress(cinfo: j_decompress_ptr);
}
extern "C" {
	pub fn jpeg_stdio_dest(cinfo: j_compress_ptr, outfile: *mut FILE);
}
extern "C" {
	pub fn jpeg_stdio_src(cinfo: j_decompress_ptr, infile: *mut FILE);
}
extern "C" {
	pub fn jpeg_mem_dest(
		cinfo: j_compress_ptr,
		outbuffer: *mut *mut ::std::os::raw::c_uchar,
		outsize: *mut ::std::os::raw::c_ulong,
	);
}
extern "C" {
	pub fn jpeg_mem_src(
		cinfo: j_decompress_ptr,
		inbuffer: *const ::std::os::raw::c_uchar,
		insize: ::std::os::raw::c_ulong,
	);
}
extern "C" {
	pub fn jpeg_set_defaults(cinfo: j_compress_ptr);
}
extern "C" {
	pub fn jpeg_set_colorspace(cinfo: j_compress_ptr, colorspace: J_COLOR_SPACE);
}
extern "C" {
	pub fn jpeg_default_colorspace(cinfo: j_compress_ptr);
}
extern "C" {
	pub fn jpeg_set_quality(
		cinfo: j_compress_ptr,
		quality: ::std::os::raw::c_int,
		force_baseline: boolean,
	);
}
extern "C" {
	pub fn jpeg_set_linear_quality(
		cinfo: j_compress_ptr,
		scale_factor: ::std::os::raw::c_int,
		force_baseline: boolean,
	);
}
extern "C" {
	pub fn jpeg_add_quant_table(
		cinfo: j_compress_ptr,
		which_tbl: ::std::os::raw::c_int,
		basic_table: *const ::std::os::raw::c_uint,
		scale_factor: ::std::os::raw::c_int,
		force_baseline: boolean,
	);
}
extern "C" {
	pub fn jpeg_quality_scaling(quality: ::std::os::raw::c_int) -> ::std::os::raw::c_int;
}
extern "C" {
	pub fn jpeg_float_quality_scaling(quality: f32) -> f32;
}
extern "C" {
	pub fn jpeg_simple_progression(cinfo: j_compress_ptr);
}
extern "C" {
	pub fn jpeg_suppress_tables(cinfo: j_compress_ptr, suppress: boolean);
}
extern "C" {
	pub fn jpeg_alloc_quant_table(cinfo: j_common_ptr) -> *mut JQUANT_TBL;
}
extern "C" {
	pub fn jpeg_alloc_huff_table(cinfo: j_common_ptr) -> *mut JHUFF_TBL;
}
extern "C" {
	pub fn jpeg_start_compress(cinfo: j_compress_ptr, write_all_tables: boolean);
}
extern "C" {
	pub fn jpeg_write_scanlines(
		cinfo: j_compress_ptr,
		scanlines: JSAMPARRAY,
		num_lines: JDIMENSION,
	) -> JDIMENSION;
}
extern "C" {
	pub fn jpeg_finish_compress(cinfo: j_compress_ptr);
}
extern "C" {
	pub fn jpeg_write_raw_data(
		cinfo: j_compress_ptr,
		data: JSAMPIMAGE,
		num_lines: JDIMENSION,
	) -> JDIMENSION;
}
extern "C" {
	pub fn jpeg_write_marker(
		cinfo: j_compress_ptr,
		marker: ::std::os::raw::c_int,
		dataptr: *const JOCTET,
		datalen: ::std::os::raw::c_uint,
	);
}
extern "C" {
	pub fn jpeg_write_m_header(
		cinfo: j_compress_ptr,
		marker: ::std::os::raw::c_int,
		datalen: ::std::os::raw::c_uint,
	);
}
extern "C" {
	pub fn jpeg_write_m_byte(cinfo: j_compress_ptr, val: ::std::os::raw::c_int);
}
extern "C" {
	pub fn jpeg_write_tables(cinfo: j_compress_ptr);
}
extern "C" {
	pub fn jpeg_write_icc_profile(
		cinfo: j_compress_ptr,
		icc_data_ptr: *const JOCTET,
		icc_data_len: ::std::os::raw::c_uint,
	);
}
extern "C" {
	pub fn jpeg_read_header(
		cinfo: j_decompress_ptr,
		require_image: boolean,
	) -> ::std::os::raw::c_int;
}
extern "C" {
	pub fn jpeg_start_decompress(cinfo: j_decompress_ptr) -> boolean;
}
extern "C" {
	pub fn jpeg_read_scanlines(
		cinfo: j_decompress_ptr,
		scanlines: JSAMPARRAY,
		max_lines: JDIMENSION,
	) -> JDIMENSION;
}
extern "C" {
	pub fn jpeg_skip_scanlines(cinfo: j_decompress_ptr, num_lines: JDIMENSION) -> JDIMENSION;
}
extern "C" {
	pub fn jpeg_crop_scanline(
		cinfo: j_decompress_ptr,
		xoffset: *mut JDIMENSION,
		width: *mut JDIMENSION,
	);
}
extern "C" {
	pub fn jpeg_finish_decompress(cinfo: j_decompress_ptr) -> boolean;
}
extern "C" {
	pub fn jpeg_read_raw_data(
		cinfo: j_decompress_ptr,
		data: JSAMPIMAGE,
		max_lines: JDIMENSION,
	) -> JDIMENSION;
}
extern "C" {
	pub fn jpeg_has_multiple_scans(cinfo: j_decompress_ptr) -> boolean;
}
extern "C" {
	pub fn jpeg_start_output(
		cinfo: j_decompress_ptr,
		scan_number: ::std::os::raw::c_int,
	) -> boolean;
}
extern "C" {
	pub fn jpeg_finish_output(cinfo: j_decompress_ptr) -> boolean;
}
extern "C" {
	pub fn jpeg_input_complete(cinfo: j_decompress_ptr) -> boolean;
}
extern "C" {
	pub fn jpeg_new_colormap(cinfo: j_decompress_ptr);
}
extern "C" {
	pub fn jpeg_consume_input(cinfo: j_decompress_ptr) -> ::std::os::raw::c_int;
}
extern "C" {
	pub fn jpeg_calc_output_dimensions(cinfo: j_decompress_ptr);
}
extern "C" {
	pub fn jpeg_save_markers(
		cinfo: j_decompress_ptr,
		marker_code: ::std::os::raw::c_int,
		length_limit: ::std::os::raw::c_uint,
	);
}
extern "C" {
	pub fn jpeg_set_marker_processor(
		cinfo: j_decompress_ptr,
		marker_code: ::std::os::raw::c_int,
		routine: jpeg_marker_parser_method,
	);
}
extern "C" {
	pub fn jpeg_read_coefficients(cinfo: j_decompress_ptr) -> *mut jvirt_barray_ptr;
}
extern "C" {
	pub fn jpeg_write_coefficients(cinfo: j_compress_ptr, coef_arrays: *mut jvirt_barray_ptr);
}
extern "C" {
	pub fn jpeg_copy_critical_parameters(srcinfo: j_decompress_ptr, dstinfo: j_compress_ptr);
}
extern "C" {
	pub fn jpeg_abort_compress(cinfo: j_compress_ptr);
}
extern "C" {
	pub fn jpeg_abort_decompress(cinfo: j_decompress_ptr);
}
extern "C" {
	pub fn jpeg_abort(cinfo: j_common_ptr);
}
extern "C" {
	pub fn jpeg_destroy(cinfo: j_common_ptr);
}
extern "C" {
	pub fn jpeg_resync_to_restart(
		cinfo: j_decompress_ptr,
		desired: ::std::os::raw::c_int,
	) -> boolean;
}
extern "C" {
	pub fn jpeg_c_bool_param_supported(cinfo: j_compress_ptr, param: J_BOOLEAN_PARAM) -> boolean;
}
extern "C" {
	pub fn jpeg_c_set_bool_param(cinfo: j_compress_ptr, param: J_BOOLEAN_PARAM, value: boolean);
}
extern "C" {
	pub fn jpeg_c_get_bool_param(cinfo: j_compress_ptr, param: J_BOOLEAN_PARAM) -> boolean;
}
extern "C" {
	pub fn jpeg_c_float_param_supported(cinfo: j_compress_ptr, param: J_FLOAT_PARAM) -> boolean;
}
extern "C" {
	pub fn jpeg_c_set_float_param(cinfo: j_compress_ptr, param: J_FLOAT_PARAM, value: f32);
}
extern "C" {
	pub fn jpeg_c_get_float_param(cinfo: j_compress_ptr, param: J_FLOAT_PARAM) -> f32;
}
extern "C" {
	pub fn jpeg_c_int_param_supported(cinfo: j_compress_ptr, param: J_INT_PARAM) -> boolean;
}
extern "C" {
	pub fn jpeg_c_set_int_param(
		cinfo: j_compress_ptr,
		param: J_INT_PARAM,
		value: ::std::os::raw::c_int,
	);
}
extern "C" {
	pub fn jpeg_c_get_int_param(cinfo: j_compress_ptr, param: J_INT_PARAM)
		-> ::std::os::raw::c_int;
}
extern "C" {
	pub fn jpeg_read_icc_profile(
		cinfo: j_decompress_ptr,
		icc_data_ptr: *mut *mut JOCTET,
		icc_data_len: *mut ::std::os::raw::c_uint,
	) -> boolean;
}
extern "C" {
	pub fn jpeg_set_idct_method_selector(
		cinfo: j_decompress_ptr,
		selector: jpeg_idct_method_selector,
	);
}
pub const J_MESSAGE_CODE_JMSG_NOMESSAGE: J_MESSAGE_CODE = 0;
pub const J_MESSAGE_CODE_JERR_ARITH_NOTIMPL: J_MESSAGE_CODE = 1;
pub const J_MESSAGE_CODE_JERR_BAD_ALIGN_TYPE: J_MESSAGE_CODE = 2;
pub const J_MESSAGE_CODE_JERR_BAD_ALLOC_CHUNK: J_MESSAGE_CODE = 3;
pub const J_MESSAGE_CODE_JERR_BAD_BUFFER_MODE: J_MESSAGE_CODE = 4;
pub const J_MESSAGE_CODE_JERR_BAD_COMPONENT_ID: J_MESSAGE_CODE = 5;
pub const J_MESSAGE_CODE_JERR_BAD_DCT_COEF: J_MESSAGE_CODE = 6;
pub const J_MESSAGE_CODE_JERR_BAD_DCTSIZE: J_MESSAGE_CODE = 7;
pub const J_MESSAGE_CODE_JERR_BAD_HUFF_TABLE: J_MESSAGE_CODE = 8;
pub const J_MESSAGE_CODE_JERR_BAD_IN_COLORSPACE: J_MESSAGE_CODE = 9;
pub const J_MESSAGE_CODE_JERR_BAD_J_COLORSPACE: J_MESSAGE_CODE = 10;
pub const J_MESSAGE_CODE_JERR_BAD_LENGTH: J_MESSAGE_CODE = 11;
pub const J_MESSAGE_CODE_JERR_BAD_LIB_VERSION: J_MESSAGE_CODE = 12;
pub const J_MESSAGE_CODE_JERR_BAD_MCU_SIZE: J_MESSAGE_CODE = 13;
pub const J_MESSAGE_CODE_JERR_BAD_POOL_ID: J_MESSAGE_CODE = 14;
pub const J_MESSAGE_CODE_JERR_BAD_PRECISION: J_MESSAGE_CODE = 15;
pub const J_MESSAGE_CODE_JERR_BAD_PROGRESSION: J_MESSAGE_CODE = 16;
pub const J_MESSAGE_CODE_JERR_BAD_PROG_SCRIPT: J_MESSAGE_CODE = 17;
pub const J_MESSAGE_CODE_JERR_BAD_SAMPLING: J_MESSAGE_CODE = 18;
pub const J_MESSAGE_CODE_JERR_BAD_SCAN_SCRIPT: J_MESSAGE_CODE = 19;
pub const J_MESSAGE_CODE_JERR_BAD_STATE: J_MESSAGE_CODE = 20;
pub const J_MESSAGE_CODE_JERR_BAD_STRUCT_SIZE: J_MESSAGE_CODE = 21;
pub const J_MESSAGE_CODE_JERR_BAD_VIRTUAL_ACCESS: J_MESSAGE_CODE = 22;
pub const J_MESSAGE_CODE_JERR_BUFFER_SIZE: J_MESSAGE_CODE = 23;
pub const J_MESSAGE_CODE_JERR_CANT_SUSPEND: J_MESSAGE_CODE = 24;
pub const J_MESSAGE_CODE_JERR_CCIR601_NOTIMPL: J_MESSAGE_CODE = 25;
pub const J_MESSAGE_CODE_JERR_COMPONENT_COUNT: J_MESSAGE_CODE = 26;
pub const J_MESSAGE_CODE_JERR_CONVERSION_NOTIMPL: J_MESSAGE_CODE = 27;
pub const J_MESSAGE_CODE_JERR_DAC_INDEX: J_MESSAGE_CODE = 28;
pub const J_MESSAGE_CODE_JERR_DAC_VALUE: J_MESSAGE_CODE = 29;
pub const J_MESSAGE_CODE_JERR_DHT_INDEX: J_MESSAGE_CODE = 30;
pub const J_MESSAGE_CODE_JERR_DQT_INDEX: J_MESSAGE_CODE = 31;
pub const J_MESSAGE_CODE_JERR_EMPTY_IMAGE: J_MESSAGE_CODE = 32;
pub const J_MESSAGE_CODE_JERR_EMS_READ: J_MESSAGE_CODE = 33;
pub const J_MESSAGE_CODE_JERR_EMS_WRITE: J_MESSAGE_CODE = 34;
pub const J_MESSAGE_CODE_JERR_EOI_EXPECTED: J_MESSAGE_CODE = 35;
pub const J_MESSAGE_CODE_JERR_FILE_READ: J_MESSAGE_CODE = 36;
pub const J_MESSAGE_CODE_JERR_FILE_WRITE: J_MESSAGE_CODE = 37;
pub const J_MESSAGE_CODE_JERR_FRACT_SAMPLE_NOTIMPL: J_MESSAGE_CODE = 38;
pub const J_MESSAGE_CODE_JERR_HUFF_CLEN_OVERFLOW: J_MESSAGE_CODE = 39;
pub const J_MESSAGE_CODE_JERR_HUFF_MISSING_CODE: J_MESSAGE_CODE = 40;
pub const J_MESSAGE_CODE_JERR_IMAGE_TOO_BIG: J_MESSAGE_CODE = 41;
pub const J_MESSAGE_CODE_JERR_INPUT_EMPTY: J_MESSAGE_CODE = 42;
pub const J_MESSAGE_CODE_JERR_INPUT_EOF: J_MESSAGE_CODE = 43;
pub const J_MESSAGE_CODE_JERR_MISMATCHED_QUANT_TABLE: J_MESSAGE_CODE = 44;
pub const J_MESSAGE_CODE_JERR_MISSING_DATA: J_MESSAGE_CODE = 45;
pub const J_MESSAGE_CODE_JERR_MODE_CHANGE: J_MESSAGE_CODE = 46;
pub const J_MESSAGE_CODE_JERR_NOTIMPL: J_MESSAGE_CODE = 47;
pub const J_MESSAGE_CODE_JERR_NOT_COMPILED: J_MESSAGE_CODE = 48;
pub const J_MESSAGE_CODE_JERR_NO_BACKING_STORE: J_MESSAGE_CODE = 49;
pub const J_MESSAGE_CODE_JERR_NO_HUFF_TABLE: J_MESSAGE_CODE = 50;
pub const J_MESSAGE_CODE_JERR_NO_IMAGE: J_MESSAGE_CODE = 51;
pub const J_MESSAGE_CODE_JERR_NO_QUANT_TABLE: J_MESSAGE_CODE = 52;
pub const J_MESSAGE_CODE_JERR_NO_SOI: J_MESSAGE_CODE = 53;
pub const J_MESSAGE_CODE_JERR_OUT_OF_MEMORY: J_MESSAGE_CODE = 54;
pub const J_MESSAGE_CODE_JERR_QUANT_COMPONENTS: J_MESSAGE_CODE = 55;
pub const J_MESSAGE_CODE_JERR_QUANT_FEW_COLORS: J_MESSAGE_CODE = 56;
pub const J_MESSAGE_CODE_JERR_QUANT_MANY_COLORS: J_MESSAGE_CODE = 57;
pub const J_MESSAGE_CODE_JERR_SOF_DUPLICATE: J_MESSAGE_CODE = 58;
pub const J_MESSAGE_CODE_JERR_SOF_NO_SOS: J_MESSAGE_CODE = 59;
pub const J_MESSAGE_CODE_JERR_SOF_UNSUPPORTED: J_MESSAGE_CODE = 60;
pub const J_MESSAGE_CODE_JERR_SOI_DUPLICATE: J_MESSAGE_CODE = 61;
pub const J_MESSAGE_CODE_JERR_SOS_NO_SOF: J_MESSAGE_CODE = 62;
pub const J_MESSAGE_CODE_JERR_TFILE_CREATE: J_MESSAGE_CODE = 63;
pub const J_MESSAGE_CODE_JERR_TFILE_READ: J_MESSAGE_CODE = 64;
pub const J_MESSAGE_CODE_JERR_TFILE_SEEK: J_MESSAGE_CODE = 65;
pub const J_MESSAGE_CODE_JERR_TFILE_WRITE: J_MESSAGE_CODE = 66;
pub const J_MESSAGE_CODE_JERR_TOO_LITTLE_DATA: J_MESSAGE_CODE = 67;
pub const J_MESSAGE_CODE_JERR_UNKNOWN_MARKER: J_MESSAGE_CODE = 68;
pub const J_MESSAGE_CODE_JERR_VIRTUAL_BUG: J_MESSAGE_CODE = 69;
pub const J_MESSAGE_CODE_JERR_WIDTH_OVERFLOW: J_MESSAGE_CODE = 70;
pub const J_MESSAGE_CODE_JERR_XMS_READ: J_MESSAGE_CODE = 71;
pub const J_MESSAGE_CODE_JERR_XMS_WRITE: J_MESSAGE_CODE = 72;
pub const J_MESSAGE_CODE_JMSG_COPYRIGHT: J_MESSAGE_CODE = 73;
pub const J_MESSAGE_CODE_JMSG_VERSION: J_MESSAGE_CODE = 74;
pub const J_MESSAGE_CODE_JTRC_16BIT_TABLES: J_MESSAGE_CODE = 75;
pub const J_MESSAGE_CODE_JTRC_ADOBE: J_MESSAGE_CODE = 76;
pub const J_MESSAGE_CODE_JTRC_APP0: J_MESSAGE_CODE = 77;
pub const J_MESSAGE_CODE_JTRC_APP14: J_MESSAGE_CODE = 78;
pub const J_MESSAGE_CODE_JTRC_DAC: J_MESSAGE_CODE = 79;
pub const J_MESSAGE_CODE_JTRC_DHT: J_MESSAGE_CODE = 80;
pub const J_MESSAGE_CODE_JTRC_DQT: J_MESSAGE_CODE = 81;
pub const J_MESSAGE_CODE_JTRC_DRI: J_MESSAGE_CODE = 82;
pub const J_MESSAGE_CODE_JTRC_EMS_CLOSE: J_MESSAGE_CODE = 83;
pub const J_MESSAGE_CODE_JTRC_EMS_OPEN: J_MESSAGE_CODE = 84;
pub const J_MESSAGE_CODE_JTRC_EOI: J_MESSAGE_CODE = 85;
pub const J_MESSAGE_CODE_JTRC_HUFFBITS: J_MESSAGE_CODE = 86;
pub const J_MESSAGE_CODE_JTRC_JFIF: J_MESSAGE_CODE = 87;
pub const J_MESSAGE_CODE_JTRC_JFIF_BADTHUMBNAILSIZE: J_MESSAGE_CODE = 88;
pub const J_MESSAGE_CODE_JTRC_JFIF_EXTENSION: J_MESSAGE_CODE = 89;
pub const J_MESSAGE_CODE_JTRC_JFIF_THUMBNAIL: J_MESSAGE_CODE = 90;
pub const J_MESSAGE_CODE_JTRC_MISC_MARKER: J_MESSAGE_CODE = 91;
pub const J_MESSAGE_CODE_JTRC_PARMLESS_MARKER: J_MESSAGE_CODE = 92;
pub const J_MESSAGE_CODE_JTRC_QUANTVALS: J_MESSAGE_CODE = 93;
pub const J_MESSAGE_CODE_JTRC_QUANT_3_NCOLORS: J_MESSAGE_CODE = 94;
pub const J_MESSAGE_CODE_JTRC_QUANT_NCOLORS: J_MESSAGE_CODE = 95;
pub const J_MESSAGE_CODE_JTRC_QUANT_SELECTED: J_MESSAGE_CODE = 96;
pub const J_MESSAGE_CODE_JTRC_RECOVERY_ACTION: J_MESSAGE_CODE = 97;
pub const J_MESSAGE_CODE_JTRC_RST: J_MESSAGE_CODE = 98;
pub const J_MESSAGE_CODE_JTRC_SMOOTH_NOTIMPL: J_MESSAGE_CODE = 99;
pub const J_MESSAGE_CODE_JTRC_SOF: J_MESSAGE_CODE = 100;
pub const J_MESSAGE_CODE_JTRC_SOF_COMPONENT: J_MESSAGE_CODE = 101;
pub const J_MESSAGE_CODE_JTRC_SOI: J_MESSAGE_CODE = 102;
pub const J_MESSAGE_CODE_JTRC_SOS: J_MESSAGE_CODE = 103;
pub const J_MESSAGE_CODE_JTRC_SOS_COMPONENT: J_MESSAGE_CODE = 104;
pub const J_MESSAGE_CODE_JTRC_SOS_PARAMS: J_MESSAGE_CODE = 105;
pub const J_MESSAGE_CODE_JTRC_TFILE_CLOSE: J_MESSAGE_CODE = 106;
pub const J_MESSAGE_CODE_JTRC_TFILE_OPEN: J_MESSAGE_CODE = 107;
pub const J_MESSAGE_CODE_JTRC_THUMB_JPEG: J_MESSAGE_CODE = 108;
pub const J_MESSAGE_CODE_JTRC_THUMB_PALETTE: J_MESSAGE_CODE = 109;
pub const J_MESSAGE_CODE_JTRC_THUMB_RGB: J_MESSAGE_CODE = 110;
pub const J_MESSAGE_CODE_JTRC_UNKNOWN_IDS: J_MESSAGE_CODE = 111;
pub const J_MESSAGE_CODE_JTRC_XMS_CLOSE: J_MESSAGE_CODE = 112;
pub const J_MESSAGE_CODE_JTRC_XMS_OPEN: J_MESSAGE_CODE = 113;
pub const J_MESSAGE_CODE_JWRN_ADOBE_XFORM: J_MESSAGE_CODE = 114;
pub const J_MESSAGE_CODE_JWRN_BOGUS_PROGRESSION: J_MESSAGE_CODE = 115;
pub const J_MESSAGE_CODE_JWRN_EXTRANEOUS_DATA: J_MESSAGE_CODE = 116;
pub const J_MESSAGE_CODE_JWRN_HIT_MARKER: J_MESSAGE_CODE = 117;
pub const J_MESSAGE_CODE_JWRN_HUFF_BAD_CODE: J_MESSAGE_CODE = 118;
pub const J_MESSAGE_CODE_JWRN_JFIF_MAJOR: J_MESSAGE_CODE = 119;
pub const J_MESSAGE_CODE_JWRN_JPEG_EOF: J_MESSAGE_CODE = 120;
pub const J_MESSAGE_CODE_JWRN_MUST_RESYNC: J_MESSAGE_CODE = 121;
pub const J_MESSAGE_CODE_JWRN_NOT_SEQUENTIAL: J_MESSAGE_CODE = 122;
pub const J_MESSAGE_CODE_JWRN_TOO_MUCH_DATA: J_MESSAGE_CODE = 123;
pub const J_MESSAGE_CODE_JERR_BAD_CROP_SPEC: J_MESSAGE_CODE = 124;
pub const J_MESSAGE_CODE_JERR_BAD_PARAM: J_MESSAGE_CODE = 125;
pub const J_MESSAGE_CODE_JERR_BAD_PARAM_VALUE: J_MESSAGE_CODE = 126;
pub const J_MESSAGE_CODE_JERR_UNSUPPORTED_SUSPEND: J_MESSAGE_CODE = 127;
pub const J_MESSAGE_CODE_JWRN_BOGUS_ICC: J_MESSAGE_CODE = 128;
pub const J_MESSAGE_CODE_JMSG_LASTMSGCODE: J_MESSAGE_CODE = 129;
pub type J_MESSAGE_CODE = u32;
#[doc = " 4:4:4 chrominance subsampling (no chrominance subsampling).  The JPEG or"]
#[doc = " YUV image will contain one chrominance component for every pixel in the"]
#[doc = " source image."]
pub const TJSAMP_TJSAMP_444: TJSAMP = 0;
#[doc = " 4:2:2 chrominance subsampling.  The JPEG or YUV image will contain one"]
#[doc = " chrominance component for every 2x1 block of pixels in the source image."]
pub const TJSAMP_TJSAMP_422: TJSAMP = 1;
#[doc = " 4:2:0 chrominance subsampling.  The JPEG or YUV image will contain one"]
#[doc = " chrominance component for every 2x2 block of pixels in the source image."]
pub const TJSAMP_TJSAMP_420: TJSAMP = 2;
#[doc = " Grayscale.  The JPEG or YUV image will contain no chrominance components."]
pub const TJSAMP_TJSAMP_GRAY: TJSAMP = 3;
#[doc = " 4:4:0 chrominance subsampling.  The JPEG or YUV image will contain one"]
#[doc = " chrominance component for every 1x2 block of pixels in the source image."]
#[doc = ""]
#[doc = " @note 4:4:0 subsampling is not fully accelerated in libjpeg-turbo."]
pub const TJSAMP_TJSAMP_440: TJSAMP = 4;
#[doc = " 4:1:1 chrominance subsampling.  The JPEG or YUV image will contain one"]
#[doc = " chrominance component for every 4x1 block of pixels in the source image."]
#[doc = " JPEG images compressed with 4:1:1 subsampling will be almost exactly the"]
#[doc = " same size as those compressed with 4:2:0 subsampling, and in the"]
#[doc = " aggregate, both subsampling methods produce approximately the same"]
#[doc = " perceptual quality.  However, 4:1:1 is better able to reproduce sharp"]
#[doc = " horizontal features."]
#[doc = ""]
#[doc = " @note 4:1:1 subsampling is not fully accelerated in libjpeg-turbo."]
pub const TJSAMP_TJSAMP_411: TJSAMP = 5;
#[doc = " Chrominance subsampling options."]
#[doc = " When pixels are converted from RGB to YCbCr (see #TJCS_YCbCr) or from CMYK"]
#[doc = " to YCCK (see #TJCS_YCCK) as part of the JPEG compression process, some of"]
#[doc = " the Cb and Cr (chrominance) components can be discarded or averaged together"]
#[doc = " to produce a smaller image with little perceptible loss of image clarity"]
#[doc = " (the human eye is more sensitive to small changes in brightness than to"]
#[doc = " small changes in color.)  This is called \"chrominance subsampling\"."]
pub type TJSAMP = u32;
extern "C" {
	pub static tjMCUWidth: [::std::os::raw::c_int; 6usize];
}
extern "C" {
	pub static tjMCUHeight: [::std::os::raw::c_int; 6usize];
}
#[doc = " RGB pixel format.  The red, green, and blue components in the image are"]
#[doc = " stored in 3-byte pixels in the order R, G, B from lowest to highest byte"]
#[doc = " address within each pixel."]
pub const TJPF_TJPF_RGB: TJPF = 0;
#[doc = " BGR pixel format.  The red, green, and blue components in the image are"]
#[doc = " stored in 3-byte pixels in the order B, G, R from lowest to highest byte"]
#[doc = " address within each pixel."]
pub const TJPF_TJPF_BGR: TJPF = 1;
#[doc = " RGBX pixel format.  The red, green, and blue components in the image are"]
#[doc = " stored in 4-byte pixels in the order R, G, B from lowest to highest byte"]
#[doc = " address within each pixel.  The X component is ignored when compressing"]
#[doc = " and undefined when decompressing."]
pub const TJPF_TJPF_RGBX: TJPF = 2;
#[doc = " BGRX pixel format.  The red, green, and blue components in the image are"]
#[doc = " stored in 4-byte pixels in the order B, G, R from lowest to highest byte"]
#[doc = " address within each pixel.  The X component is ignored when compressing"]
#[doc = " and undefined when decompressing."]
pub const TJPF_TJPF_BGRX: TJPF = 3;
#[doc = " XBGR pixel format.  The red, green, and blue components in the image are"]
#[doc = " stored in 4-byte pixels in the order R, G, B from highest to lowest byte"]
#[doc = " address within each pixel.  The X component is ignored when compressing"]
#[doc = " and undefined when decompressing."]
pub const TJPF_TJPF_XBGR: TJPF = 4;
#[doc = " XRGB pixel format.  The red, green, and blue components in the image are"]
#[doc = " stored in 4-byte pixels in the order B, G, R from highest to lowest byte"]
#[doc = " address within each pixel.  The X component is ignored when compressing"]
#[doc = " and undefined when decompressing."]
pub const TJPF_TJPF_XRGB: TJPF = 5;
#[doc = " Grayscale pixel format.  Each 1-byte pixel represents a luminance"]
#[doc = " (brightness) level from 0 to 255."]
pub const TJPF_TJPF_GRAY: TJPF = 6;
#[doc = " RGBA pixel format.  This is the same as @ref TJPF_RGBX, except that when"]
#[doc = " decompressing, the X component is guaranteed to be 0xFF, which can be"]
#[doc = " interpreted as an opaque alpha channel."]
pub const TJPF_TJPF_RGBA: TJPF = 7;
#[doc = " BGRA pixel format.  This is the same as @ref TJPF_BGRX, except that when"]
#[doc = " decompressing, the X component is guaranteed to be 0xFF, which can be"]
#[doc = " interpreted as an opaque alpha channel."]
pub const TJPF_TJPF_BGRA: TJPF = 8;
#[doc = " ABGR pixel format.  This is the same as @ref TJPF_XBGR, except that when"]
#[doc = " decompressing, the X component is guaranteed to be 0xFF, which can be"]
#[doc = " interpreted as an opaque alpha channel."]
pub const TJPF_TJPF_ABGR: TJPF = 9;
#[doc = " ARGB pixel format.  This is the same as @ref TJPF_XRGB, except that when"]
#[doc = " decompressing, the X component is guaranteed to be 0xFF, which can be"]
#[doc = " interpreted as an opaque alpha channel."]
pub const TJPF_TJPF_ARGB: TJPF = 10;
#[doc = " CMYK pixel format.  Unlike RGB, which is an additive color model used"]
#[doc = " primarily for display, CMYK (Cyan/Magenta/Yellow/Key) is a subtractive"]
#[doc = " color model used primarily for printing.  In the CMYK color model, the"]
#[doc = " value of each color component typically corresponds to an amount of cyan,"]
#[doc = " magenta, yellow, or black ink that is applied to a white background.  In"]
#[doc = " order to convert between CMYK and RGB, it is necessary to use a color"]
#[doc = " management system (CMS.)  A CMS will attempt to map colors within the"]
#[doc = " printer's gamut to perceptually similar colors in the display's gamut and"]
#[doc = " vice versa, but the mapping is typically not 1:1 or reversible, nor can it"]
#[doc = " be defined with a simple formula.  Thus, such a conversion is out of scope"]
#[doc = " for a codec library.  However, the TurboJPEG API allows for compressing"]
#[doc = " CMYK pixels into a YCCK JPEG image (see #TJCS_YCCK) and decompressing YCCK"]
#[doc = " JPEG images into CMYK pixels."]
pub const TJPF_TJPF_CMYK: TJPF = 11;
#[doc = " Unknown pixel format.  Currently this is only used by #tjLoadImage()."]
pub const TJPF_TJPF_UNKNOWN: TJPF = -1;
#[doc = " Pixel formats"]
pub type TJPF = i32;
extern "C" {
	pub static tjRedOffset: [::std::os::raw::c_int; 12usize];
}
extern "C" {
	pub static tjGreenOffset: [::std::os::raw::c_int; 12usize];
}
extern "C" {
	pub static tjBlueOffset: [::std::os::raw::c_int; 12usize];
}
extern "C" {
	pub static tjAlphaOffset: [::std::os::raw::c_int; 12usize];
}
extern "C" {
	pub static tjPixelSize: [::std::os::raw::c_int; 12usize];
}
#[doc = " RGB colorspace.  When compressing the JPEG image, the R, G, and B"]
#[doc = " components in the source image are reordered into image planes, but no"]
#[doc = " colorspace conversion or subsampling is performed.  RGB JPEG images can be"]
#[doc = " decompressed to any of the extended RGB pixel formats or grayscale, but"]
#[doc = " they cannot be decompressed to YUV images."]
pub const TJCS_TJCS_RGB: TJCS = 0;
#[doc = " YCbCr colorspace.  YCbCr is not an absolute colorspace but rather a"]
#[doc = " mathematical transformation of RGB designed solely for storage and"]
#[doc = " transmission.  YCbCr images must be converted to RGB before they can"]
#[doc = " actually be displayed.  In the YCbCr colorspace, the Y (luminance)"]
#[doc = " component represents the black & white portion of the original image, and"]
#[doc = " the Cb and Cr (chrominance) components represent the color portion of the"]
#[doc = " original image.  Originally, the analog equivalent of this transformation"]
#[doc = " allowed the same signal to drive both black & white and color televisions,"]
#[doc = " but JPEG images use YCbCr primarily because it allows the color data to be"]
#[doc = " optionally subsampled for the purposes of reducing bandwidth or disk"]
#[doc = " space.  YCbCr is the most common JPEG colorspace, and YCbCr JPEG images"]
#[doc = " can be compressed from and decompressed to any of the extended RGB pixel"]
#[doc = " formats or grayscale, or they can be decompressed to YUV planar images."]
pub const TJCS_TJCS_YCbCr: TJCS = 1;
#[doc = " Grayscale colorspace.  The JPEG image retains only the luminance data (Y"]
#[doc = " component), and any color data from the source image is discarded."]
#[doc = " Grayscale JPEG images can be compressed from and decompressed to any of"]
#[doc = " the extended RGB pixel formats or grayscale, or they can be decompressed"]
#[doc = " to YUV planar images."]
pub const TJCS_TJCS_GRAY: TJCS = 2;
#[doc = " CMYK colorspace.  When compressing the JPEG image, the C, M, Y, and K"]
#[doc = " components in the source image are reordered into image planes, but no"]
#[doc = " colorspace conversion or subsampling is performed.  CMYK JPEG images can"]
#[doc = " only be decompressed to CMYK pixels."]
pub const TJCS_TJCS_CMYK: TJCS = 3;
#[doc = " YCCK colorspace.  YCCK (AKA \"YCbCrK\") is not an absolute colorspace but"]
#[doc = " rather a mathematical transformation of CMYK designed solely for storage"]
#[doc = " and transmission.  It is to CMYK as YCbCr is to RGB.  CMYK pixels can be"]
#[doc = " reversibly transformed into YCCK, and as with YCbCr, the chrominance"]
#[doc = " components in the YCCK pixels can be subsampled without incurring major"]
#[doc = " perceptual loss.  YCCK JPEG images can only be compressed from and"]
#[doc = " decompressed to CMYK pixels."]
pub const TJCS_TJCS_YCCK: TJCS = 4;
#[doc = " JPEG colorspaces"]
pub type TJCS = u32;
#[doc = " The error was non-fatal and recoverable, but the image may still be"]
#[doc = " corrupt."]
pub const TJERR_TJERR_WARNING: TJERR = 0;
#[doc = " The error was fatal and non-recoverable."]
pub const TJERR_TJERR_FATAL: TJERR = 1;
#[doc = " Error codes"]
pub type TJERR = u32;
#[doc = " Do not transform the position of the image pixels"]
pub const TJXOP_TJXOP_NONE: TJXOP = 0;
#[doc = " Flip (mirror) image horizontally.  This transform is imperfect if there"]
#[doc = " are any partial MCU blocks on the right edge (see #TJXOPT_PERFECT.)"]
pub const TJXOP_TJXOP_HFLIP: TJXOP = 1;
#[doc = " Flip (mirror) image vertically.  This transform is imperfect if there are"]
#[doc = " any partial MCU blocks on the bottom edge (see #TJXOPT_PERFECT.)"]
pub const TJXOP_TJXOP_VFLIP: TJXOP = 2;
#[doc = " Transpose image (flip/mirror along upper left to lower right axis.)  This"]
#[doc = " transform is always perfect."]
pub const TJXOP_TJXOP_TRANSPOSE: TJXOP = 3;
#[doc = " Transverse transpose image (flip/mirror along upper right to lower left"]
#[doc = " axis.)  This transform is imperfect if there are any partial MCU blocks in"]
#[doc = " the image (see #TJXOPT_PERFECT.)"]
pub const TJXOP_TJXOP_TRANSVERSE: TJXOP = 4;
#[doc = " Rotate image clockwise by 90 degrees.  This transform is imperfect if"]
#[doc = " there are any partial MCU blocks on the bottom edge (see"]
#[doc = " #TJXOPT_PERFECT.)"]
pub const TJXOP_TJXOP_ROT90: TJXOP = 5;
#[doc = " Rotate image 180 degrees.  This transform is imperfect if there are any"]
#[doc = " partial MCU blocks in the image (see #TJXOPT_PERFECT.)"]
pub const TJXOP_TJXOP_ROT180: TJXOP = 6;
#[doc = " Rotate image counter-clockwise by 90 degrees.  This transform is imperfect"]
#[doc = " if there are any partial MCU blocks on the right edge (see"]
#[doc = " #TJXOPT_PERFECT.)"]
pub const TJXOP_TJXOP_ROT270: TJXOP = 7;
#[doc = " Transform operations for #tjTransform()"]
pub type TJXOP = u32;
#[doc = " Scaling factor"]
#[repr(C)]
pub struct tjscalingfactor {
	#[doc = " Numerator"]
	pub num: ::std::os::raw::c_int,
	#[doc = " Denominator"]
	pub denom: ::std::os::raw::c_int,
}
#[test]
fn bindgen_test_layout_tjscalingfactor() {
	assert_eq!(
		::core::mem::size_of::<tjscalingfactor>(),
		8usize,
		concat!("Size of: ", stringify!(tjscalingfactor))
	);
	assert_eq!(
		::core::mem::align_of::<tjscalingfactor>(),
		4usize,
		concat!("Alignment of ", stringify!(tjscalingfactor))
	);
	assert_eq!(
		unsafe { &(*(::core::ptr::null::<tjscalingfactor>())).num as *const _ as usize },
		0usize,
		concat!(
			"Offset of field: ",
			stringify!(tjscalingfactor),
			"::",
			stringify!(num)
		)
	);
	assert_eq!(
		unsafe { &(*(::core::ptr::null::<tjscalingfactor>())).denom as *const _ as usize },
		4usize,
		concat!(
			"Offset of field: ",
			stringify!(tjscalingfactor),
			"::",
			stringify!(denom)
		)
	);
}
#[doc = " Cropping region"]
#[repr(C)]
pub struct tjregion {
	#[doc = " The left boundary of the cropping region.  This must be evenly divisible"]
	#[doc = " by the MCU block width (see #tjMCUWidth.)"]
	pub x: ::std::os::raw::c_int,
	#[doc = " The upper boundary of the cropping region.  This must be evenly divisible"]
	#[doc = " by the MCU block height (see #tjMCUHeight.)"]
	pub y: ::std::os::raw::c_int,
	#[doc = " The width of the cropping region. Setting this to 0 is the equivalent of"]
	#[doc = " setting it to the width of the source JPEG image - x."]
	pub w: ::std::os::raw::c_int,
	#[doc = " The height of the cropping region. Setting this to 0 is the equivalent of"]
	#[doc = " setting it to the height of the source JPEG image - y."]
	pub h: ::std::os::raw::c_int,
}
#[test]
fn bindgen_test_layout_tjregion() {
	assert_eq!(
		::core::mem::size_of::<tjregion>(),
		16usize,
		concat!("Size of: ", stringify!(tjregion))
	);
	assert_eq!(
		::core::mem::align_of::<tjregion>(),
		4usize,
		concat!("Alignment of ", stringify!(tjregion))
	);
	assert_eq!(
		unsafe { &(*(::core::ptr::null::<tjregion>())).x as *const _ as usize },
		0usize,
		concat!(
			"Offset of field: ",
			stringify!(tjregion),
			"::",
			stringify!(x)
		)
	);
	assert_eq!(
		unsafe { &(*(::core::ptr::null::<tjregion>())).y as *const _ as usize },
		4usize,
		concat!(
			"Offset of field: ",
			stringify!(tjregion),
			"::",
			stringify!(y)
		)
	);
	assert_eq!(
		unsafe { &(*(::core::ptr::null::<tjregion>())).w as *const _ as usize },
		8usize,
		concat!(
			"Offset of field: ",
			stringify!(tjregion),
			"::",
			stringify!(w)
		)
	);
	assert_eq!(
		unsafe { &(*(::core::ptr::null::<tjregion>())).h as *const _ as usize },
		12usize,
		concat!(
			"Offset of field: ",
			stringify!(tjregion),
			"::",
			stringify!(h)
		)
	);
}
#[doc = " Lossless transform"]
#[repr(C)]
pub struct tjtransform {
	#[doc = " Cropping region"]
	pub r: tjregion,
	#[doc = " One of the @ref TJXOP \"transform operations\""]
	pub op: ::std::os::raw::c_int,
	#[doc = " The bitwise OR of one of more of the @ref TJXOPT_CROP \"transform options\""]
	pub options: ::std::os::raw::c_int,
	#[doc = " Arbitrary data that can be accessed within the body of the callback"]
	#[doc = " function"]
	pub data: *mut ::core::ffi::c_void,
	#[doc = " A callback function that can be used to modify the DCT coefficients"]
	#[doc = " after they are losslessly transformed but before they are transcoded to a"]
	#[doc = " new JPEG image.  This allows for custom filters or other transformations"]
	#[doc = " to be applied in the frequency domain."]
	#[doc = ""]
	#[doc = " @param coeffs pointer to an array of transformed DCT coefficients.  (NOTE:"]
	#[doc = " this pointer is not guaranteed to be valid once the callback returns, so"]
	#[doc = " applications wishing to hand off the DCT coefficients to another function"]
	#[doc = " or library should make a copy of them within the body of the callback.)"]
	#[doc = ""]
	#[doc = " @param arrayRegion #tjregion structure containing the width and height of"]
	#[doc = " the array pointed to by <tt>coeffs</tt> as well as its offset relative to"]
	#[doc = " the component plane.  TurboJPEG implementations may choose to split each"]
	#[doc = " component plane into multiple DCT coefficient arrays and call the callback"]
	#[doc = " function once for each array."]
	#[doc = ""]
	#[doc = " @param planeRegion #tjregion structure containing the width and height of"]
	#[doc = " the component plane to which <tt>coeffs</tt> belongs"]
	#[doc = ""]
	#[doc = " @param componentID ID number of the component plane to which"]
	#[doc = " <tt>coeffs</tt> belongs (Y, Cb, and Cr have, respectively, ID's of 0, 1,"]
	#[doc = " and 2 in typical JPEG images.)"]
	#[doc = ""]
	#[doc = " @param transformID ID number of the transformed image to which"]
	#[doc = " <tt>coeffs</tt> belongs.  This is the same as the index of the transform"]
	#[doc = " in the <tt>transforms</tt> array that was passed to #tjTransform()."]
	#[doc = ""]
	#[doc = " @param transform a pointer to a #tjtransform structure that specifies the"]
	#[doc = " parameters and/or cropping region for this transform"]
	#[doc = ""]
	#[doc = " @return 0 if the callback was successful, or -1 if an error occurred."]
	pub customFilter: ::core::option::Option<
		unsafe extern "C" fn(
			coeffs: *mut ::std::os::raw::c_short,
			arrayRegion: tjregion,
			planeRegion: tjregion,
			componentIndex: ::std::os::raw::c_int,
			transformIndex: ::std::os::raw::c_int,
			transform: *mut tjtransform,
		) -> ::std::os::raw::c_int,
	>,
}
#[test]
fn bindgen_test_layout_tjtransform() {
	assert_eq!(
		::core::mem::size_of::<tjtransform>(),
		40usize,
		concat!("Size of: ", stringify!(tjtransform))
	);
	assert_eq!(
		::core::mem::align_of::<tjtransform>(),
		8usize,
		concat!("Alignment of ", stringify!(tjtransform))
	);
	assert_eq!(
		unsafe { &(*(::core::ptr::null::<tjtransform>())).r as *const _ as usize },
		0usize,
		concat!(
			"Offset of field: ",
			stringify!(tjtransform),
			"::",
			stringify!(r)
		)
	);
	assert_eq!(
		unsafe { &(*(::core::ptr::null::<tjtransform>())).op as *const _ as usize },
		16usize,
		concat!(
			"Offset of field: ",
			stringify!(tjtransform),
			"::",
			stringify!(op)
		)
	);
	assert_eq!(
		unsafe { &(*(::core::ptr::null::<tjtransform>())).options as *const _ as usize },
		20usize,
		concat!(
			"Offset of field: ",
			stringify!(tjtransform),
			"::",
			stringify!(options)
		)
	);
	assert_eq!(
		unsafe { &(*(::core::ptr::null::<tjtransform>())).data as *const _ as usize },
		24usize,
		concat!(
			"Offset of field: ",
			stringify!(tjtransform),
			"::",
			stringify!(data)
		)
	);
	assert_eq!(
		unsafe { &(*(::core::ptr::null::<tjtransform>())).customFilter as *const _ as usize },
		32usize,
		concat!(
			"Offset of field: ",
			stringify!(tjtransform),
			"::",
			stringify!(customFilter)
		)
	);
}
#[doc = " TurboJPEG instance handle"]
pub type tjhandle = *mut ::core::ffi::c_void;
extern "C" {
	#[doc = " Create a TurboJPEG compressor instance."]
	#[doc = ""]
	#[doc = " @return a handle to the newly-created instance, or NULL if an error"]
	#[doc = " occurred (see #tjGetErrorStr2().)"]
	pub fn tjInitCompress() -> tjhandle;
}
extern "C" {
	#[doc = " Compress an RGB, grayscale, or CMYK image into a JPEG image."]
	#[doc = ""]
	#[doc = " @param handle a handle to a TurboJPEG compressor or transformer instance"]
	#[doc = ""]
	#[doc = " @param srcBuf pointer to an image buffer containing RGB, grayscale, or"]
	#[doc = " CMYK pixels to be compressed"]
	#[doc = ""]
	#[doc = " @param width width (in pixels) of the source image"]
	#[doc = ""]
	#[doc = " @param pitch bytes per line in the source image.  Normally, this should be"]
	#[doc = " <tt>width * #tjPixelSize[pixelFormat]</tt> if the image is unpadded, or"]
	#[doc = " <tt>#TJPAD(width * #tjPixelSize[pixelFormat])</tt> if each line of the image"]
	#[doc = " is padded to the nearest 32-bit boundary, as is the case for Windows"]
	#[doc = " bitmaps.  You can also be clever and use this parameter to skip lines, etc."]
	#[doc = " Setting this parameter to 0 is the equivalent of setting it to"]
	#[doc = " <tt>width * #tjPixelSize[pixelFormat]</tt>."]
	#[doc = ""]
	#[doc = " @param height height (in pixels) of the source image"]
	#[doc = ""]
	#[doc = " @param pixelFormat pixel format of the source image (see @ref TJPF"]
	#[doc = " \"Pixel formats\".)"]
	#[doc = ""]
	#[doc = " @param jpegBuf address of a pointer to an image buffer that will receive the"]
	#[doc = " JPEG image.  TurboJPEG has the ability to reallocate the JPEG buffer"]
	#[doc = " to accommodate the size of the JPEG image.  Thus, you can choose to:"]
	#[doc = " -# pre-allocate the JPEG buffer with an arbitrary size using #tjAlloc() and"]
	#[doc = " let TurboJPEG grow the buffer as needed,"]
	#[doc = " -# set <tt>*jpegBuf</tt> to NULL to tell TurboJPEG to allocate the buffer"]
	#[doc = " for you, or"]
	#[doc = " -# pre-allocate the buffer to a \"worst case\" size determined by calling"]
	#[doc = " #tjBufSize().  This should ensure that the buffer never has to be"]
	#[doc = " re-allocated (setting #TJFLAG_NOREALLOC guarantees that it won't be.)"]
	#[doc = " ."]
	#[doc = " If you choose option 1, <tt>*jpegSize</tt> should be set to the size of your"]
	#[doc = " pre-allocated buffer.  In any case, unless you have set #TJFLAG_NOREALLOC,"]
	#[doc = " you should always check <tt>*jpegBuf</tt> upon return from this function, as"]
	#[doc = " it may have changed."]
	#[doc = ""]
	#[doc = " @param jpegSize pointer to an unsigned long variable that holds the size of"]
	#[doc = " the JPEG image buffer.  If <tt>*jpegBuf</tt> points to a pre-allocated"]
	#[doc = " buffer, then <tt>*jpegSize</tt> should be set to the size of the buffer."]
	#[doc = " Upon return, <tt>*jpegSize</tt> will contain the size of the JPEG image (in"]
	#[doc = " bytes.)  If <tt>*jpegBuf</tt> points to a JPEG image buffer that is being"]
	#[doc = " reused from a previous call to one of the JPEG compression functions, then"]
	#[doc = " <tt>*jpegSize</tt> is ignored."]
	#[doc = ""]
	#[doc = " @param jpegSubsamp the level of chrominance subsampling to be used when"]
	#[doc = " generating the JPEG image (see @ref TJSAMP"]
	#[doc = " \"Chrominance subsampling options\".)"]
	#[doc = ""]
	#[doc = " @param jpegQual the image quality of the generated JPEG image (1 = worst,"]
	#[doc = " 100 = best)"]
	#[doc = ""]
	#[doc = " @param flags the bitwise OR of one or more of the @ref TJFLAG_ACCURATEDCT"]
	#[doc = " \"flags\""]
	#[doc = ""]
	#[doc = " @return 0 if successful, or -1 if an error occurred (see #tjGetErrorStr2()"]
	#[doc = " and #tjGetErrorCode().)"]
	pub fn tjCompress2(
		handle: tjhandle,
		srcBuf: *const ::std::os::raw::c_uchar,
		width: ::std::os::raw::c_int,
		pitch: ::std::os::raw::c_int,
		height: ::std::os::raw::c_int,
		pixelFormat: ::std::os::raw::c_int,
		jpegBuf: *mut *mut ::std::os::raw::c_uchar,
		jpegSize: *mut ::std::os::raw::c_ulong,
		jpegSubsamp: ::std::os::raw::c_int,
		jpegQual: ::std::os::raw::c_int,
		flags: ::std::os::raw::c_int,
	) -> ::std::os::raw::c_int;
}
extern "C" {
	#[doc = " Compress a YUV planar image into a JPEG image."]
	#[doc = ""]
	#[doc = " @param handle a handle to a TurboJPEG compressor or transformer instance"]
	#[doc = ""]
	#[doc = " @param srcBuf pointer to an image buffer containing a YUV planar image to be"]
	#[doc = " compressed.  The size of this buffer should match the value returned by"]
	#[doc = " #tjBufSizeYUV2() for the given image width, height, padding, and level of"]
	#[doc = " chrominance subsampling.  The Y, U (Cb), and V (Cr) image planes should be"]
	#[doc = " stored sequentially in the source buffer (refer to @ref YUVnotes"]
	#[doc = " \"YUV Image Format Notes\".)"]
	#[doc = ""]
	#[doc = " @param width width (in pixels) of the source image.  If the width is not an"]
	#[doc = " even multiple of the MCU block width (see #tjMCUWidth), then an intermediate"]
	#[doc = " buffer copy will be performed within TurboJPEG."]
	#[doc = ""]
	#[doc = " @param pad the line padding used in the source image.  For instance, if each"]
	#[doc = " line in each plane of the YUV image is padded to the nearest multiple of 4"]
	#[doc = " bytes, then <tt>pad</tt> should be set to 4."]
	#[doc = ""]
	#[doc = " @param height height (in pixels) of the source image.  If the height is not"]
	#[doc = " an even multiple of the MCU block height (see #tjMCUHeight), then an"]
	#[doc = " intermediate buffer copy will be performed within TurboJPEG."]
	#[doc = ""]
	#[doc = " @param subsamp the level of chrominance subsampling used in the source"]
	#[doc = " image (see @ref TJSAMP \"Chrominance subsampling options\".)"]
	#[doc = ""]
	#[doc = " @param jpegBuf address of a pointer to an image buffer that will receive the"]
	#[doc = " JPEG image.  TurboJPEG has the ability to reallocate the JPEG buffer to"]
	#[doc = " accommodate the size of the JPEG image.  Thus, you can choose to:"]
	#[doc = " -# pre-allocate the JPEG buffer with an arbitrary size using #tjAlloc() and"]
	#[doc = " let TurboJPEG grow the buffer as needed,"]
	#[doc = " -# set <tt>*jpegBuf</tt> to NULL to tell TurboJPEG to allocate the buffer"]
	#[doc = " for you, or"]
	#[doc = " -# pre-allocate the buffer to a \"worst case\" size determined by calling"]
	#[doc = " #tjBufSize().  This should ensure that the buffer never has to be"]
	#[doc = " re-allocated (setting #TJFLAG_NOREALLOC guarantees that it won't be.)"]
	#[doc = " ."]
	#[doc = " If you choose option 1, <tt>*jpegSize</tt> should be set to the size of your"]
	#[doc = " pre-allocated buffer.  In any case, unless you have set #TJFLAG_NOREALLOC,"]
	#[doc = " you should always check <tt>*jpegBuf</tt> upon return from this function, as"]
	#[doc = " it may have changed."]
	#[doc = ""]
	#[doc = " @param jpegSize pointer to an unsigned long variable that holds the size of"]
	#[doc = " the JPEG image buffer.  If <tt>*jpegBuf</tt> points to a pre-allocated"]
	#[doc = " buffer, then <tt>*jpegSize</tt> should be set to the size of the buffer."]
	#[doc = " Upon return, <tt>*jpegSize</tt> will contain the size of the JPEG image (in"]
	#[doc = " bytes.)  If <tt>*jpegBuf</tt> points to a JPEG image buffer that is being"]
	#[doc = " reused from a previous call to one of the JPEG compression functions, then"]
	#[doc = " <tt>*jpegSize</tt> is ignored."]
	#[doc = ""]
	#[doc = " @param jpegQual the image quality of the generated JPEG image (1 = worst,"]
	#[doc = " 100 = best)"]
	#[doc = ""]
	#[doc = " @param flags the bitwise OR of one or more of the @ref TJFLAG_ACCURATEDCT"]
	#[doc = " \"flags\""]
	#[doc = ""]
	#[doc = " @return 0 if successful, or -1 if an error occurred (see #tjGetErrorStr2()"]
	#[doc = " and #tjGetErrorCode().)"]
	pub fn tjCompressFromYUV(
		handle: tjhandle,
		srcBuf: *const ::std::os::raw::c_uchar,
		width: ::std::os::raw::c_int,
		pad: ::std::os::raw::c_int,
		height: ::std::os::raw::c_int,
		subsamp: ::std::os::raw::c_int,
		jpegBuf: *mut *mut ::std::os::raw::c_uchar,
		jpegSize: *mut ::std::os::raw::c_ulong,
		jpegQual: ::std::os::raw::c_int,
		flags: ::std::os::raw::c_int,
	) -> ::std::os::raw::c_int;
}
extern "C" {
	#[doc = " Compress a set of Y, U (Cb), and V (Cr) image planes into a JPEG image."]
	#[doc = ""]
	#[doc = " @param handle a handle to a TurboJPEG compressor or transformer instance"]
	#[doc = ""]
	#[doc = " @param srcPlanes an array of pointers to Y, U (Cb), and V (Cr) image planes"]
	#[doc = " (or just a Y plane, if compressing a grayscale image) that contain a YUV"]
	#[doc = " image to be compressed.  These planes can be contiguous or non-contiguous in"]
	#[doc = " memory.  The size of each plane should match the value returned by"]
	#[doc = " #tjPlaneSizeYUV() for the given image width, height, strides, and level of"]
	#[doc = " chrominance subsampling.  Refer to @ref YUVnotes \"YUV Image Format Notes\""]
	#[doc = " for more details."]
	#[doc = ""]
	#[doc = " @param width width (in pixels) of the source image.  If the width is not an"]
	#[doc = " even multiple of the MCU block width (see #tjMCUWidth), then an intermediate"]
	#[doc = " buffer copy will be performed within TurboJPEG."]
	#[doc = ""]
	#[doc = " @param strides an array of integers, each specifying the number of bytes per"]
	#[doc = " line in the corresponding plane of the YUV source image.  Setting the stride"]
	#[doc = " for any plane to 0 is the same as setting it to the plane width (see"]
	#[doc = " @ref YUVnotes \"YUV Image Format Notes\".)  If <tt>strides</tt> is NULL, then"]
	#[doc = " the strides for all planes will be set to their respective plane widths."]
	#[doc = " You can adjust the strides in order to specify an arbitrary amount of line"]
	#[doc = " padding in each plane or to create a JPEG image from a subregion of a larger"]
	#[doc = " YUV planar image."]
	#[doc = ""]
	#[doc = " @param height height (in pixels) of the source image.  If the height is not"]
	#[doc = " an even multiple of the MCU block height (see #tjMCUHeight), then an"]
	#[doc = " intermediate buffer copy will be performed within TurboJPEG."]
	#[doc = ""]
	#[doc = " @param subsamp the level of chrominance subsampling used in the source"]
	#[doc = " image (see @ref TJSAMP \"Chrominance subsampling options\".)"]
	#[doc = ""]
	#[doc = " @param jpegBuf address of a pointer to an image buffer that will receive the"]
	#[doc = " JPEG image.  TurboJPEG has the ability to reallocate the JPEG buffer to"]
	#[doc = " accommodate the size of the JPEG image.  Thus, you can choose to:"]
	#[doc = " -# pre-allocate the JPEG buffer with an arbitrary size using #tjAlloc() and"]
	#[doc = " let TurboJPEG grow the buffer as needed,"]
	#[doc = " -# set <tt>*jpegBuf</tt> to NULL to tell TurboJPEG to allocate the buffer"]
	#[doc = " for you, or"]
	#[doc = " -# pre-allocate the buffer to a \"worst case\" size determined by calling"]
	#[doc = " #tjBufSize().  This should ensure that the buffer never has to be"]
	#[doc = " re-allocated (setting #TJFLAG_NOREALLOC guarantees that it won't be.)"]
	#[doc = " ."]
	#[doc = " If you choose option 1, <tt>*jpegSize</tt> should be set to the size of your"]
	#[doc = " pre-allocated buffer.  In any case, unless you have set #TJFLAG_NOREALLOC,"]
	#[doc = " you should always check <tt>*jpegBuf</tt> upon return from this function, as"]
	#[doc = " it may have changed."]
	#[doc = ""]
	#[doc = " @param jpegSize pointer to an unsigned long variable that holds the size of"]
	#[doc = " the JPEG image buffer.  If <tt>*jpegBuf</tt> points to a pre-allocated"]
	#[doc = " buffer, then <tt>*jpegSize</tt> should be set to the size of the buffer."]
	#[doc = " Upon return, <tt>*jpegSize</tt> will contain the size of the JPEG image (in"]
	#[doc = " bytes.)  If <tt>*jpegBuf</tt> points to a JPEG image buffer that is being"]
	#[doc = " reused from a previous call to one of the JPEG compression functions, then"]
	#[doc = " <tt>*jpegSize</tt> is ignored."]
	#[doc = ""]
	#[doc = " @param jpegQual the image quality of the generated JPEG image (1 = worst,"]
	#[doc = " 100 = best)"]
	#[doc = ""]
	#[doc = " @param flags the bitwise OR of one or more of the @ref TJFLAG_ACCURATEDCT"]
	#[doc = " \"flags\""]
	#[doc = ""]
	#[doc = " @return 0 if successful, or -1 if an error occurred (see #tjGetErrorStr2()"]
	#[doc = " and #tjGetErrorCode().)"]
	pub fn tjCompressFromYUVPlanes(
		handle: tjhandle,
		srcPlanes: *mut *const ::std::os::raw::c_uchar,
		width: ::std::os::raw::c_int,
		strides: *const ::std::os::raw::c_int,
		height: ::std::os::raw::c_int,
		subsamp: ::std::os::raw::c_int,
		jpegBuf: *mut *mut ::std::os::raw::c_uchar,
		jpegSize: *mut ::std::os::raw::c_ulong,
		jpegQual: ::std::os::raw::c_int,
		flags: ::std::os::raw::c_int,
	) -> ::std::os::raw::c_int;
}
extern "C" {
	#[doc = " The maximum size of the buffer (in bytes) required to hold a JPEG image with"]
	#[doc = " the given parameters.  The number of bytes returned by this function is"]
	#[doc = " larger than the size of the uncompressed source image.  The reason for this"]
	#[doc = " is that the JPEG format uses 16-bit coefficients, and it is thus possible"]
	#[doc = " for a very high-quality JPEG image with very high-frequency content to"]
	#[doc = " expand rather than compress when converted to the JPEG format.  Such images"]
	#[doc = " represent a very rare corner case, but since there is no way to predict the"]
	#[doc = " size of a JPEG image prior to compression, the corner case has to be"]
	#[doc = " handled."]
	#[doc = ""]
	#[doc = " @param width width (in pixels) of the image"]
	#[doc = ""]
	#[doc = " @param height height (in pixels) of the image"]
	#[doc = ""]
	#[doc = " @param jpegSubsamp the level of chrominance subsampling to be used when"]
	#[doc = " generating the JPEG image (see @ref TJSAMP"]
	#[doc = " \"Chrominance subsampling options\".)"]
	#[doc = ""]
	#[doc = " @return the maximum size of the buffer (in bytes) required to hold the"]
	#[doc = " image, or -1 if the arguments are out of bounds."]
	pub fn tjBufSize(
		width: ::std::os::raw::c_int,
		height: ::std::os::raw::c_int,
		jpegSubsamp: ::std::os::raw::c_int,
	) -> ::std::os::raw::c_ulong;
}
extern "C" {
	#[doc = " The size of the buffer (in bytes) required to hold a YUV planar image with"]
	#[doc = " the given parameters."]
	#[doc = ""]
	#[doc = " @param width width (in pixels) of the image"]
	#[doc = ""]
	#[doc = " @param pad the width of each line in each plane of the image is padded to"]
	#[doc = " the nearest multiple of this number of bytes (must be a power of 2.)"]
	#[doc = ""]
	#[doc = " @param height height (in pixels) of the image"]
	#[doc = ""]
	#[doc = " @param subsamp level of chrominance subsampling in the image (see"]
	#[doc = " @ref TJSAMP \"Chrominance subsampling options\".)"]
	#[doc = ""]
	#[doc = " @return the size of the buffer (in bytes) required to hold the image, or"]
	#[doc = " -1 if the arguments are out of bounds."]
	pub fn tjBufSizeYUV2(
		width: ::std::os::raw::c_int,
		pad: ::std::os::raw::c_int,
		height: ::std::os::raw::c_int,
		subsamp: ::std::os::raw::c_int,
	) -> ::std::os::raw::c_ulong;
}
extern "C" {
	#[doc = " The size of the buffer (in bytes) required to hold a YUV image plane with"]
	#[doc = " the given parameters."]
	#[doc = ""]
	#[doc = " @param componentID ID number of the image plane (0 = Y, 1 = U/Cb, 2 = V/Cr)"]
	#[doc = ""]
	#[doc = " @param width width (in pixels) of the YUV image.  NOTE: this is the width of"]
	#[doc = " the whole image, not the plane width."]
	#[doc = ""]
	#[doc = " @param stride bytes per line in the image plane.  Setting this to 0 is the"]
	#[doc = " equivalent of setting it to the plane width."]
	#[doc = ""]
	#[doc = " @param height height (in pixels) of the YUV image.  NOTE: this is the height"]
	#[doc = " of the whole image, not the plane height."]
	#[doc = ""]
	#[doc = " @param subsamp level of chrominance subsampling in the image (see"]
	#[doc = " @ref TJSAMP \"Chrominance subsampling options\".)"]
	#[doc = ""]
	#[doc = " @return the size of the buffer (in bytes) required to hold the YUV image"]
	#[doc = " plane, or -1 if the arguments are out of bounds."]
	pub fn tjPlaneSizeYUV(
		componentID: ::std::os::raw::c_int,
		width: ::std::os::raw::c_int,
		stride: ::std::os::raw::c_int,
		height: ::std::os::raw::c_int,
		subsamp: ::std::os::raw::c_int,
	) -> ::std::os::raw::c_ulong;
}
extern "C" {
	#[doc = " The plane width of a YUV image plane with the given parameters.  Refer to"]
	#[doc = " @ref YUVnotes \"YUV Image Format Notes\" for a description of plane width."]
	#[doc = ""]
	#[doc = " @param componentID ID number of the image plane (0 = Y, 1 = U/Cb, 2 = V/Cr)"]
	#[doc = ""]
	#[doc = " @param width width (in pixels) of the YUV image"]
	#[doc = ""]
	#[doc = " @param subsamp level of chrominance subsampling in the image (see"]
	#[doc = " @ref TJSAMP \"Chrominance subsampling options\".)"]
	#[doc = ""]
	#[doc = " @return the plane width of a YUV image plane with the given parameters, or"]
	#[doc = " -1 if the arguments are out of bounds."]
	pub fn tjPlaneWidth(
		componentID: ::std::os::raw::c_int,
		width: ::std::os::raw::c_int,
		subsamp: ::std::os::raw::c_int,
	) -> ::std::os::raw::c_int;
}
extern "C" {
	#[doc = " The plane height of a YUV image plane with the given parameters.  Refer to"]
	#[doc = " @ref YUVnotes \"YUV Image Format Notes\" for a description of plane height."]
	#[doc = ""]
	#[doc = " @param componentID ID number of the image plane (0 = Y, 1 = U/Cb, 2 = V/Cr)"]
	#[doc = ""]
	#[doc = " @param height height (in pixels) of the YUV image"]
	#[doc = ""]
	#[doc = " @param subsamp level of chrominance subsampling in the image (see"]
	#[doc = " @ref TJSAMP \"Chrominance subsampling options\".)"]
	#[doc = ""]
	#[doc = " @return the plane height of a YUV image plane with the given parameters, or"]
	#[doc = " -1 if the arguments are out of bounds."]
	pub fn tjPlaneHeight(
		componentID: ::std::os::raw::c_int,
		height: ::std::os::raw::c_int,
		subsamp: ::std::os::raw::c_int,
	) -> ::std::os::raw::c_int;
}
extern "C" {
	#[doc = " Encode an RGB or grayscale image into a YUV planar image.  This function"]
	#[doc = " uses the accelerated color conversion routines in the underlying"]
	#[doc = " codec but does not execute any of the other steps in the JPEG compression"]
	#[doc = " process."]
	#[doc = ""]
	#[doc = " @param handle a handle to a TurboJPEG compressor or transformer instance"]
	#[doc = ""]
	#[doc = " @param srcBuf pointer to an image buffer containing RGB or grayscale pixels"]
	#[doc = " to be encoded"]
	#[doc = ""]
	#[doc = " @param width width (in pixels) of the source image"]
	#[doc = ""]
	#[doc = " @param pitch bytes per line in the source image.  Normally, this should be"]
	#[doc = " <tt>width * #tjPixelSize[pixelFormat]</tt> if the image is unpadded, or"]
	#[doc = " <tt>#TJPAD(width * #tjPixelSize[pixelFormat])</tt> if each line of the image"]
	#[doc = " is padded to the nearest 32-bit boundary, as is the case for Windows"]
	#[doc = " bitmaps.  You can also be clever and use this parameter to skip lines, etc."]
	#[doc = " Setting this parameter to 0 is the equivalent of setting it to"]
	#[doc = " <tt>width * #tjPixelSize[pixelFormat]</tt>."]
	#[doc = ""]
	#[doc = " @param height height (in pixels) of the source image"]
	#[doc = ""]
	#[doc = " @param pixelFormat pixel format of the source image (see @ref TJPF"]
	#[doc = " \"Pixel formats\".)"]
	#[doc = ""]
	#[doc = " @param dstBuf pointer to an image buffer that will receive the YUV image."]
	#[doc = " Use #tjBufSizeYUV2() to determine the appropriate size for this buffer based"]
	#[doc = " on the image width, height, padding, and level of chrominance subsampling."]
	#[doc = " The Y, U (Cb), and V (Cr) image planes will be stored sequentially in the"]
	#[doc = " buffer (refer to @ref YUVnotes \"YUV Image Format Notes\".)"]
	#[doc = ""]
	#[doc = " @param pad the width of each line in each plane of the YUV image will be"]
	#[doc = " padded to the nearest multiple of this number of bytes (must be a power of"]
	#[doc = " 2.)  To generate images suitable for X Video, <tt>pad</tt> should be set to"]
	#[doc = " 4."]
	#[doc = ""]
	#[doc = " @param subsamp the level of chrominance subsampling to be used when"]
	#[doc = " generating the YUV image (see @ref TJSAMP"]
	#[doc = " \"Chrominance subsampling options\".)  To generate images suitable for X"]
	#[doc = " Video, <tt>subsamp</tt> should be set to @ref TJSAMP_420.  This produces an"]
	#[doc = " image compatible with the I420 (AKA \"YUV420P\") format."]
	#[doc = ""]
	#[doc = " @param flags the bitwise OR of one or more of the @ref TJFLAG_ACCURATEDCT"]
	#[doc = " \"flags\""]
	#[doc = ""]
	#[doc = " @return 0 if successful, or -1 if an error occurred (see #tjGetErrorStr2()"]
	#[doc = " and #tjGetErrorCode().)"]
	pub fn tjEncodeYUV3(
		handle: tjhandle,
		srcBuf: *const ::std::os::raw::c_uchar,
		width: ::std::os::raw::c_int,
		pitch: ::std::os::raw::c_int,
		height: ::std::os::raw::c_int,
		pixelFormat: ::std::os::raw::c_int,
		dstBuf: *mut ::std::os::raw::c_uchar,
		pad: ::std::os::raw::c_int,
		subsamp: ::std::os::raw::c_int,
		flags: ::std::os::raw::c_int,
	) -> ::std::os::raw::c_int;
}
extern "C" {
	#[doc = " Encode an RGB or grayscale image into separate Y, U (Cb), and V (Cr) image"]
	#[doc = " planes.  This function uses the accelerated color conversion routines in the"]
	#[doc = " underlying codec but does not execute any of the other steps in the JPEG"]
	#[doc = " compression process."]
	#[doc = ""]
	#[doc = " @param handle a handle to a TurboJPEG compressor or transformer instance"]
	#[doc = ""]
	#[doc = " @param srcBuf pointer to an image buffer containing RGB or grayscale pixels"]
	#[doc = " to be encoded"]
	#[doc = ""]
	#[doc = " @param width width (in pixels) of the source image"]
	#[doc = ""]
	#[doc = " @param pitch bytes per line in the source image.  Normally, this should be"]
	#[doc = " <tt>width * #tjPixelSize[pixelFormat]</tt> if the image is unpadded, or"]
	#[doc = " <tt>#TJPAD(width * #tjPixelSize[pixelFormat])</tt> if each line of the image"]
	#[doc = " is padded to the nearest 32-bit boundary, as is the case for Windows"]
	#[doc = " bitmaps.  You can also be clever and use this parameter to skip lines, etc."]
	#[doc = " Setting this parameter to 0 is the equivalent of setting it to"]
	#[doc = " <tt>width * #tjPixelSize[pixelFormat]</tt>."]
	#[doc = ""]
	#[doc = " @param height height (in pixels) of the source image"]
	#[doc = ""]
	#[doc = " @param pixelFormat pixel format of the source image (see @ref TJPF"]
	#[doc = " \"Pixel formats\".)"]
	#[doc = ""]
	#[doc = " @param dstPlanes an array of pointers to Y, U (Cb), and V (Cr) image planes"]
	#[doc = " (or just a Y plane, if generating a grayscale image) that will receive the"]
	#[doc = " encoded image.  These planes can be contiguous or non-contiguous in memory."]
	#[doc = " Use #tjPlaneSizeYUV() to determine the appropriate size for each plane based"]
	#[doc = " on the image width, height, strides, and level of chrominance subsampling."]
	#[doc = " Refer to @ref YUVnotes \"YUV Image Format Notes\" for more details."]
	#[doc = ""]
	#[doc = " @param strides an array of integers, each specifying the number of bytes per"]
	#[doc = " line in the corresponding plane of the output image.  Setting the stride for"]
	#[doc = " any plane to 0 is the same as setting it to the plane width (see"]
	#[doc = " @ref YUVnotes \"YUV Image Format Notes\".)  If <tt>strides</tt> is NULL, then"]
	#[doc = " the strides for all planes will be set to their respective plane widths."]
	#[doc = " You can adjust the strides in order to add an arbitrary amount of line"]
	#[doc = " padding to each plane or to encode an RGB or grayscale image into a"]
	#[doc = " subregion of a larger YUV planar image."]
	#[doc = ""]
	#[doc = " @param subsamp the level of chrominance subsampling to be used when"]
	#[doc = " generating the YUV image (see @ref TJSAMP"]
	#[doc = " \"Chrominance subsampling options\".)  To generate images suitable for X"]
	#[doc = " Video, <tt>subsamp</tt> should be set to @ref TJSAMP_420.  This produces an"]
	#[doc = " image compatible with the I420 (AKA \"YUV420P\") format."]
	#[doc = ""]
	#[doc = " @param flags the bitwise OR of one or more of the @ref TJFLAG_ACCURATEDCT"]
	#[doc = " \"flags\""]
	#[doc = ""]
	#[doc = " @return 0 if successful, or -1 if an error occurred (see #tjGetErrorStr2()"]
	#[doc = " and #tjGetErrorCode().)"]
	pub fn tjEncodeYUVPlanes(
		handle: tjhandle,
		srcBuf: *const ::std::os::raw::c_uchar,
		width: ::std::os::raw::c_int,
		pitch: ::std::os::raw::c_int,
		height: ::std::os::raw::c_int,
		pixelFormat: ::std::os::raw::c_int,
		dstPlanes: *mut *mut ::std::os::raw::c_uchar,
		strides: *mut ::std::os::raw::c_int,
		subsamp: ::std::os::raw::c_int,
		flags: ::std::os::raw::c_int,
	) -> ::std::os::raw::c_int;
}
extern "C" {
	#[doc = " Create a TurboJPEG decompressor instance."]
	#[doc = ""]
	#[doc = " @return a handle to the newly-created instance, or NULL if an error"]
	#[doc = " occurred (see #tjGetErrorStr2().)"]
	pub fn tjInitDecompress() -> tjhandle;
}
extern "C" {
	#[doc = " Retrieve information about a JPEG image without decompressing it."]
	#[doc = ""]
	#[doc = " @param handle a handle to a TurboJPEG decompressor or transformer instance"]
	#[doc = ""]
	#[doc = " @param jpegBuf pointer to a buffer containing a JPEG image"]
	#[doc = ""]
	#[doc = " @param jpegSize size of the JPEG image (in bytes)"]
	#[doc = ""]
	#[doc = " @param width pointer to an integer variable that will receive the width (in"]
	#[doc = " pixels) of the JPEG image"]
	#[doc = ""]
	#[doc = " @param height pointer to an integer variable that will receive the height"]
	#[doc = " (in pixels) of the JPEG image"]
	#[doc = ""]
	#[doc = " @param jpegSubsamp pointer to an integer variable that will receive the"]
	#[doc = " level of chrominance subsampling used when the JPEG image was compressed"]
	#[doc = " (see @ref TJSAMP \"Chrominance subsampling options\".)"]
	#[doc = ""]
	#[doc = " @param jpegColorspace pointer to an integer variable that will receive one"]
	#[doc = " of the JPEG colorspace constants, indicating the colorspace of the JPEG"]
	#[doc = " image (see @ref TJCS \"JPEG colorspaces\".)"]
	#[doc = ""]
	#[doc = " @return 0 if successful, or -1 if an error occurred (see #tjGetErrorStr2()"]
	#[doc = " and #tjGetErrorCode().)"]
	pub fn tjDecompressHeader3(
		handle: tjhandle,
		jpegBuf: *const ::std::os::raw::c_uchar,
		jpegSize: ::std::os::raw::c_ulong,
		width: *mut ::std::os::raw::c_int,
		height: *mut ::std::os::raw::c_int,
		jpegSubsamp: *mut ::std::os::raw::c_int,
		jpegColorspace: *mut ::std::os::raw::c_int,
	) -> ::std::os::raw::c_int;
}
extern "C" {
	#[doc = " Returns a list of fractional scaling factors that the JPEG decompressor in"]
	#[doc = " this implementation of TurboJPEG supports."]
	#[doc = ""]
	#[doc = " @param numscalingfactors pointer to an integer variable that will receive"]
	#[doc = " the number of elements in the list"]
	#[doc = ""]
	#[doc = " @return a pointer to a list of fractional scaling factors, or NULL if an"]
	#[doc = " error is encountered (see #tjGetErrorStr2().)"]
	pub fn tjGetScalingFactors(
		numscalingfactors: *mut ::std::os::raw::c_int,
	) -> *mut tjscalingfactor;
}
extern "C" {
	#[doc = " Decompress a JPEG image to an RGB, grayscale, or CMYK image."]
	#[doc = ""]
	#[doc = " @param handle a handle to a TurboJPEG decompressor or transformer instance"]
	#[doc = ""]
	#[doc = " @param jpegBuf pointer to a buffer containing the JPEG image to decompress"]
	#[doc = ""]
	#[doc = " @param jpegSize size of the JPEG image (in bytes)"]
	#[doc = ""]
	#[doc = " @param dstBuf pointer to an image buffer that will receive the decompressed"]
	#[doc = " image.  This buffer should normally be <tt>pitch * scaledHeight</tt> bytes"]
	#[doc = " in size, where <tt>scaledHeight</tt> can be determined by calling"]
	#[doc = " #TJSCALED() with the JPEG image height and one of the scaling factors"]
	#[doc = " returned by #tjGetScalingFactors().  The <tt>dstBuf</tt> pointer may also be"]
	#[doc = " used to decompress into a specific region of a larger buffer."]
	#[doc = ""]
	#[doc = " @param width desired width (in pixels) of the destination image.  If this is"]
	#[doc = " different than the width of the JPEG image being decompressed, then"]
	#[doc = " TurboJPEG will use scaling in the JPEG decompressor to generate the largest"]
	#[doc = " possible image that will fit within the desired width.  If <tt>width</tt> is"]
	#[doc = " set to 0, then only the height will be considered when determining the"]
	#[doc = " scaled image size."]
	#[doc = ""]
	#[doc = " @param pitch bytes per line in the destination image.  Normally, this is"]
	#[doc = " <tt>scaledWidth * #tjPixelSize[pixelFormat]</tt> if the decompressed image"]
	#[doc = " is unpadded, else <tt>#TJPAD(scaledWidth * #tjPixelSize[pixelFormat])</tt>"]
	#[doc = " if each line of the decompressed image is padded to the nearest 32-bit"]
	#[doc = " boundary, as is the case for Windows bitmaps.  (NOTE: <tt>scaledWidth</tt>"]
	#[doc = " can be determined by calling #TJSCALED() with the JPEG image width and one"]
	#[doc = " of the scaling factors returned by #tjGetScalingFactors().)  You can also be"]
	#[doc = " clever and use the pitch parameter to skip lines, etc.  Setting this"]
	#[doc = " parameter to 0 is the equivalent of setting it to"]
	#[doc = " <tt>scaledWidth * #tjPixelSize[pixelFormat]</tt>."]
	#[doc = ""]
	#[doc = " @param height desired height (in pixels) of the destination image.  If this"]
	#[doc = " is different than the height of the JPEG image being decompressed, then"]
	#[doc = " TurboJPEG will use scaling in the JPEG decompressor to generate the largest"]
	#[doc = " possible image that will fit within the desired height.  If <tt>height</tt>"]
	#[doc = " is set to 0, then only the width will be considered when determining the"]
	#[doc = " scaled image size."]
	#[doc = ""]
	#[doc = " @param pixelFormat pixel format of the destination image (see @ref"]
	#[doc = " TJPF \"Pixel formats\".)"]
	#[doc = ""]
	#[doc = " @param flags the bitwise OR of one or more of the @ref TJFLAG_ACCURATEDCT"]
	#[doc = " \"flags\""]
	#[doc = ""]
	#[doc = " @return 0 if successful, or -1 if an error occurred (see #tjGetErrorStr2()"]
	#[doc = " and #tjGetErrorCode().)"]
	pub fn tjDecompress2(
		handle: tjhandle,
		jpegBuf: *const ::std::os::raw::c_uchar,
		jpegSize: ::std::os::raw::c_ulong,
		dstBuf: *mut ::std::os::raw::c_uchar,
		width: ::std::os::raw::c_int,
		pitch: ::std::os::raw::c_int,
		height: ::std::os::raw::c_int,
		pixelFormat: ::std::os::raw::c_int,
		flags: ::std::os::raw::c_int,
	) -> ::std::os::raw::c_int;
}
extern "C" {
	#[doc = " Decompress a JPEG image to a YUV planar image.  This function performs JPEG"]
	#[doc = " decompression but leaves out the color conversion step, so a planar YUV"]
	#[doc = " image is generated instead of an RGB image."]
	#[doc = ""]
	#[doc = " @param handle a handle to a TurboJPEG decompressor or transformer instance"]
	#[doc = ""]
	#[doc = " @param jpegBuf pointer to a buffer containing the JPEG image to decompress"]
	#[doc = ""]
	#[doc = " @param jpegSize size of the JPEG image (in bytes)"]
	#[doc = ""]
	#[doc = " @param dstBuf pointer to an image buffer that will receive the YUV image."]
	#[doc = " Use #tjBufSizeYUV2() to determine the appropriate size for this buffer based"]
	#[doc = " on the image width, height, padding, and level of subsampling.  The Y,"]
	#[doc = " U (Cb), and V (Cr) image planes will be stored sequentially in the buffer"]
	#[doc = " (refer to @ref YUVnotes \"YUV Image Format Notes\".)"]
	#[doc = ""]
	#[doc = " @param width desired width (in pixels) of the YUV image.  If this is"]
	#[doc = " different than the width of the JPEG image being decompressed, then"]
	#[doc = " TurboJPEG will use scaling in the JPEG decompressor to generate the largest"]
	#[doc = " possible image that will fit within the desired width.  If <tt>width</tt> is"]
	#[doc = " set to 0, then only the height will be considered when determining the"]
	#[doc = " scaled image size.  If the scaled width is not an even multiple of the MCU"]
	#[doc = " block width (see #tjMCUWidth), then an intermediate buffer copy will be"]
	#[doc = " performed within TurboJPEG."]
	#[doc = ""]
	#[doc = " @param pad the width of each line in each plane of the YUV image will be"]
	#[doc = " padded to the nearest multiple of this number of bytes (must be a power of"]
	#[doc = " 2.)  To generate images suitable for X Video, <tt>pad</tt> should be set to"]
	#[doc = " 4."]
	#[doc = ""]
	#[doc = " @param height desired height (in pixels) of the YUV image.  If this is"]
	#[doc = " different than the height of the JPEG image being decompressed, then"]
	#[doc = " TurboJPEG will use scaling in the JPEG decompressor to generate the largest"]
	#[doc = " possible image that will fit within the desired height.  If <tt>height</tt>"]
	#[doc = " is set to 0, then only the width will be considered when determining the"]
	#[doc = " scaled image size.  If the scaled height is not an even multiple of the MCU"]
	#[doc = " block height (see #tjMCUHeight), then an intermediate buffer copy will be"]
	#[doc = " performed within TurboJPEG."]
	#[doc = ""]
	#[doc = " @param flags the bitwise OR of one or more of the @ref TJFLAG_ACCURATEDCT"]
	#[doc = " \"flags\""]
	#[doc = ""]
	#[doc = " @return 0 if successful, or -1 if an error occurred (see #tjGetErrorStr2()"]
	#[doc = " and #tjGetErrorCode().)"]
	pub fn tjDecompressToYUV2(
		handle: tjhandle,
		jpegBuf: *const ::std::os::raw::c_uchar,
		jpegSize: ::std::os::raw::c_ulong,
		dstBuf: *mut ::std::os::raw::c_uchar,
		width: ::std::os::raw::c_int,
		pad: ::std::os::raw::c_int,
		height: ::std::os::raw::c_int,
		flags: ::std::os::raw::c_int,
	) -> ::std::os::raw::c_int;
}
extern "C" {
	#[doc = " Decompress a JPEG image into separate Y, U (Cb), and V (Cr) image"]
	#[doc = " planes.  This function performs JPEG decompression but leaves out the color"]
	#[doc = " conversion step, so a planar YUV image is generated instead of an RGB image."]
	#[doc = ""]
	#[doc = " @param handle a handle to a TurboJPEG decompressor or transformer instance"]
	#[doc = ""]
	#[doc = " @param jpegBuf pointer to a buffer containing the JPEG image to decompress"]
	#[doc = ""]
	#[doc = " @param jpegSize size of the JPEG image (in bytes)"]
	#[doc = ""]
	#[doc = " @param dstPlanes an array of pointers to Y, U (Cb), and V (Cr) image planes"]
	#[doc = " (or just a Y plane, if decompressing a grayscale image) that will receive"]
	#[doc = " the YUV image.  These planes can be contiguous or non-contiguous in memory."]
	#[doc = " Use #tjPlaneSizeYUV() to determine the appropriate size for each plane based"]
	#[doc = " on the scaled image width, scaled image height, strides, and level of"]
	#[doc = " chrominance subsampling.  Refer to @ref YUVnotes \"YUV Image Format Notes\""]
	#[doc = " for more details."]
	#[doc = ""]
	#[doc = " @param width desired width (in pixels) of the YUV image.  If this is"]
	#[doc = " different than the width of the JPEG image being decompressed, then"]
	#[doc = " TurboJPEG will use scaling in the JPEG decompressor to generate the largest"]
	#[doc = " possible image that will fit within the desired width.  If <tt>width</tt> is"]
	#[doc = " set to 0, then only the height will be considered when determining the"]
	#[doc = " scaled image size.  If the scaled width is not an even multiple of the MCU"]
	#[doc = " block width (see #tjMCUWidth), then an intermediate buffer copy will be"]
	#[doc = " performed within TurboJPEG."]
	#[doc = ""]
	#[doc = " @param strides an array of integers, each specifying the number of bytes per"]
	#[doc = " line in the corresponding plane of the output image.  Setting the stride for"]
	#[doc = " any plane to 0 is the same as setting it to the scaled plane width (see"]
	#[doc = " @ref YUVnotes \"YUV Image Format Notes\".)  If <tt>strides</tt> is NULL, then"]
	#[doc = " the strides for all planes will be set to their respective scaled plane"]
	#[doc = " widths.  You can adjust the strides in order to add an arbitrary amount of"]
	#[doc = " line padding to each plane or to decompress the JPEG image into a subregion"]
	#[doc = " of a larger YUV planar image."]
	#[doc = ""]
	#[doc = " @param height desired height (in pixels) of the YUV image.  If this is"]
	#[doc = " different than the height of the JPEG image being decompressed, then"]
	#[doc = " TurboJPEG will use scaling in the JPEG decompressor to generate the largest"]
	#[doc = " possible image that will fit within the desired height.  If <tt>height</tt>"]
	#[doc = " is set to 0, then only the width will be considered when determining the"]
	#[doc = " scaled image size.  If the scaled height is not an even multiple of the MCU"]
	#[doc = " block height (see #tjMCUHeight), then an intermediate buffer copy will be"]
	#[doc = " performed within TurboJPEG."]
	#[doc = ""]
	#[doc = " @param flags the bitwise OR of one or more of the @ref TJFLAG_ACCURATEDCT"]
	#[doc = " \"flags\""]
	#[doc = ""]
	#[doc = " @return 0 if successful, or -1 if an error occurred (see #tjGetErrorStr2()"]
	#[doc = " and #tjGetErrorCode().)"]
	pub fn tjDecompressToYUVPlanes(
		handle: tjhandle,
		jpegBuf: *const ::std::os::raw::c_uchar,
		jpegSize: ::std::os::raw::c_ulong,
		dstPlanes: *mut *mut ::std::os::raw::c_uchar,
		width: ::std::os::raw::c_int,
		strides: *mut ::std::os::raw::c_int,
		height: ::std::os::raw::c_int,
		flags: ::std::os::raw::c_int,
	) -> ::std::os::raw::c_int;
}
extern "C" {
	#[doc = " Decode a YUV planar image into an RGB or grayscale image.  This function"]
	#[doc = " uses the accelerated color conversion routines in the underlying"]
	#[doc = " codec but does not execute any of the other steps in the JPEG decompression"]
	#[doc = " process."]
	#[doc = ""]
	#[doc = " @param handle a handle to a TurboJPEG decompressor or transformer instance"]
	#[doc = ""]
	#[doc = " @param srcBuf pointer to an image buffer containing a YUV planar image to be"]
	#[doc = " decoded.  The size of this buffer should match the value returned by"]
	#[doc = " #tjBufSizeYUV2() for the given image width, height, padding, and level of"]
	#[doc = " chrominance subsampling.  The Y, U (Cb), and V (Cr) image planes should be"]
	#[doc = " stored sequentially in the source buffer (refer to @ref YUVnotes"]
	#[doc = " \"YUV Image Format Notes\".)"]
	#[doc = ""]
	#[doc = " @param pad Use this parameter to specify that the width of each line in each"]
	#[doc = " plane of the YUV source image is padded to the nearest multiple of this"]
	#[doc = " number of bytes (must be a power of 2.)"]
	#[doc = ""]
	#[doc = " @param subsamp the level of chrominance subsampling used in the YUV source"]
	#[doc = " image (see @ref TJSAMP \"Chrominance subsampling options\".)"]
	#[doc = ""]
	#[doc = " @param dstBuf pointer to an image buffer that will receive the decoded"]
	#[doc = " image.  This buffer should normally be <tt>pitch * height</tt> bytes in"]
	#[doc = " size, but the <tt>dstBuf</tt> pointer can also be used to decode into a"]
	#[doc = " specific region of a larger buffer."]
	#[doc = ""]
	#[doc = " @param width width (in pixels) of the source and destination images"]
	#[doc = ""]
	#[doc = " @param pitch bytes per line in the destination image.  Normally, this should"]
	#[doc = " be <tt>width * #tjPixelSize[pixelFormat]</tt> if the destination image is"]
	#[doc = " unpadded, or <tt>#TJPAD(width * #tjPixelSize[pixelFormat])</tt> if each line"]
	#[doc = " of the destination image should be padded to the nearest 32-bit boundary, as"]
	#[doc = " is the case for Windows bitmaps.  You can also be clever and use the pitch"]
	#[doc = " parameter to skip lines, etc.  Setting this parameter to 0 is the equivalent"]
	#[doc = " of setting it to <tt>width * #tjPixelSize[pixelFormat]</tt>."]
	#[doc = ""]
	#[doc = " @param height height (in pixels) of the source and destination images"]
	#[doc = ""]
	#[doc = " @param pixelFormat pixel format of the destination image (see @ref TJPF"]
	#[doc = " \"Pixel formats\".)"]
	#[doc = ""]
	#[doc = " @param flags the bitwise OR of one or more of the @ref TJFLAG_ACCURATEDCT"]
	#[doc = " \"flags\""]
	#[doc = ""]
	#[doc = " @return 0 if successful, or -1 if an error occurred (see #tjGetErrorStr2()"]
	#[doc = " and #tjGetErrorCode().)"]
	pub fn tjDecodeYUV(
		handle: tjhandle,
		srcBuf: *const ::std::os::raw::c_uchar,
		pad: ::std::os::raw::c_int,
		subsamp: ::std::os::raw::c_int,
		dstBuf: *mut ::std::os::raw::c_uchar,
		width: ::std::os::raw::c_int,
		pitch: ::std::os::raw::c_int,
		height: ::std::os::raw::c_int,
		pixelFormat: ::std::os::raw::c_int,
		flags: ::std::os::raw::c_int,
	) -> ::std::os::raw::c_int;
}
extern "C" {
	#[doc = " Decode a set of Y, U (Cb), and V (Cr) image planes into an RGB or grayscale"]
	#[doc = " image.  This function uses the accelerated color conversion routines in the"]
	#[doc = " underlying codec but does not execute any of the other steps in the JPEG"]
	#[doc = " decompression process."]
	#[doc = ""]
	#[doc = " @param handle a handle to a TurboJPEG decompressor or transformer instance"]
	#[doc = ""]
	#[doc = " @param srcPlanes an array of pointers to Y, U (Cb), and V (Cr) image planes"]
	#[doc = " (or just a Y plane, if decoding a grayscale image) that contain a YUV image"]
	#[doc = " to be decoded.  These planes can be contiguous or non-contiguous in memory."]
	#[doc = " The size of each plane should match the value returned by #tjPlaneSizeYUV()"]
	#[doc = " for the given image width, height, strides, and level of chrominance"]
	#[doc = " subsampling.  Refer to @ref YUVnotes \"YUV Image Format Notes\" for more"]
	#[doc = " details."]
	#[doc = ""]
	#[doc = " @param strides an array of integers, each specifying the number of bytes per"]
	#[doc = " line in the corresponding plane of the YUV source image.  Setting the stride"]
	#[doc = " for any plane to 0 is the same as setting it to the plane width (see"]
	#[doc = " @ref YUVnotes \"YUV Image Format Notes\".)  If <tt>strides</tt> is NULL, then"]
	#[doc = " the strides for all planes will be set to their respective plane widths."]
	#[doc = " You can adjust the strides in order to specify an arbitrary amount of line"]
	#[doc = " padding in each plane or to decode a subregion of a larger YUV planar image."]
	#[doc = ""]
	#[doc = " @param subsamp the level of chrominance subsampling used in the YUV source"]
	#[doc = " image (see @ref TJSAMP \"Chrominance subsampling options\".)"]
	#[doc = ""]
	#[doc = " @param dstBuf pointer to an image buffer that will receive the decoded"]
	#[doc = " image.  This buffer should normally be <tt>pitch * height</tt> bytes in"]
	#[doc = " size, but the <tt>dstBuf</tt> pointer can also be used to decode into a"]
	#[doc = " specific region of a larger buffer."]
	#[doc = ""]
	#[doc = " @param width width (in pixels) of the source and destination images"]
	#[doc = ""]
	#[doc = " @param pitch bytes per line in the destination image.  Normally, this should"]
	#[doc = " be <tt>width * #tjPixelSize[pixelFormat]</tt> if the destination image is"]
	#[doc = " unpadded, or <tt>#TJPAD(width * #tjPixelSize[pixelFormat])</tt> if each line"]
	#[doc = " of the destination image should be padded to the nearest 32-bit boundary, as"]
	#[doc = " is the case for Windows bitmaps.  You can also be clever and use the pitch"]
	#[doc = " parameter to skip lines, etc.  Setting this parameter to 0 is the equivalent"]
	#[doc = " of setting it to <tt>width * #tjPixelSize[pixelFormat]</tt>."]
	#[doc = ""]
	#[doc = " @param height height (in pixels) of the source and destination images"]
	#[doc = ""]
	#[doc = " @param pixelFormat pixel format of the destination image (see @ref TJPF"]
	#[doc = " \"Pixel formats\".)"]
	#[doc = ""]
	#[doc = " @param flags the bitwise OR of one or more of the @ref TJFLAG_ACCURATEDCT"]
	#[doc = " \"flags\""]
	#[doc = ""]
	#[doc = " @return 0 if successful, or -1 if an error occurred (see #tjGetErrorStr2()"]
	#[doc = " and #tjGetErrorCode().)"]
	pub fn tjDecodeYUVPlanes(
		handle: tjhandle,
		srcPlanes: *mut *const ::std::os::raw::c_uchar,
		strides: *const ::std::os::raw::c_int,
		subsamp: ::std::os::raw::c_int,
		dstBuf: *mut ::std::os::raw::c_uchar,
		width: ::std::os::raw::c_int,
		pitch: ::std::os::raw::c_int,
		height: ::std::os::raw::c_int,
		pixelFormat: ::std::os::raw::c_int,
		flags: ::std::os::raw::c_int,
	) -> ::std::os::raw::c_int;
}
extern "C" {
	#[doc = " Create a new TurboJPEG transformer instance."]
	#[doc = ""]
	#[doc = " @return a handle to the newly-created instance, or NULL if an error"]
	#[doc = " occurred (see #tjGetErrorStr2().)"]
	pub fn tjInitTransform() -> tjhandle;
}
extern "C" {
	#[doc = " Losslessly transform a JPEG image into another JPEG image.  Lossless"]
	#[doc = " transforms work by moving the raw DCT coefficients from one JPEG image"]
	#[doc = " structure to another without altering the values of the coefficients.  While"]
	#[doc = " this is typically faster than decompressing the image, transforming it, and"]
	#[doc = " re-compressing it, lossless transforms are not free.  Each lossless"]
	#[doc = " transform requires reading and performing Huffman decoding on all of the"]
	#[doc = " coefficients in the source image, regardless of the size of the destination"]
	#[doc = " image.  Thus, this function provides a means of generating multiple"]
	#[doc = " transformed images from the same source or  applying multiple"]
	#[doc = " transformations simultaneously, in order to eliminate the need to read the"]
	#[doc = " source coefficients multiple times."]
	#[doc = ""]
	#[doc = " @param handle a handle to a TurboJPEG transformer instance"]
	#[doc = ""]
	#[doc = " @param jpegBuf pointer to a buffer containing the JPEG source image to"]
	#[doc = " transform"]
	#[doc = ""]
	#[doc = " @param jpegSize size of the JPEG source image (in bytes)"]
	#[doc = ""]
	#[doc = " @param n the number of transformed JPEG images to generate"]
	#[doc = ""]
	#[doc = " @param dstBufs pointer to an array of n image buffers.  <tt>dstBufs[i]</tt>"]
	#[doc = " will receive a JPEG image that has been transformed using the parameters in"]
	#[doc = " <tt>transforms[i]</tt>.  TurboJPEG has the ability to reallocate the JPEG"]
	#[doc = " buffer to accommodate the size of the JPEG image.  Thus, you can choose to:"]
	#[doc = " -# pre-allocate the JPEG buffer with an arbitrary size using #tjAlloc() and"]
	#[doc = " let TurboJPEG grow the buffer as needed,"]
	#[doc = " -# set <tt>dstBufs[i]</tt> to NULL to tell TurboJPEG to allocate the buffer"]
	#[doc = " for you, or"]
	#[doc = " -# pre-allocate the buffer to a \"worst case\" size determined by calling"]
	#[doc = " #tjBufSize() with the transformed or cropped width and height.  Under normal"]
	#[doc = " circumstances, this should ensure that the buffer never has to be"]
	#[doc = " re-allocated (setting #TJFLAG_NOREALLOC guarantees that it won't be.)  Note,"]
	#[doc = " however, that there are some rare cases (such as transforming images with a"]
	#[doc = " large amount of embedded EXIF or ICC profile data) in which the output image"]
	#[doc = " will be larger than the worst-case size, and #TJFLAG_NOREALLOC cannot be"]
	#[doc = " used in those cases."]
	#[doc = " ."]
	#[doc = " If you choose option 1, <tt>dstSizes[i]</tt> should be set to the size of"]
	#[doc = " your pre-allocated buffer.  In any case, unless you have set"]
	#[doc = " #TJFLAG_NOREALLOC, you should always check <tt>dstBufs[i]</tt> upon return"]
	#[doc = " from this function, as it may have changed."]
	#[doc = ""]
	#[doc = " @param dstSizes pointer to an array of n unsigned long variables that will"]
	#[doc = " receive the actual sizes (in bytes) of each transformed JPEG image.  If"]
	#[doc = " <tt>dstBufs[i]</tt> points to a pre-allocated buffer, then"]
	#[doc = " <tt>dstSizes[i]</tt> should be set to the size of the buffer.  Upon return,"]
	#[doc = " <tt>dstSizes[i]</tt> will contain the size of the JPEG image (in bytes.)"]
	#[doc = ""]
	#[doc = " @param transforms pointer to an array of n #tjtransform structures, each of"]
	#[doc = " which specifies the transform parameters and/or cropping region for the"]
	#[doc = " corresponding transformed output image."]
	#[doc = ""]
	#[doc = " @param flags the bitwise OR of one or more of the @ref TJFLAG_ACCURATEDCT"]
	#[doc = " \"flags\""]
	#[doc = ""]
	#[doc = " @return 0 if successful, or -1 if an error occurred (see #tjGetErrorStr2()"]
	#[doc = " and #tjGetErrorCode().)"]
	pub fn tjTransform(
		handle: tjhandle,
		jpegBuf: *const ::std::os::raw::c_uchar,
		jpegSize: ::std::os::raw::c_ulong,
		n: ::std::os::raw::c_int,
		dstBufs: *mut *mut ::std::os::raw::c_uchar,
		dstSizes: *mut ::std::os::raw::c_ulong,
		transforms: *mut tjtransform,
		flags: ::std::os::raw::c_int,
	) -> ::std::os::raw::c_int;
}
extern "C" {
	#[doc = " Destroy a TurboJPEG compressor, decompressor, or transformer instance."]
	#[doc = ""]
	#[doc = " @param handle a handle to a TurboJPEG compressor, decompressor or"]
	#[doc = " transformer instance"]
	#[doc = ""]
	#[doc = " @return 0 if successful, or -1 if an error occurred (see #tjGetErrorStr2().)"]
	pub fn tjDestroy(handle: tjhandle) -> ::std::os::raw::c_int;
}
extern "C" {
	#[doc = " Allocate an image buffer for use with TurboJPEG.  You should always use"]
	#[doc = " this function to allocate the JPEG destination buffer(s) for the compression"]
	#[doc = " and transform functions unless you are disabling automatic buffer"]
	#[doc = " (re)allocation (by setting #TJFLAG_NOREALLOC.)"]
	#[doc = ""]
	#[doc = " @param bytes the number of bytes to allocate"]
	#[doc = ""]
	#[doc = " @return a pointer to a newly-allocated buffer with the specified number of"]
	#[doc = " bytes."]
	#[doc = ""]
	#[doc = " @sa tjFree()"]
	pub fn tjAlloc(bytes: ::std::os::raw::c_int) -> *mut ::std::os::raw::c_uchar;
}
extern "C" {
	#[doc = " Load an uncompressed image from disk into memory."]
	#[doc = ""]
	#[doc = " @param filename name of a file containing an uncompressed image in Windows"]
	#[doc = " BMP or PBMPLUS (PPM/PGM) format"]
	#[doc = ""]
	#[doc = " @param width pointer to an integer variable that will receive the width (in"]
	#[doc = " pixels) of the uncompressed image"]
	#[doc = ""]
	#[doc = " @param align row alignment of the image buffer to be returned (must be a"]
	#[doc = " power of 2.)  For instance, setting this parameter to 4 will cause all rows"]
	#[doc = " in the image buffer to be padded to the nearest 32-bit boundary, and setting"]
	#[doc = " this parameter to 1 will cause all rows in the image buffer to be unpadded."]
	#[doc = ""]
	#[doc = " @param height pointer to an integer variable that will receive the height"]
	#[doc = " (in pixels) of the uncompressed image"]
	#[doc = ""]
	#[doc = " @param pixelFormat pointer to an integer variable that specifies or will"]
	#[doc = " receive the pixel format of the uncompressed image buffer.  The behavior of"]
	#[doc = " #tjLoadImage() will vary depending on the value of <tt>*pixelFormat</tt>"]
	#[doc = " passed to the function:"]
	#[doc = " - @ref TJPF_UNKNOWN : The uncompressed image buffer returned by the function"]
	#[doc = " will use the most optimal pixel format for the file type, and"]
	#[doc = " <tt>*pixelFormat</tt> will contain the ID of this pixel format upon"]
	#[doc = " successful return from the function."]
	#[doc = " - @ref TJPF_GRAY : Only PGM files and 8-bit BMP files with a grayscale"]
	#[doc = " colormap can be loaded."]
	#[doc = " - @ref TJPF_CMYK : The RGB or grayscale pixels stored in the file will be"]
	#[doc = " converted using a quick & dirty algorithm that is suitable only for testing"]
	#[doc = " purposes (proper conversion between CMYK and other formats requires a color"]
	#[doc = " management system.)"]
	#[doc = " - Other @ref TJPF \"pixel formats\" : The uncompressed image buffer will use"]
	#[doc = " the specified pixel format, and pixel format conversion will be performed if"]
	#[doc = " necessary."]
	#[doc = ""]
	#[doc = " @param flags the bitwise OR of one or more of the @ref TJFLAG_BOTTOMUP"]
	#[doc = " \"flags\"."]
	#[doc = ""]
	#[doc = " @return a pointer to a newly-allocated buffer containing the uncompressed"]
	#[doc = " image, converted to the chosen pixel format and with the chosen row"]
	#[doc = " alignment, or NULL if an error occurred (see #tjGetErrorStr2().)  This"]
	#[doc = " buffer should be freed using #tjFree()."]
	pub fn tjLoadImage(
		filename: *const ::std::os::raw::c_char,
		width: *mut ::std::os::raw::c_int,
		align: ::std::os::raw::c_int,
		height: *mut ::std::os::raw::c_int,
		pixelFormat: *mut ::std::os::raw::c_int,
		flags: ::std::os::raw::c_int,
	) -> *mut ::std::os::raw::c_uchar;
}
extern "C" {
	#[doc = " Save an uncompressed image from memory to disk."]
	#[doc = ""]
	#[doc = " @param filename name of a file to which to save the uncompressed image."]
	#[doc = " The image will be stored in Windows BMP or PBMPLUS (PPM/PGM) format,"]
	#[doc = " depending on the file extension."]
	#[doc = ""]
	#[doc = " @param buffer pointer to an image buffer containing RGB, grayscale, or"]
	#[doc = " CMYK pixels to be saved"]
	#[doc = ""]
	#[doc = " @param width width (in pixels) of the uncompressed image"]
	#[doc = ""]
	#[doc = " @param pitch bytes per line in the image buffer.  Setting this parameter to"]
	#[doc = " 0 is the equivalent of setting it to"]
	#[doc = " <tt>width * #tjPixelSize[pixelFormat]</tt>."]
	#[doc = ""]
	#[doc = " @param height height (in pixels) of the uncompressed image"]
	#[doc = ""]
	#[doc = " @param pixelFormat pixel format of the image buffer (see @ref TJPF"]
	#[doc = " \"Pixel formats\".)  If this parameter is set to @ref TJPF_GRAY, then the"]
	#[doc = " image will be stored in PGM or 8-bit (indexed color) BMP format.  Otherwise,"]
	#[doc = " the image will be stored in PPM or 24-bit BMP format.  If this parameter"]
	#[doc = " is set to @ref TJPF_CMYK, then the CMYK pixels will be converted to RGB"]
	#[doc = " using a quick & dirty algorithm that is suitable only for testing (proper"]
	#[doc = " conversion between CMYK and other formats requires a color management"]
	#[doc = " system.)"]
	#[doc = ""]
	#[doc = " @param flags the bitwise OR of one or more of the @ref TJFLAG_BOTTOMUP"]
	#[doc = " \"flags\"."]
	#[doc = ""]
	#[doc = " @return 0 if successful, or -1 if an error occurred (see #tjGetErrorStr2().)"]
	pub fn tjSaveImage(
		filename: *const ::std::os::raw::c_char,
		buffer: *mut ::std::os::raw::c_uchar,
		width: ::std::os::raw::c_int,
		pitch: ::std::os::raw::c_int,
		height: ::std::os::raw::c_int,
		pixelFormat: ::std::os::raw::c_int,
		flags: ::std::os::raw::c_int,
	) -> ::std::os::raw::c_int;
}
extern "C" {
	#[doc = " Free an image buffer previously allocated by TurboJPEG.  You should always"]
	#[doc = " use this function to free JPEG destination buffer(s) that were automatically"]
	#[doc = " (re)allocated by the compression and transform functions or that were"]
	#[doc = " manually allocated using #tjAlloc()."]
	#[doc = ""]
	#[doc = " @param buffer address of the buffer to free.  If the address is NULL, then"]
	#[doc = " this function has no effect."]
	#[doc = ""]
	#[doc = " @sa tjAlloc()"]
	pub fn tjFree(buffer: *mut ::std::os::raw::c_uchar);
}
extern "C" {
	#[doc = " Returns a descriptive error message explaining why the last command failed."]
	#[doc = ""]
	#[doc = " @param handle a handle to a TurboJPEG compressor, decompressor, or"]
	#[doc = " transformer instance, or NULL if the error was generated by a global"]
	#[doc = " function (but note that retrieving the error message for a global function"]
	#[doc = " is not thread-safe.)"]
	#[doc = ""]
	#[doc = " @return a descriptive error message explaining why the last command failed."]
	pub fn tjGetErrorStr2(handle: tjhandle) -> *mut ::std::os::raw::c_char;
}
extern "C" {
	#[doc = " Returns a code indicating the severity of the last error.  See"]
	#[doc = " @ref TJERR \"Error codes\"."]
	#[doc = ""]
	#[doc = " @param handle a handle to a TurboJPEG compressor, decompressor or"]
	#[doc = " transformer instance"]
	#[doc = ""]
	#[doc = " @return a code indicating the severity of the last error.  See"]
	#[doc = " @ref TJERR \"Error codes\"."]
	pub fn tjGetErrorCode(handle: tjhandle) -> ::std::os::raw::c_int;
}
extern "C" {
	pub fn TJBUFSIZE(
		width: ::std::os::raw::c_int,
		height: ::std::os::raw::c_int,
	) -> ::std::os::raw::c_ulong;
}
extern "C" {
	pub fn TJBUFSIZEYUV(
		width: ::std::os::raw::c_int,
		height: ::std::os::raw::c_int,
		jpegSubsamp: ::std::os::raw::c_int,
	) -> ::std::os::raw::c_ulong;
}
extern "C" {
	pub fn tjBufSizeYUV(
		width: ::std::os::raw::c_int,
		height: ::std::os::raw::c_int,
		subsamp: ::std::os::raw::c_int,
	) -> ::std::os::raw::c_ulong;
}
extern "C" {
	pub fn tjCompress(
		handle: tjhandle,
		srcBuf: *mut ::std::os::raw::c_uchar,
		width: ::std::os::raw::c_int,
		pitch: ::std::os::raw::c_int,
		height: ::std::os::raw::c_int,
		pixelSize: ::std::os::raw::c_int,
		dstBuf: *mut ::std::os::raw::c_uchar,
		compressedSize: *mut ::std::os::raw::c_ulong,
		jpegSubsamp: ::std::os::raw::c_int,
		jpegQual: ::std::os::raw::c_int,
		flags: ::std::os::raw::c_int,
	) -> ::std::os::raw::c_int;
}
extern "C" {
	pub fn tjEncodeYUV(
		handle: tjhandle,
		srcBuf: *mut ::std::os::raw::c_uchar,
		width: ::std::os::raw::c_int,
		pitch: ::std::os::raw::c_int,
		height: ::std::os::raw::c_int,
		pixelSize: ::std::os::raw::c_int,
		dstBuf: *mut ::std::os::raw::c_uchar,
		subsamp: ::std::os::raw::c_int,
		flags: ::std::os::raw::c_int,
	) -> ::std::os::raw::c_int;
}
extern "C" {
	pub fn tjEncodeYUV2(
		handle: tjhandle,
		srcBuf: *mut ::std::os::raw::c_uchar,
		width: ::std::os::raw::c_int,
		pitch: ::std::os::raw::c_int,
		height: ::std::os::raw::c_int,
		pixelFormat: ::std::os::raw::c_int,
		dstBuf: *mut ::std::os::raw::c_uchar,
		subsamp: ::std::os::raw::c_int,
		flags: ::std::os::raw::c_int,
	) -> ::std::os::raw::c_int;
}
extern "C" {
	pub fn tjDecompressHeader(
		handle: tjhandle,
		jpegBuf: *mut ::std::os::raw::c_uchar,
		jpegSize: ::std::os::raw::c_ulong,
		width: *mut ::std::os::raw::c_int,
		height: *mut ::std::os::raw::c_int,
	) -> ::std::os::raw::c_int;
}
extern "C" {
	pub fn tjDecompressHeader2(
		handle: tjhandle,
		jpegBuf: *mut ::std::os::raw::c_uchar,
		jpegSize: ::std::os::raw::c_ulong,
		width: *mut ::std::os::raw::c_int,
		height: *mut ::std::os::raw::c_int,
		jpegSubsamp: *mut ::std::os::raw::c_int,
	) -> ::std::os::raw::c_int;
}
extern "C" {
	pub fn tjDecompress(
		handle: tjhandle,
		jpegBuf: *mut ::std::os::raw::c_uchar,
		jpegSize: ::std::os::raw::c_ulong,
		dstBuf: *mut ::std::os::raw::c_uchar,
		width: ::std::os::raw::c_int,
		pitch: ::std::os::raw::c_int,
		height: ::std::os::raw::c_int,
		pixelSize: ::std::os::raw::c_int,
		flags: ::std::os::raw::c_int,
	) -> ::std::os::raw::c_int;
}
extern "C" {
	pub fn tjDecompressToYUV(
		handle: tjhandle,
		jpegBuf: *mut ::std::os::raw::c_uchar,
		jpegSize: ::std::os::raw::c_ulong,
		dstBuf: *mut ::std::os::raw::c_uchar,
		flags: ::std::os::raw::c_int,
	) -> ::std::os::raw::c_int;
}
extern "C" {
	pub fn tjGetErrorStr() -> *mut ::std::os::raw::c_char;
}
pub const JXFORM_CODE_JXFORM_NONE: JXFORM_CODE = 0;
pub const JXFORM_CODE_JXFORM_FLIP_H: JXFORM_CODE = 1;
pub const JXFORM_CODE_JXFORM_FLIP_V: JXFORM_CODE = 2;
pub const JXFORM_CODE_JXFORM_TRANSPOSE: JXFORM_CODE = 3;
pub const JXFORM_CODE_JXFORM_TRANSVERSE: JXFORM_CODE = 4;
pub const JXFORM_CODE_JXFORM_ROT_90: JXFORM_CODE = 5;
pub const JXFORM_CODE_JXFORM_ROT_180: JXFORM_CODE = 6;
pub const JXFORM_CODE_JXFORM_ROT_270: JXFORM_CODE = 7;
pub type JXFORM_CODE = u32;
pub const JCROP_CODE_JCROP_UNSET: JCROP_CODE = 0;
pub const JCROP_CODE_JCROP_POS: JCROP_CODE = 1;
pub const JCROP_CODE_JCROP_NEG: JCROP_CODE = 2;
pub const JCROP_CODE_JCROP_FORCE: JCROP_CODE = 3;
pub type JCROP_CODE = u32;
#[repr(C)]
pub struct jpeg_transform_info {
	pub transform: JXFORM_CODE,
	pub perfect: boolean,
	pub trim: boolean,
	pub force_grayscale: boolean,
	pub crop: boolean,
	pub slow_hflip: boolean,
	pub crop_width: JDIMENSION,
	pub crop_width_set: JCROP_CODE,
	pub crop_height: JDIMENSION,
	pub crop_height_set: JCROP_CODE,
	pub crop_xoffset: JDIMENSION,
	pub crop_xoffset_set: JCROP_CODE,
	pub crop_yoffset: JDIMENSION,
	pub crop_yoffset_set: JCROP_CODE,
	pub num_components: ::std::os::raw::c_int,
	pub workspace_coef_arrays: *mut jvirt_barray_ptr,
	pub output_width: JDIMENSION,
	pub output_height: JDIMENSION,
	pub x_crop_offset: JDIMENSION,
	pub y_crop_offset: JDIMENSION,
	pub iMCU_sample_width: ::std::os::raw::c_int,
	pub iMCU_sample_height: ::std::os::raw::c_int,
}
#[test]
fn bindgen_test_layout_jpeg_transform_info() {
	assert_eq!(
		::core::mem::size_of::<jpeg_transform_info>(),
		96usize,
		concat!("Size of: ", stringify!(jpeg_transform_info))
	);
	assert_eq!(
		::core::mem::align_of::<jpeg_transform_info>(),
		8usize,
		concat!("Alignment of ", stringify!(jpeg_transform_info))
	);
	assert_eq!(
		unsafe { &(*(::core::ptr::null::<jpeg_transform_info>())).transform as *const _ as usize },
		0usize,
		concat!(
			"Offset of field: ",
			stringify!(jpeg_transform_info),
			"::",
			stringify!(transform)
		)
	);
	assert_eq!(
		unsafe { &(*(::core::ptr::null::<jpeg_transform_info>())).perfect as *const _ as usize },
		4usize,
		concat!(
			"Offset of field: ",
			stringify!(jpeg_transform_info),
			"::",
			stringify!(perfect)
		)
	);
	assert_eq!(
		unsafe { &(*(::core::ptr::null::<jpeg_transform_info>())).trim as *const _ as usize },
		8usize,
		concat!(
			"Offset of field: ",
			stringify!(jpeg_transform_info),
			"::",
			stringify!(trim)
		)
	);
	assert_eq!(
		unsafe {
			&(*(::core::ptr::null::<jpeg_transform_info>())).force_grayscale as *const _ as usize
		},
		12usize,
		concat!(
			"Offset of field: ",
			stringify!(jpeg_transform_info),
			"::",
			stringify!(force_grayscale)
		)
	);
	assert_eq!(
		unsafe { &(*(::core::ptr::null::<jpeg_transform_info>())).crop as *const _ as usize },
		16usize,
		concat!(
			"Offset of field: ",
			stringify!(jpeg_transform_info),
			"::",
			stringify!(crop)
		)
	);
	assert_eq!(
		unsafe { &(*(::core::ptr::null::<jpeg_transform_info>())).slow_hflip as *const _ as usize },
		20usize,
		concat!(
			"Offset of field: ",
			stringify!(jpeg_transform_info),
			"::",
			stringify!(slow_hflip)
		)
	);
	assert_eq!(
		unsafe { &(*(::core::ptr::null::<jpeg_transform_info>())).crop_width as *const _ as usize },
		24usize,
		concat!(
			"Offset of field: ",
			stringify!(jpeg_transform_info),
			"::",
			stringify!(crop_width)
		)
	);
	assert_eq!(
		unsafe {
			&(*(::core::ptr::null::<jpeg_transform_info>())).crop_width_set as *const _ as usize
		},
		28usize,
		concat!(
			"Offset of field: ",
			stringify!(jpeg_transform_info),
			"::",
			stringify!(crop_width_set)
		)
	);
	assert_eq!(
		unsafe {
			&(*(::core::ptr::null::<jpeg_transform_info>())).crop_height as *const _ as usize
		},
		32usize,
		concat!(
			"Offset of field: ",
			stringify!(jpeg_transform_info),
			"::",
			stringify!(crop_height)
		)
	);
	assert_eq!(
		unsafe {
			&(*(::core::ptr::null::<jpeg_transform_info>())).crop_height_set as *const _ as usize
		},
		36usize,
		concat!(
			"Offset of field: ",
			stringify!(jpeg_transform_info),
			"::",
			stringify!(crop_height_set)
		)
	);
	assert_eq!(
		unsafe {
			&(*(::core::ptr::null::<jpeg_transform_info>())).crop_xoffset as *const _ as usize
		},
		40usize,
		concat!(
			"Offset of field: ",
			stringify!(jpeg_transform_info),
			"::",
			stringify!(crop_xoffset)
		)
	);
	assert_eq!(
		unsafe {
			&(*(::core::ptr::null::<jpeg_transform_info>())).crop_xoffset_set as *const _ as usize
		},
		44usize,
		concat!(
			"Offset of field: ",
			stringify!(jpeg_transform_info),
			"::",
			stringify!(crop_xoffset_set)
		)
	);
	assert_eq!(
		unsafe {
			&(*(::core::ptr::null::<jpeg_transform_info>())).crop_yoffset as *const _ as usize
		},
		48usize,
		concat!(
			"Offset of field: ",
			stringify!(jpeg_transform_info),
			"::",
			stringify!(crop_yoffset)
		)
	);
	assert_eq!(
		unsafe {
			&(*(::core::ptr::null::<jpeg_transform_info>())).crop_yoffset_set as *const _ as usize
		},
		52usize,
		concat!(
			"Offset of field: ",
			stringify!(jpeg_transform_info),
			"::",
			stringify!(crop_yoffset_set)
		)
	);
	assert_eq!(
		unsafe {
			&(*(::core::ptr::null::<jpeg_transform_info>())).num_components as *const _ as usize
		},
		56usize,
		concat!(
			"Offset of field: ",
			stringify!(jpeg_transform_info),
			"::",
			stringify!(num_components)
		)
	);
	assert_eq!(
		unsafe {
			&(*(::core::ptr::null::<jpeg_transform_info>())).workspace_coef_arrays as *const _
				as usize
		},
		64usize,
		concat!(
			"Offset of field: ",
			stringify!(jpeg_transform_info),
			"::",
			stringify!(workspace_coef_arrays)
		)
	);
	assert_eq!(
		unsafe {
			&(*(::core::ptr::null::<jpeg_transform_info>())).output_width as *const _ as usize
		},
		72usize,
		concat!(
			"Offset of field: ",
			stringify!(jpeg_transform_info),
			"::",
			stringify!(output_width)
		)
	);
	assert_eq!(
		unsafe {
			&(*(::core::ptr::null::<jpeg_transform_info>())).output_height as *const _ as usize
		},
		76usize,
		concat!(
			"Offset of field: ",
			stringify!(jpeg_transform_info),
			"::",
			stringify!(output_height)
		)
	);
	assert_eq!(
		unsafe {
			&(*(::core::ptr::null::<jpeg_transform_info>())).x_crop_offset as *const _ as usize
		},
		80usize,
		concat!(
			"Offset of field: ",
			stringify!(jpeg_transform_info),
			"::",
			stringify!(x_crop_offset)
		)
	);
	assert_eq!(
		unsafe {
			&(*(::core::ptr::null::<jpeg_transform_info>())).y_crop_offset as *const _ as usize
		},
		84usize,
		concat!(
			"Offset of field: ",
			stringify!(jpeg_transform_info),
			"::",
			stringify!(y_crop_offset)
		)
	);
	assert_eq!(
		unsafe {
			&(*(::core::ptr::null::<jpeg_transform_info>())).iMCU_sample_width as *const _ as usize
		},
		88usize,
		concat!(
			"Offset of field: ",
			stringify!(jpeg_transform_info),
			"::",
			stringify!(iMCU_sample_width)
		)
	);
	assert_eq!(
		unsafe {
			&(*(::core::ptr::null::<jpeg_transform_info>())).iMCU_sample_height as *const _ as usize
		},
		92usize,
		concat!(
			"Offset of field: ",
			stringify!(jpeg_transform_info),
			"::",
			stringify!(iMCU_sample_height)
		)
	);
}
extern "C" {
	pub fn jtransform_parse_crop_spec(
		info: *mut jpeg_transform_info,
		spec: *const ::std::os::raw::c_char,
	) -> boolean;
}
extern "C" {
	pub fn jtransform_request_workspace(
		srcinfo: j_decompress_ptr,
		info: *mut jpeg_transform_info,
	) -> boolean;
}
extern "C" {
	pub fn jtransform_adjust_parameters(
		srcinfo: j_decompress_ptr,
		dstinfo: j_compress_ptr,
		src_coef_arrays: *mut jvirt_barray_ptr,
		info: *mut jpeg_transform_info,
	) -> *mut jvirt_barray_ptr;
}
extern "C" {
	pub fn jtransform_execute_transform(
		srcinfo: j_decompress_ptr,
		dstinfo: j_compress_ptr,
		src_coef_arrays: *mut jvirt_barray_ptr,
		info: *mut jpeg_transform_info,
	);
}
extern "C" {
	pub fn jtransform_perfect_transform(
		image_width: JDIMENSION,
		image_height: JDIMENSION,
		MCU_width: ::std::os::raw::c_int,
		MCU_height: ::std::os::raw::c_int,
		transform: JXFORM_CODE,
	) -> boolean;
}
pub const JCOPY_OPTION_JCOPYOPT_NONE: JCOPY_OPTION = 0;
pub const JCOPY_OPTION_JCOPYOPT_COMMENTS: JCOPY_OPTION = 1;
pub const JCOPY_OPTION_JCOPYOPT_ALL: JCOPY_OPTION = 2;
pub const JCOPY_OPTION_JCOPYOPT_ALL_EXCEPT_ICC: JCOPY_OPTION = 3;
pub type JCOPY_OPTION = u32;
extern "C" {
	pub fn jcopy_markers_setup(srcinfo: j_decompress_ptr, option: JCOPY_OPTION);
}
extern "C" {
	pub fn jcopy_markers_execute(
		srcinfo: j_decompress_ptr,
		dstinfo: j_compress_ptr,
		option: JCOPY_OPTION,
	);
}
pub type __builtin_va_list = [__va_list_tag; 1usize];
#[repr(C)]
pub struct __va_list_tag {
	pub gp_offset: ::std::os::raw::c_uint,
	pub fp_offset: ::std::os::raw::c_uint,
	pub overflow_arg_area: *mut ::core::ffi::c_void,
	pub reg_save_area: *mut ::core::ffi::c_void,
}
#[test]
fn bindgen_test_layout___va_list_tag() {
	assert_eq!(
		::core::mem::size_of::<__va_list_tag>(),
		24usize,
		concat!("Size of: ", stringify!(__va_list_tag))
	);
	assert_eq!(
		::core::mem::align_of::<__va_list_tag>(),
		8usize,
		concat!("Alignment of ", stringify!(__va_list_tag))
	);
	assert_eq!(
		unsafe { &(*(::core::ptr::null::<__va_list_tag>())).gp_offset as *const _ as usize },
		0usize,
		concat!(
			"Offset of field: ",
			stringify!(__va_list_tag),
			"::",
			stringify!(gp_offset)
		)
	);
	assert_eq!(
		unsafe { &(*(::core::ptr::null::<__va_list_tag>())).fp_offset as *const _ as usize },
		4usize,
		concat!(
			"Offset of field: ",
			stringify!(__va_list_tag),
			"::",
			stringify!(fp_offset)
		)
	);
	assert_eq!(
		unsafe {
			&(*(::core::ptr::null::<__va_list_tag>())).overflow_arg_area as *const _ as usize
		},
		8usize,
		concat!(
			"Offset of field: ",
			stringify!(__va_list_tag),
			"::",
			stringify!(overflow_arg_area)
		)
	);
	assert_eq!(
		unsafe { &(*(::core::ptr::null::<__va_list_tag>())).reg_save_area as *const _ as usize },
		16usize,
		concat!(
			"Offset of field: ",
			stringify!(__va_list_tag),
			"::",
			stringify!(reg_save_area)
		)
	);
}
#[repr(C)]
pub struct __locale_data {
	pub _address: u8,
}
#[repr(C)]
pub struct jpeg_comp_master {
	pub _address: u8,
}
#[repr(C)]
pub struct jpeg_c_main_controller {
	pub _address: u8,
}
#[repr(C)]
pub struct jpeg_c_prep_controller {
	pub _address: u8,
}
#[repr(C)]
pub struct jpeg_c_coef_controller {
	pub _address: u8,
}
#[repr(C)]
pub struct jpeg_marker_writer {
	pub _address: u8,
}
#[repr(C)]
pub struct jpeg_color_converter {
	pub _address: u8,
}
#[repr(C)]
pub struct jpeg_downsampler {
	pub _address: u8,
}
#[repr(C)]
pub struct jpeg_forward_dct {
	pub _address: u8,
}
#[repr(C)]
pub struct jpeg_entropy_encoder {
	pub _address: u8,
}
#[repr(C)]
pub struct jpeg_decomp_master {
	pub _address: u8,
}
#[repr(C)]
pub struct jpeg_d_main_controller {
	pub _address: u8,
}
#[repr(C)]
pub struct jpeg_d_coef_controller {
	pub _address: u8,
}
#[repr(C)]
pub struct jpeg_d_post_controller {
	pub _address: u8,
}
#[repr(C)]
pub struct jpeg_input_controller {
	pub _address: u8,
}
#[repr(C)]
pub struct jpeg_marker_reader {
	pub _address: u8,
}
#[repr(C)]
pub struct jpeg_entropy_decoder {
	pub _address: u8,
}
#[repr(C)]
pub struct jpeg_inverse_dct {
	pub _address: u8,
}
#[repr(C)]
pub struct jpeg_upsampler {
	pub _address: u8,
}
#[repr(C)]
pub struct jpeg_color_deconverter {
	pub _address: u8,
}
#[repr(C)]
pub struct jpeg_color_quantizer {
	pub _address: u8,
}
