/*!
# Flaca: Lodepng

These are FFI bindings to the upstream `lodepng.c` library functionality
required to recreate the `zopflipng` behaviors in Rust.
*/

#![allow(non_camel_case_types, non_upper_case_globals)]

use crate::ZOPFLI_ITERATIONS;
use std::{
	ffi::{
		c_uchar,
		c_uint,
		c_void,
	},
	mem::MaybeUninit,
};
use super::{
	deflate_part,
	ffi::EncodedImage,
	SplitPoints,
};



// Generated by build.rs.
include!(concat!(env!("OUT_DIR"), "/lodepng-bindgen.rs"));

const ZOPFLI_MASTER_BLOCK_SIZE: usize = 1_000_000;



#[no_mangle]
#[inline]
#[allow(unsafe_code)]
/// # Custom PNG Deflate.
///
/// This tells lodepng to use zopfli for encoding.
pub(crate) extern "C" fn flaca_png_deflate(
	out: *mut *mut c_uchar,
	outsize: *mut usize,
	arr: *const c_uchar,
	insize: usize,
	_settings: *const LodePNGCompressSettings,
) -> c_uint {
	// Figure out how many iterations to use.
	let mut numiterations = *ZOPFLI_ITERATIONS.get_or_init(|| 0);
	if numiterations <= 0 {
		numiterations = if insize < 200_000 { 60 } else { 20 };
	}

	// Initialize a reusable split-point buffer.
	let mut splits = SplitPoints::new();
	let mut dst = ZopfliOut {
		bp: 0,
		out,
		outsize,
	};

	// Compress in chunks, Ã  la ZopfliDeflate.
	let mut i: usize = 0;
	while i < insize {
		// Each pass needs to know if it is the last, and how much data to
		// handle.
		let (last_part, size) =
			if i + ZOPFLI_MASTER_BLOCK_SIZE >= insize { (true, insize - i) }
			else { (false, ZOPFLI_MASTER_BLOCK_SIZE) };

		// Crunch the part!
		let res = deflate_part(
			&mut splits,
			numiterations,
			last_part,
			unsafe { std::slice::from_raw_parts(arr, i + size) },
			i,
			&mut dst,
		);

		if res.is_err() {
			// Force a panic in debug mode.
			#[cfg(debug_assertions)] panic!("(zopfli) {res:?}");

			// Otherwise just let lodepng know we failed.
			return 1;
		}

		// Onward and upward!
		i += size;
	}

	// Errors panic, so if we're here everything must be fine.
	0
}



#[derive(Debug)]
/// # Decoded Image.
pub(super) struct DecodedImage {
	pub(super) buf: *mut c_uchar,
	pub(super) w: c_uint,
	pub(super) h: c_uint,
}

impl Drop for DecodedImage {
	#[allow(unsafe_code)]
	fn drop(&mut self) {
		if ! self.buf.is_null() {
			unsafe { libc::free(self.buf.cast::<c_void>()); }
			self.buf = std::ptr::null_mut();
		}
	}
}



/// # Lodepng Output Pointers.
///
/// This struct provides a wrapper around the lingering bit-writing zopfli C
/// methods, saving us the trouble of having to pass down three different
/// pointers (and using a bunch of unsafe blocks) just to get the data saved.
pub(super) struct ZopfliOut {
	bp: u8,
	out: *mut *mut u8,
	outsize: *mut usize,
}

impl ZopfliOut {
	#[allow(unsafe_code)]
	#[inline]
	/// # Add Bit.
	pub(crate) fn add_bit(&mut self, bit: i32) {
		unsafe {
			// Safety: only unsafe because of FFI.
			ZopfliAddBit(bit, &mut self.bp, self.out, self.outsize);
		}
	}

	#[allow(unsafe_code)]
	#[inline]
	/// # Add Multiple Bits.
	pub(crate) fn add_bits(&mut self, symbol: u32, length: u32) {
		unsafe {
			// Safety: only unsafe because of FFI.
			ZopfliAddBits(symbol, length,&mut self.bp, self.out, self.outsize);
		}
	}

	#[allow(unsafe_code)]
	#[inline]
	/// # Add Huffman Bits.
	pub(crate) fn add_huffman_bits(&mut self, symbol: u32, length: u32) {
		unsafe {
			// Safety: only unsafe because of FFI.
			ZopfliAddHuffmanBits(symbol, length,&mut self.bp, self.out, self.outsize);
		}
	}

	#[allow(unsafe_code)]
	#[inline]
	/// # Add Non-Compressed Block.
	pub(crate) fn add_uncompressed_block(
		&mut self,
		last_block: bool,
		arr: *const u8,
		start: usize,
		end: usize,
	) {
		unsafe {
			// Safety: only unsafe because of FFI.
			ZopfliAddNonCompressedBlock(
				i32::from(last_block),
				arr,
				start,
				end,
				&mut self.bp,
				self.out,
				self.outsize,
			);
		}
	}
}



impl Default for LodePNGColorStats {
	#[allow(unsafe_code)]
	fn default() -> Self {
		let mut out = MaybeUninit::<Self>::zeroed();
		unsafe {
			// Safety: lodepng_color_stats_init sets the data.
			lodepng_color_stats_init(out.as_mut_ptr());
			out.assume_init()
		}
	}
}

impl LodePNGColorType {
	/// # Confirm Raw Image Color Type
	///
	/// This reads the color type from the raw image header to check if it
	/// matches `self`.
	///
	/// Note to future self: 25 == 16 (start of IHDR chunk) + 4 (be32 width) + 4
	/// (be32 height) + 1 (bitdepth).
	pub(super) const fn is_match(self, src: &[u8]) -> bool {
		25 < src.len() && src[25] == self as u8
	}
}

impl Default for LodePNGState {
	#[allow(unsafe_code)]
	fn default() -> Self {
		let mut out = MaybeUninit::<Self>::zeroed();
		unsafe {
			// Safety: lodepng_state_init sets the data.
			lodepng_state_init(out.as_mut_ptr());
			out.assume_init()
		}
	}
}

impl Drop for LodePNGState {
	#[allow(unsafe_code)]
	fn drop(&mut self) { unsafe { lodepng_state_cleanup(self) } }
}

impl LodePNGState {
	#[allow(unsafe_code)]
	/// # Decode!
	pub(super) fn decode(&mut self, src: &[u8]) -> Option<DecodedImage> {
		let mut buf = std::ptr::null_mut();
		let mut w = 0;
		let mut h = 0;

		// Safety: a non-zero response is an error.
		let res = unsafe {
			lodepng_decode(&mut buf, &mut w, &mut h, self, src.as_ptr(), src.len())
		};

		// Return it if we got it.
		if 0 == res && ! buf.is_null() && 0 != w && 0 != h {
			Some(DecodedImage { buf, w, h })
		}
		else { None }
	}

	#[allow(unsafe_code)]
	/// # Encode!
	pub(super) fn encode(&mut self, img: &DecodedImage) -> Option<EncodedImage<usize>> {
		// Safety: a non-zero response is an error.
		let mut out = EncodedImage::default();
		let res = unsafe {
			lodepng_encode(&mut out.buf, &mut out.size, img.buf, img.w, img.h, self)
		};

		// Return it if we got it.
		if 0 == res && ! out.is_empty() { Some(out) }
		else { None }
	}

	#[allow(unsafe_code)]
	/// # Set Up Encoder.
	///
	/// This configures and returns a new state for encoding purposes.
	pub(super) fn encoder(
		dec: &Self,
		strategy: LodePNGFilterStrategy,
		slow: bool
	) -> Option<Self> {
		let mut enc = Self::default();

		// Copy palette details over to the encoder.
		if dec.info_png.color.colortype == LodePNGColorType::LCT_PALETTE {
			// Safety: a non-zero response indicates an error.
			if 0 != unsafe {
				lodepng_color_mode_copy(&mut enc.info_raw, &dec.info_png.color)
			} { return None; }

			enc.info_raw.colortype = LodePNGColorType::LCT_RGBA;
			enc.info_raw.bitdepth = 8;
		}

		enc.encoder.filter_palette_zero = 0;
		enc.encoder.filter_strategy = strategy;
		enc.encoder.add_id = 0;
		enc.encoder.text_compression = 1;

		// For final compression, enable the custom zopfli deflater.
		if slow {
			enc.encoder.zlibsettings.windowsize = 32_768;
			enc.encoder.zlibsettings.custom_deflate = Some(flaca_png_deflate);
		}
		else {
			enc.encoder.zlibsettings.windowsize = 8_192;
		}

		Some(enc)
	}

	#[allow(unsafe_code)]
	/// # Prepare Encoder for Encoding (a small image).
	///
	/// This updates an existing encoder to potentially further optimize a
	/// really small image.
	pub(super) fn prepare_encoder_small(&mut self, img: &DecodedImage) -> bool {
		// Safety: a non-zero response is an error.
		let mut stats = LodePNGColorStats::default();
		if 0 != unsafe {
			lodepng_compute_color_stats(&mut stats, img.buf, img.w, img.h, &self.info_raw)
		} { return false; }

		// The image is too small for tRNS chunk overhead.
		if img.w * img.h <= 16 && 0 != stats.key { stats.alpha = 1; }

		// Set the encoding color mode to RGB/RGBA.
		self.encoder.auto_convert = 0;
		self.info_png.color.colortype = match (0 != stats.colored, 0 != stats.alpha) {
			(true, false) => LodePNGColorType::LCT_RGB,
			(true, true) => LodePNGColorType::LCT_RGBA,
			(false, false) => LodePNGColorType::LCT_GREY,
			(false, true) => LodePNGColorType::LCT_GREY_ALPHA,
		};
		self.info_png.color.bitdepth = 8.min(stats.bits);

		// Rekey if necessary.
		if 0 == stats.alpha && 0 != stats.key {
			self.info_png.color.key_defined = 1;
			self.info_png.color.key_r = c_uint::from(stats.key_r) & 255;
			self.info_png.color.key_g = c_uint::from(stats.key_g) & 255;
			self.info_png.color.key_b = c_uint::from(stats.key_b) & 255;
		}
		else { self.info_png.color.key_defined = 0; }

		true
	}
}



#[cfg(test)]
#[allow(deref_nullptr, non_snake_case, trivial_casts, unsafe_code)]
mod tests {
	use super::*;

	#[test]
	fn t_color_type_is_match() {
		for (p, t) in [
			("skel/assets/png/01.png", LodePNGColorType::LCT_RGB),
			("skel/assets/png/02.png", LodePNGColorType::LCT_RGBA),
			("skel/assets/png/04.png", LodePNGColorType::LCT_GREY),
			("skel/assets/png/small-bwa.png", LodePNGColorType::LCT_GREY_ALPHA),
		] {
			let raw = match std::fs::read(p) {
				Ok(x) => x,
				_ => panic!("Missing {}", p),
			};
			assert!(t.is_match(&raw));
		}

		// Let's test a negative to make sure we aren't doing something silly.
		let raw = std::fs::read("skel/assets/png/01.png").unwrap();
		assert!(! LodePNGColorType::LCT_GREY.is_match(&raw));
	}

	// Generated by build.rs (layout tests).
	include!(concat!(env!("OUT_DIR"), "/lodepng-bindgen-tests.rs"));
}
