/*!
# Flaca
*/

#![deny(unsafe_code)]

#![warn(
	clippy::filetype_is_file,
	clippy::integer_division,
	clippy::needless_borrow,
	clippy::nursery,
	clippy::pedantic,
	clippy::perf,
	clippy::suboptimal_flops,
	clippy::unneeded_field_pattern,
	macro_use_extern_crate,
	missing_copy_implementations,
	missing_debug_implementations,
	missing_docs,
	non_ascii_idents,
	trivial_casts,
	trivial_numeric_casts,
	unreachable_pub,
	unused_crate_dependencies,
	unused_extern_crates,
	unused_import_braces,
)]

#![allow(clippy::module_name_repetitions)]



mod error;
mod image;

pub(crate) use error::FlacaError;
pub(crate) use image::FlacaImage;

use argyle::{
	Argue,
	ArgyleError,
	FLAG_HELP,
	FLAG_REQUIRED,
	FLAG_VERSION,
};
use dowser::{
	Dowser,
	Extension,
};
use fyi_msg::{
	BeforeAfter,
	Msg,
	MsgKind,
	Progless,
};
use rayon::iter::{
	IntoParallelRefIterator,
	ParallelIterator,
};
use std::{
	path::PathBuf,
	sync::{
		Arc,
		atomic::{
			AtomicBool,
			AtomicU64,
			Ordering::SeqCst,
		},
	},
};



// The E_JPEG, E_JPG, and E_PNG constants are generated by build.rs.
include!(concat!(env!("OUT_DIR"), "/flaca-extensions.rs"));



/// # Main.
///
/// This shell provides us a way to easily handle error responses. Actual
/// processing is done by `_main()`.
fn main() {
	match _main() {
		Ok(_) => {},
		Err(FlacaError::Argue(ArgyleError::WantsVersion)) => {
			println!(concat!("Flaca v", env!("CARGO_PKG_VERSION")));
		},
		Err(FlacaError::Argue(ArgyleError::WantsHelp)) => {
			helper();
		},
		Err(e) => {
			Msg::error(e).die(1);
		},
	}
}

#[inline]
#[allow(clippy::cast_possible_truncation)] // It fits.
#[allow(clippy::option_if_let_else)] // This looks bad.
/// # Actual Main.
///
/// This is the actual main, allowing us to easily bubble errors.
fn _main() -> Result<(), FlacaError> {
	// Parse CLI arguments.
	let args = Argue::new(FLAG_HELP | FLAG_REQUIRED | FLAG_VERSION)?
		.with_list();

	// Figure out which kinds we're doing.
	let jpeg: bool = ! args.switch2(b"--no-jpeg", b"--no-jpg");
	let png: bool = ! args.switch(b"--no-png");

	// Find files!
	let paths: Vec<PathBuf> = match (jpeg, png) {
		// Both.
		(true, true) => Dowser::default()
			.with_paths(args.args_os())
			.into_vec(|p|
				Extension::try_from3(p).map_or_else(
					|| Some(E_JPEG) == Extension::try_from4(p),
					|e| e == E_JPG || e == E_PNG
				)
			),
		// JPEG.
		(true, false) => Dowser::default()
			.with_paths(args.args_os())
			.into_vec(|p|
				Extension::try_from3(p).map_or_else(
					|| Some(E_JPEG) == Extension::try_from4(p),
					|e| e == E_JPG
				)
			),
		// PNG.
		(false, true) => Dowser::default()
			.with_paths(args.args_os())
			.into_vec(|p| Some(E_PNG) == Extension::try_from3(p)),
		// Nothing?!
		(false, false) => Vec::new(),
	};

	if paths.is_empty() {
		return Err(FlacaError::NoImages);
	}

	// Should we show progress?
	let progress =
		if args.switch2(b"-p", b"--progress") {
			if paths.len() <= Progless::MAX_TOTAL { true }
			else {
				Msg::warning(Progless::MAX_TOTAL_ERROR).print();
				false
			}
		}
		else { false };

	// Watch for SIGINT so we can shut down cleanly.
	let killed = Arc::from(AtomicBool::new(false));
	let _res = signal_hook::flag::register(
		signal_hook::consts::SIGINT,
		Arc::clone(&killed)
	);

	// Initialize our global oxipng compression settings. Doing it here is a
	// bit strange, but less contentious than leveraging a lazy static within
	// FlacaImage itself (particularly at scale). As a bonus, the memory can be
	// freed afterward, making Valgrind happier.
	let oxi = image::oxipng_options();

	// Sexy run-through.
	if progress {
		// Boot up a progress bar.
		let progress = Progless::try_from(paths.len() as u32)
			.unwrap()
			.with_reticulating_splines("Flaca");

		// Keep track of the before and after file sizes as we go.
		let before: AtomicU64 = AtomicU64::new(0);
		let after: AtomicU64 = AtomicU64::new(0);

		// Process!
		paths.par_iter().for_each(|x|
			if killed.load(SeqCst) { progress.sigint(); }
			else {
				// Encode if we can.
				if let Some(mut enc) = FlacaImage::new(x, jpeg, png) {
					let tmp = x.to_string_lossy();
					progress.add(&tmp);

					let (b, a) = enc.compress(&oxi);
					before.fetch_add(b, SeqCst);
					after.fetch_add(a, SeqCst);

					progress.remove(&tmp);
				}
				// Bump the count if we can't.
				else {
					progress.increment();
				}
			}
		);

		// Finish up.
		progress.finish();

		// Print a summary.
		progress.summary(MsgKind::Crunched, "image", "images")
			.with_bytes_saved(BeforeAfter::from((
				before.load(SeqCst),
				after.load(SeqCst),
			)))
			.print();
	}
	else {
		// Process!
		paths.par_iter().for_each(|x|
			if ! killed.load(SeqCst) {
				if let Some(mut enc) = FlacaImage::new(x, jpeg, png) {
					let _res = enc.compress(&oxi);
				}
			}
		);
	}

	// Early abort?
	if killed.load(SeqCst) { Err(FlacaError::Killed) }
	else { Ok(()) }
}

#[cold]
/// # Print Help.
fn helper() {
	println!(concat!(
		r"
             ,--._,--.
           ,'  ,'   ,-`.
(`-.__    /  ,'   /
 `.   `--'        \__,--'-.
   `--/       ,-.  ______/
     (o-.     ,o- /
      `. ;        \    ", "\x1b[38;5;199mFlaca\x1b[0;38;5;69m v", env!("CARGO_PKG_VERSION"), "\x1b[0m", r"
       |:          \   Brute-force, lossless
      ,'`       ,   \  JPEG and PNG compression.
     (o o ,  --'     :
      \--','.        ;
       `;;  :       /
        ;'  ;  ,' ,'
        ,','  :  '
        \ \   :
         `

USAGE:
    flaca [FLAGS] [OPTIONS] <PATH(S)>...

FLAGS:
    -h, --help        Print help information and exit.
        --no-jpeg     Skip JPEG images.
        --no-png      Skip PNG images.
    -p, --progress    Show progress bar while minifying.
    -V, --version     Print version information and exit.

OPTIONS:
    -l, --list <FILE> Read (absolute) image and/or directory paths from this
                      text file, one entry per line.

ARGS:
    <PATH(S)>...      One or more image and/or directory paths to losslessly
                      compress.

OPTIMIZERS USED:
    MozJPEG   <https://github.com/mozilla/mozjpeg>
    Oxipng    <https://github.com/shssoichiro/oxipng>
    Zopflipng <https://github.com/google/zopfli>
"
	));
}
