/*!
# Flaca
*/

#![deny(unsafe_code)]

#![warn(
	clippy::filetype_is_file,
	clippy::integer_division,
	clippy::needless_borrow,
	clippy::nursery,
	clippy::pedantic,
	clippy::perf,
	clippy::suboptimal_flops,
	clippy::unneeded_field_pattern,
	macro_use_extern_crate,
	missing_copy_implementations,
	missing_debug_implementations,
	missing_docs,
	non_ascii_idents,
	trivial_casts,
	trivial_numeric_casts,
	unreachable_pub,
	unused_crate_dependencies,
	unused_extern_crates,
	unused_import_braces,
)]

#![allow(
	clippy::module_name_repetitions,
	clippy::redundant_pub_crate,
)]



mod error;
mod image;

pub(crate) use error::FlacaError;
pub(crate) use image::kind::ImageKind;

use argyle::{
	Argue,
	ArgyleError,
	FLAG_HELP,
	FLAG_REQUIRED,
	FLAG_VERSION,
};
use dactyl::{
	NiceElapsed,
	NiceU64,
	traits::{
		BytesToSigned,
		BytesToUnsigned,
		NiceInflection,
	},
};
use dowser::{
	Dowser,
	Extension,
};
use fyi_msg::{
	BeforeAfter,
	Msg,
	MsgKind,
	Progless,
};
use rayon::iter::{
	IndexedParallelIterator,
	IntoParallelRefIterator,
	ParallelIterator,
};
use std::{
	num::NonZeroUsize,
	path::Path,
	sync::{
		Arc,
		atomic::{
			AtomicBool,
			AtomicU64,
			Ordering::{
				Acquire,
				Relaxed,
				SeqCst,
			},
		},
		OnceLock,
	},
};



// The E_JPEG, E_JPG, and E_PNG constants are generated by build.rs.
include!(concat!(env!("OUT_DIR"), "/flaca-extensions.rs"));

/// # Number of Zopfli Iterations.
pub(crate) static ZOPFLI_ITERATIONS: OnceLock<i32> = OnceLock::new();



/// # Main.
///
/// This shell provides us a way to easily handle error responses. Actual
/// processing is done by `_main()`.
fn main() {
	match _main() {
		Ok(()) => {},
		Err(FlacaError::Argue(ArgyleError::WantsVersion)) => {
			println!(concat!("Flaca v", env!("CARGO_PKG_VERSION")));
		},
		Err(FlacaError::Argue(ArgyleError::WantsHelp)) => {
			helper();
		},
		Err(e) => {
			Msg::error(e).die(1);
		},
	}
}

#[inline]
/// # Actual Main.
///
/// This is the actual main, allowing us to easily bubble errors.
fn _main() -> Result<(), FlacaError> {
	// Parse CLI arguments.
	let args = Argue::new(FLAG_HELP | FLAG_REQUIRED | FLAG_VERSION)?
		.with_list();

	// Figure out which kinds we're doing.
	let mut kinds = ImageKind::All;
	if args.switch2(b"--no-jpeg", b"--no-jpg") { kinds &= ! (ImageKind::Jpeg as u8); }
	if args.switch(b"--no-png") { kinds &= ! (ImageKind::Png as u8); }
	if ImageKind::None == kinds { return Err(FlacaError::NoImages); }

	// Zopfli iterations.
	if let Some(n) = args.option(b"-z") {
		let n = i32::btoi(n)
			.filter(|n| 0 < *n)
			.ok_or(FlacaError::ZopfliIterations)?;
		let _res = ZOPFLI_ITERATIONS.set(n);
	}

	let paths = Dowser::default()
		.with_paths(args.args_os())
		.into_vec_filtered(|p| Extension::try_from3(p).map_or_else(
			|| Some(E_JPEG) == Extension::try_from4(p),
			|e| e == E_JPG || e == E_PNG
		));

	let total = paths.len() as u64;
	if total == 0 {
		return Err(FlacaError::NoImages);
	}

	// Watch for SIGINT so we can shut down cleanly.
	let killed = Arc::from(AtomicBool::new(false));

	// Initialize the oxipng compression options. Doing that here is a bit
	// strange, but it is less contentious to use a shared reference to this
	// object than to try to leverage a Lazy Static in a more appropriate
	// location.
	let oxi = image::oxipng_options();

	// Set up a threadpool for our workload.
	let mut threads = std::thread::available_parallelism().unwrap_or(NonZeroUsize::MIN);
	if let Some(t) = args.option(b"-j") {
		if let Some(t) = t.strip_prefix(b"-").and_then(NonZeroUsize::btou) {
			threads = threads.get().checked_sub(t.get())
				.and_then(NonZeroUsize::new)
				.unwrap_or(NonZeroUsize::MIN);
		}
		else if let Some(t) = NonZeroUsize::btou(t) {
			if t < threads { threads = t; }
		}
	}
	let pool = rayon::ThreadPoolBuilder::new()
		.num_threads(threads.get())
		.build()
		.map_err(|_| FlacaError::NoThreads)?;

	// Sexy run-through.
	if args.switch2(b"-p", b"--progress") {
		// Boot up a progress bar.
		let progress = Progless::try_from(total)?.with_reticulating_splines("Flaca");

		// Keep track of the before and after file sizes as we go.
		let skipped: AtomicU64 = AtomicU64::new(0);
		let before: AtomicU64 = AtomicU64::new(0);
		let after: AtomicU64 = AtomicU64::new(0);

		// Process!
		sigint(Arc::clone(&killed), Some(progress.clone()));
		pool.install(|| paths.par_iter().with_max_len(1).for_each(|x|
			if ! killed.load(Acquire) {
				let tmp = x.to_string_lossy();
				progress.add(&tmp);

				match image::encode(x, kinds, &oxi) {
					// The file is empty.
					Some((0, 0)) => {
						skipped.fetch_add(1, Relaxed);
						skip_warn(x, kinds, "Empty file", &progress);
					},
					// The image was intentionally skipped.
					Some((_, 0)) => { skipped.fetch_add(1, Relaxed); },
					// The image was processed and maybe updated.
					Some((b, a)) => {
						before.fetch_add(b, Relaxed);
						after.fetch_add(a, Relaxed);
					},
					// The image could not be read or decoded.
					None => {
						skipped.fetch_add(1, Relaxed);
						skip_warn(x, kinds, "Unrecognized format", &progress);
					},
				}

				progress.remove(&tmp);
			}
		));

		// Print a summary.
		let elapsed = progress.finish();
		let skipped = skipped.load(Acquire);
		if skipped == 0 {
			progress.summary(MsgKind::Crunched, "image", "images")
		}
		else {
			// And summarize what we did do.
			Msg::crunched(format!(
				"{}\x1b[2m/\x1b[0m{} in {}.",
				NiceU64::from(total - skipped),
				total.nice_inflect("image", "images"),
				NiceElapsed::from(elapsed),
			))
		}
			.with_bytes_saved(BeforeAfter::from((
				before.into_inner(),
				after.into_inner(),
			)))
			.eprint();
	}
	// Silent run-through.
	else {
		sigint(Arc::clone(&killed), None);
		pool.install(|| paths.par_iter().for_each(|x| if ! killed.load(Acquire) {
			let _res = image::encode(x, kinds, &oxi);
		}));
	}

	// Early abort?
	if killed.load(Acquire) { Err(FlacaError::Killed) }
	else { Ok(()) }
}

#[cold]
/// # Print Help.
fn helper() {
	println!(concat!(
		r"
             ,--._,--.
           ,'  ,'   ,-`.
(`-.__    /  ,'   /
 `.   `--'        \__,--'-.
   `--/       ,-.  ______/
     (o-.     ,o- /
      `. ;        \    ", "\x1b[38;5;199mFlaca\x1b[0;38;5;69m v", env!("CARGO_PKG_VERSION"), "\x1b[0m", r#"
       |:          \   Brute-force, lossless
      ,'`       ,   \  JPEG and PNG compression.
     (o o ,  --'     :
      \--','.        ;
       `;;  :       /
        ;'  ;  ,' ,'
        ,','  :  '
        \ \   :
         `

USAGE:
    flaca [FLAGS] [OPTIONS] <PATH(S)>...

FLAGS:
    -h, --help        Print help information and exit.
        --no-jpeg     Skip JPEG images.
        --no-png      Skip PNG images.
    -p, --progress    Show progress bar while minifying.
    -V, --version     Print version information and exit.

OPTIONS:
    -j <NUM>          Limit parallelization to this many threads (instead of
                      giving each logical core its own image to work on). If
                      negative, the value will be subtracted from the total
                      number of logical cores.
    -l, --list <FILE> Read (absolute) image and/or directory paths from this
                      text file — or STDIN if "-" — one entry per line, instead
                      of or in addition to (actually trailing) <PATH(S)>.
    -z <NUM>          Run NUM lz77 backward/forward iterations during zopfli
                      PNG encoding passes. More iterations yield better
                      compression (up to a point), but require *significantly*
                      longer processing times. In practice, values beyond 500
                      are unlikely to save more than a few bytes, and could
                      take *days* to complete! Haha. [default: 20 or 60,
                      depending on the file size]
ARGS:
    <PATH(S)>...      One or more image and/or directory paths to losslessly
                      compress.

EARLY EXIT:
    Press "#, "\x1b[38;5;208mCTRL\x1b[0m+\x1b[38;5;208mC\x1b[0m once to quit as soon as the already-in-progress operations
    have finished (ignoring any pending images still in the queue).

    Press \x1b[38;5;208mCTRL\x1b[0m+\x1b[38;5;208mC\x1b[0m a second time if you need to exit IMMEDIATELY, but note that
    doing so may leave artifacts (temporary files) behind, and in rare cases,
    lead to image corruption.

OPTIMIZERS USED:
    MozJPEG   <https://github.com/mozilla/mozjpeg>
    Oxipng    <https://github.com/shssoichiro/oxipng>
    Zopflipng <https://github.com/google/zopfli>
"
	));
}

/// # Hook Up CTRL+C.
///
/// Once stops processing new items, twice forces immediate shutdown.
fn sigint(killed: Arc<AtomicBool>, progress: Option<Progless>) {
	let _res = ctrlc::set_handler(move ||
		if killed.compare_exchange(false, true, SeqCst, Relaxed).is_ok() {
			if let Some(p) = &progress { p.sigint(); }
		}
		else { std::process::exit(1); }
	);
}

/// # Maybe Warn About a Skip.
fn skip_warn(file: &Path, kinds: ImageKind, note: &str, progress: &Progless) {
	// If we're only compressing one or the other kind of image, make sure the
	// file extension belongs to that kind before complaining about it.
	if kinds != ImageKind::All {
		let file_kind =
			if Some(E_PNG) == Extension::try_from3(file) { ImageKind::Png }
			else { ImageKind::Jpeg };
		if ImageKind::None == kinds & file_kind { return; }
	}

	progress.push_msg(Msg::custom("Skipped", 11, &format!(
		"{} \x1b[2m({note}.)\x1b[0m",
		file.to_string_lossy()
	)), true);
}
