/*!
# Flaca
*/

#![deny(unsafe_code)]

#![warn(
	clippy::filetype_is_file,
	clippy::integer_division,
	clippy::needless_borrow,
	clippy::nursery,
	clippy::pedantic,
	clippy::perf,
	clippy::suboptimal_flops,
	clippy::unneeded_field_pattern,
	macro_use_extern_crate,
	missing_copy_implementations,
	missing_debug_implementations,
	missing_docs,
	non_ascii_idents,
	trivial_casts,
	trivial_numeric_casts,
	unreachable_pub,
	unused_crate_dependencies,
	unused_extern_crates,
	unused_import_braces,
)]

#![allow(
	clippy::module_name_repetitions,
	clippy::redundant_pub_crate,
)]



mod error;
mod image;

pub(crate) use error::FlacaError;
pub(crate) use image::kind::ImageKind;

use argyle::{
	Argue,
	ArgyleError,
	FLAG_HELP,
	FLAG_REQUIRED,
	FLAG_VERSION,
};
use dactyl::{
	NiceElapsed,
	NiceU64,
	traits::{
		BytesToSigned,
		NiceInflection,
	},
};
use dowser::{
	Dowser,
	Extension,
};
use fyi_msg::{
	BeforeAfter,
	Msg,
	MsgKind,
	Progless,
};
use rayon::iter::{
	IndexedParallelIterator,
	IntoParallelRefIterator,
	ParallelIterator,
};
use std::sync::{
	Arc,
	atomic::{
		AtomicBool,
		AtomicU64,
		Ordering::{
			Acquire,
			Relaxed,
			SeqCst,
		},
	},
	Mutex,
	OnceLock,
};



// The E_JPEG, E_JPG, and E_PNG constants are generated by build.rs.
include!(concat!(env!("OUT_DIR"), "/flaca-extensions.rs"));

/// # Number of Zopfli Iterations.
pub(crate) static ZOPFLI_ITERATIONS: OnceLock<i32> = OnceLock::new();



/// # Main.
///
/// This shell provides us a way to easily handle error responses. Actual
/// processing is done by `_main()`.
fn main() {
	match _main() {
		Ok(()) => {},
		Err(FlacaError::Argue(ArgyleError::WantsVersion)) => {
			println!(concat!("Flaca v", env!("CARGO_PKG_VERSION")));
		},
		Err(FlacaError::Argue(ArgyleError::WantsHelp)) => {
			helper();
		},
		Err(e) => {
			Msg::error(e).die(1);
		},
	}
}

#[inline]
/// # Actual Main.
///
/// This is the actual main, allowing us to easily bubble errors.
fn _main() -> Result<(), FlacaError> {
	// Parse CLI arguments.
	let args = Argue::new(FLAG_HELP | FLAG_REQUIRED | FLAG_VERSION)?
		.with_list();

	// Figure out which kinds we're doing.
	let mut kinds = ImageKind::All;
	if args.switch2(b"--no-jpeg", b"--no-jpg") { kinds &= ! (ImageKind::Jpeg as u8); }
	if args.switch(b"--no-png") { kinds &= ! (ImageKind::Png as u8); }
	if ImageKind::None == kinds { return Err(FlacaError::NoImages); }

	// Zopfli iterations.
	if let Some(n) = args.option(b"-z") {
		let n = i32::btoi(n)
			.filter(|n| 0 < *n)
			.ok_or(FlacaError::ZopfliIterations)?;
		let _res = ZOPFLI_ITERATIONS.set(n);
	}

	let paths = Dowser::default()
		.with_paths(args.args_os())
		.into_vec_filtered(|p| Extension::try_from3(p).map_or_else(
			|| Some(E_JPEG) == Extension::try_from4(p),
			|e| e == E_JPG || e == E_PNG
		));

	let total = paths.len() as u64;
	if total == 0 {
		return Err(FlacaError::NoImages);
	}

	// Watch for SIGINT so we can shut down cleanly.
	let killed = Arc::from(AtomicBool::new(false));

	// Initialize the oxipng compression options. Doing that here is a bit
	// strange, but it is less contentious to use a shared reference to this
	// object than to try to leverage a Lazy Static in a more appropriate
	// location.
	let oxi = image::oxipng_options();

	// Sexy run-through.
	if args.switch2(b"-p", b"--progress") {
		// Boot up a progress bar.
		let progress = Progless::try_from(total)?.with_reticulating_splines("Flaca");

		// Keep track of the before and after file sizes as we go.
		let invalid = Arc::new(Mutex::new(Vec::new()));
		let skipped: AtomicU64 = AtomicU64::new(0);
		let before: AtomicU64 = AtomicU64::new(0);
		let after: AtomicU64 = AtomicU64::new(0);

		// Process!
		sigint(Arc::clone(&killed), Some(progress.clone()));
		paths.par_iter().with_max_len(1).for_each(|x|
			if ! killed.load(Acquire) {
				let tmp = x.to_string_lossy();
				progress.add(&tmp);

				match image::encode(x, kinds, &oxi) {
					// Not a JPEG or PNG. (Empty files are returned as None.)
					Some((0, 0)) => {
						if let Ok(mut ptr) = invalid.lock() {
							ptr.push(tmp.clone());
						}
						skipped.fetch_add(1, Relaxed);
					},
					// The image was processed and maybe updated.
					Some((b, a)) => {
						before.fetch_add(b, Relaxed);
						after.fetch_add(a, Relaxed);
					},
					// The image was skipped for any reason other than it
					// having non-JPEG/PNG content.
					None => { skipped.fetch_add(1, Relaxed); },
				}

				progress.remove(&tmp);
			}
		);

		// Print a summary.
		let elapsed = progress.finish();
		let skipped = skipped.load(Acquire);
		if skipped == 0 {
			progress.summary(MsgKind::Crunched, "image", "images")
		}
		else {
			Msg::crunched(format!(
				"{}\x1b[2m/\x1b[0m{} in {}.",
				NiceU64::from(total - skipped),
				total.nice_inflect("image", "images"),
				NiceElapsed::from(elapsed),
			))
		}
			.with_bytes_saved(BeforeAfter::from((
				before.into_inner(),
				after.into_inner(),
			)))
			.eprint();

		// If there were errors, print 'em.
		if let Some(invalid) = Arc::try_unwrap(invalid).ok().and_then(|m| m.into_inner().ok()) {
			if ! invalid.is_empty() {
				Msg::warning(format!(
					"{} could not be decoded:",
					invalid.len().nice_inflect("image", "images"),
				)).eprint();
				for v in invalid {
					eprintln!("    \x1b[2m{v}\x1b[0m");
				}
			}
		}
	}
	// Silent run-through.
	else {
		sigint(Arc::clone(&killed), None);
		paths.par_iter().for_each(|x| if ! killed.load(Acquire) {
			let _res = image::encode(x, kinds, &oxi);
		});
	}

	// Early abort?
	if killed.load(Acquire) { Err(FlacaError::Killed) }
	else { Ok(()) }
}

#[cold]
/// # Print Help.
fn helper() {
	println!(concat!(
		r"
             ,--._,--.
           ,'  ,'   ,-`.
(`-.__    /  ,'   /
 `.   `--'        \__,--'-.
   `--/       ,-.  ______/
     (o-.     ,o- /
      `. ;        \    ", "\x1b[38;5;199mFlaca\x1b[0;38;5;69m v", env!("CARGO_PKG_VERSION"), "\x1b[0m", r#"
       |:          \   Brute-force, lossless
      ,'`       ,   \  JPEG and PNG compression.
     (o o ,  --'     :
      \--','.        ;
       `;;  :       /
        ;'  ;  ,' ,'
        ,','  :  '
        \ \   :
         `

USAGE:
    flaca [FLAGS] [OPTIONS] <PATH(S)>...

FLAGS:
    -h, --help        Print help information and exit.
        --no-jpeg     Skip JPEG images.
        --no-png      Skip PNG images.
    -p, --progress    Show progress bar while minifying.
    -V, --version     Print version information and exit.

OPTIONS:
    -l, --list <FILE> Read (absolute) image and/or directory paths from this
                      text file — or STDIN if "-" — one entry per line, instead
                      of or in addition to (actually trailing) <PATH(S)>.
    -z <NUM>          Run NUM lz77 backward/forward iterations during zopfli
                      PNG encoding passes. More iterations yield better
                      compression (up to a point), but require *significantly*
                      longer processing times. In practice, values beyond 500
                      are unlikely to save more than a few bytes, and could
                      take *days* to complete! Haha. [default: 20 or 60,
                      depending on the file size]
ARGS:
    <PATH(S)>...      One or more image and/or directory paths to losslessly
                      compress.

EARLY EXIT:
    Press "#, "\x1b[38;5;208mCTRL\x1b[0m+\x1b[38;5;208mC\x1b[0m once to quit as soon as the already-in-progress operations
    have finished (ignoring any pending images still in the queue).

    Press \x1b[38;5;208mCTRL\x1b[0m+\x1b[38;5;208mC\x1b[0m a second time if you need to exit IMMEDIATELY, but note that
    doing so may leave artifacts (temporary files) behind, and in rare cases,
    lead to image corruption.

OPTIMIZERS USED:
    MozJPEG   <https://github.com/mozilla/mozjpeg>
    Oxipng    <https://github.com/shssoichiro/oxipng>
    Zopflipng <https://github.com/google/zopfli>
"
	));
}

/// # Hook Up CTRL+C.
///
/// Once stops processing new items, twice forces immediate shutdown.
fn sigint(killed: Arc<AtomicBool>, progress: Option<Progless>) {
	let _res = ctrlc::set_handler(move ||
		if killed.compare_exchange(false, true, SeqCst, Relaxed).is_ok() {
			if let Some(p) = &progress { p.sigint(); }
		}
		else { std::process::exit(1); }
	);
}
